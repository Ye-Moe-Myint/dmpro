{"ast":null,"code":"// A passthrough read/write stream that sets its properties\n// based on a header, extendedHeader, and globalHeader\n//\n// Can be either a file system object of some sort, or\n// a pax/ustar metadata entry.\n\nmodule.exports = Entry;\nvar TarHeader = require(\"./header.js\"),\n  tar = require(\"../tar\"),\n  assert = require(\"assert\").ok,\n  Stream = require(\"stream\").Stream,\n  inherits = require(\"inherits\"),\n  fstream = require(\"fstream\").Abstract;\nfunction Entry(header, extended, global) {\n  Stream.call(this);\n  this.readable = true;\n  this.writable = true;\n  this._needDrain = false;\n  this._paused = false;\n  this._reading = false;\n  this._ending = false;\n  this._ended = false;\n  this._remaining = 0;\n  this._abort = false;\n  this._queue = [];\n  this._index = 0;\n  this._queueLen = 0;\n  this._read = this._read.bind(this);\n  this.props = {};\n  this._header = header;\n  this._extended = extended || {};\n\n  // globals can change throughout the course of\n  // a file parse operation.  Freeze it at its current state.\n  this._global = {};\n  var me = this;\n  Object.keys(global || {}).forEach(function (g) {\n    me._global[g] = global[g];\n  });\n  this._setProps();\n}\ninherits(Entry, Stream);\nEntry.prototype.write = function (c) {\n  if (this._ending) this.error(\"write() after end()\", null, true);\n  if (this._remaining === 0) {\n    this.error(\"invalid bytes past eof\");\n  }\n\n  // often we'll get a bunch of \\0 at the end of the last write,\n  // since chunks will always be 512 bytes when reading a tarball.\n  if (c.length > this._remaining) {\n    c = c.slice(0, this._remaining);\n  }\n  this._remaining -= c.length;\n\n  // put it on the stack.\n  var ql = this._queueLen;\n  this._queue.push(c);\n  this._queueLen++;\n  this._read();\n\n  // either paused, or buffered\n  if (this._paused || ql > 0) {\n    this._needDrain = true;\n    return false;\n  }\n  return true;\n};\nEntry.prototype.end = function (c) {\n  if (c) this.write(c);\n  this._ending = true;\n  this._read();\n};\nEntry.prototype.pause = function () {\n  this._paused = true;\n  this.emit(\"pause\");\n};\nEntry.prototype.resume = function () {\n  // console.error(\"    Tar Entry resume\", this.path)\n  this.emit(\"resume\");\n  this._paused = false;\n  this._read();\n  return this._queueLen - this._index > 1;\n};\n\n// This is bound to the instance\nEntry.prototype._read = function () {\n  // console.error(\"    Tar Entry _read\", this.path)\n\n  if (this._paused || this._reading || this._ended) return;\n\n  // set this flag so that event handlers don't inadvertently\n  // get multiple _read() calls running.\n  this._reading = true;\n\n  // have any data to emit?\n  while (this._index < this._queueLen && !this._paused) {\n    var chunk = this._queue[this._index++];\n    this.emit(\"data\", chunk);\n  }\n\n  // check if we're drained\n  if (this._index >= this._queueLen) {\n    this._queue.length = this._queueLen = this._index = 0;\n    if (this._needDrain) {\n      this._needDrain = false;\n      this.emit(\"drain\");\n    }\n    if (this._ending) {\n      this._ended = true;\n      this.emit(\"end\");\n    }\n  }\n\n  // if the queue gets too big, then pluck off whatever we can.\n  // this should be fairly rare.\n  var mql = this._maxQueueLen;\n  if (this._queueLen > mql && this._index > 0) {\n    mql = Math.min(this._index, mql);\n    this._index -= mql;\n    this._queueLen -= mql;\n    this._queue = this._queue.slice(mql);\n  }\n  this._reading = false;\n};\nEntry.prototype._setProps = function () {\n  // props = extended->global->header->{}\n  var header = this._header,\n    extended = this._extended,\n    global = this._global,\n    props = this.props;\n\n  // first get the values from the normal header.\n  var fields = tar.fields;\n  for (var f = 0; fields[f] !== null; f++) {\n    var field = fields[f],\n      val = header[field];\n    if (typeof val !== \"undefined\") props[field] = val;\n  }\n\n  // next, the global header for this file.\n  // numeric values, etc, will have already been parsed.\n  ;\n  [global, extended].forEach(function (p) {\n    Object.keys(p).forEach(function (f) {\n      if (typeof p[f] !== \"undefined\") props[f] = p[f];\n    });\n  })\n\n  // no nulls allowed in path or linkpath\n  ;\n  [\"path\", \"linkpath\"].forEach(function (p) {\n    if (props.hasOwnProperty(p)) {\n      props[p] = props[p].split(\"\\0\")[0];\n    }\n  })\n\n  // set date fields to be a proper date\n  ;\n  [\"mtime\", \"ctime\", \"atime\"].forEach(function (p) {\n    if (props.hasOwnProperty(p)) {\n      props[p] = new Date(props[p] * 1000);\n    }\n  });\n\n  // set the type so that we know what kind of file to create\n  var type;\n  switch (tar.types[props.type]) {\n    case \"OldFile\":\n    case \"ContiguousFile\":\n      type = \"File\";\n      break;\n    case \"GNUDumpDir\":\n      type = \"Directory\";\n      break;\n    case undefined:\n      type = \"Unknown\";\n      break;\n    case \"Link\":\n    case \"SymbolicLink\":\n    case \"CharacterDevice\":\n    case \"BlockDevice\":\n    case \"Directory\":\n    case \"FIFO\":\n    default:\n      type = tar.types[props.type];\n  }\n  this.type = type;\n  this.path = props.path;\n  this.size = props.size;\n\n  // size is special, since it signals when the file needs to end.\n  this._remaining = props.size;\n};\n\n// the parser may not call write if _abort is true. \n// useful for skipping data from some files quickly.\nEntry.prototype.abort = function () {\n  this._abort = true;\n};\nEntry.prototype.warn = fstream.warn;\nEntry.prototype.error = fstream.error;","map":{"version":3,"names":["module","exports","Entry","TarHeader","require","tar","assert","ok","Stream","inherits","fstream","Abstract","header","extended","global","call","readable","writable","_needDrain","_paused","_reading","_ending","_ended","_remaining","_abort","_queue","_index","_queueLen","_read","bind","props","_header","_extended","_global","me","Object","keys","forEach","g","_setProps","prototype","write","c","error","length","slice","ql","push","end","pause","emit","resume","chunk","mql","_maxQueueLen","Math","min","fields","f","field","val","p","hasOwnProperty","split","Date","type","types","undefined","path","size","abort","warn"],"sources":["/Users/lieo/diabetes/CUT2DMTest/node_modules/node-gyp/node_modules/tar/lib/entry.js"],"sourcesContent":["// A passthrough read/write stream that sets its properties\n// based on a header, extendedHeader, and globalHeader\n//\n// Can be either a file system object of some sort, or\n// a pax/ustar metadata entry.\n\nmodule.exports = Entry\n\nvar TarHeader = require(\"./header.js\")\n  , tar = require(\"../tar\")\n  , assert = require(\"assert\").ok\n  , Stream = require(\"stream\").Stream\n  , inherits = require(\"inherits\")\n  , fstream = require(\"fstream\").Abstract\n\nfunction Entry (header, extended, global) {\n  Stream.call(this)\n  this.readable = true\n  this.writable = true\n\n  this._needDrain = false\n  this._paused = false\n  this._reading = false\n  this._ending = false\n  this._ended = false\n  this._remaining = 0\n  this._abort = false\n  this._queue = []\n  this._index = 0\n  this._queueLen = 0\n\n  this._read = this._read.bind(this)\n\n  this.props = {}\n  this._header = header\n  this._extended = extended || {}\n\n  // globals can change throughout the course of\n  // a file parse operation.  Freeze it at its current state.\n  this._global = {}\n  var me = this\n  Object.keys(global || {}).forEach(function (g) {\n    me._global[g] = global[g]\n  })\n\n  this._setProps()\n}\n\ninherits(Entry, Stream)\n\nEntry.prototype.write = function (c) {\n  if (this._ending) this.error(\"write() after end()\", null, true)\n  if (this._remaining === 0) {\n    this.error(\"invalid bytes past eof\")\n  }\n\n  // often we'll get a bunch of \\0 at the end of the last write,\n  // since chunks will always be 512 bytes when reading a tarball.\n  if (c.length > this._remaining) {\n    c = c.slice(0, this._remaining)\n  }\n  this._remaining -= c.length\n\n  // put it on the stack.\n  var ql = this._queueLen\n  this._queue.push(c)\n  this._queueLen ++\n\n  this._read()\n\n  // either paused, or buffered\n  if (this._paused || ql > 0) {\n    this._needDrain = true\n    return false\n  }\n\n  return true\n}\n\nEntry.prototype.end = function (c) {\n  if (c) this.write(c)\n  this._ending = true\n  this._read()\n}\n\nEntry.prototype.pause = function () {\n  this._paused = true\n  this.emit(\"pause\")\n}\n\nEntry.prototype.resume = function () {\n  // console.error(\"    Tar Entry resume\", this.path)\n  this.emit(\"resume\")\n  this._paused = false\n  this._read()\n  return this._queueLen - this._index > 1\n}\n\n  // This is bound to the instance\nEntry.prototype._read = function () {\n  // console.error(\"    Tar Entry _read\", this.path)\n\n  if (this._paused || this._reading || this._ended) return\n\n  // set this flag so that event handlers don't inadvertently\n  // get multiple _read() calls running.\n  this._reading = true\n\n  // have any data to emit?\n  while (this._index < this._queueLen && !this._paused) {\n    var chunk = this._queue[this._index ++]\n    this.emit(\"data\", chunk)\n  }\n\n  // check if we're drained\n  if (this._index >= this._queueLen) {\n    this._queue.length = this._queueLen = this._index = 0\n    if (this._needDrain) {\n      this._needDrain = false\n      this.emit(\"drain\")\n    }\n    if (this._ending) {\n      this._ended = true\n      this.emit(\"end\")\n    }\n  }\n\n  // if the queue gets too big, then pluck off whatever we can.\n  // this should be fairly rare.\n  var mql = this._maxQueueLen\n  if (this._queueLen > mql && this._index > 0) {\n    mql = Math.min(this._index, mql)\n    this._index -= mql\n    this._queueLen -= mql\n    this._queue = this._queue.slice(mql)\n  }\n\n  this._reading = false\n}\n\nEntry.prototype._setProps = function () {\n  // props = extended->global->header->{}\n  var header = this._header\n    , extended = this._extended\n    , global = this._global\n    , props = this.props\n\n  // first get the values from the normal header.\n  var fields = tar.fields\n  for (var f = 0; fields[f] !== null; f ++) {\n    var field = fields[f]\n      , val = header[field]\n    if (typeof val !== \"undefined\") props[field] = val\n  }\n\n  // next, the global header for this file.\n  // numeric values, etc, will have already been parsed.\n  ;[global, extended].forEach(function (p) {\n    Object.keys(p).forEach(function (f) {\n      if (typeof p[f] !== \"undefined\") props[f] = p[f]\n    })\n  })\n\n  // no nulls allowed in path or linkpath\n  ;[\"path\", \"linkpath\"].forEach(function (p) {\n    if (props.hasOwnProperty(p)) {\n      props[p] = props[p].split(\"\\0\")[0]\n    }\n  })\n\n\n  // set date fields to be a proper date\n  ;[\"mtime\", \"ctime\", \"atime\"].forEach(function (p) {\n    if (props.hasOwnProperty(p)) {\n      props[p] = new Date(props[p] * 1000)\n    }\n  })\n\n  // set the type so that we know what kind of file to create\n  var type\n  switch (tar.types[props.type]) {\n    case \"OldFile\":\n    case \"ContiguousFile\":\n      type = \"File\"\n      break\n\n    case \"GNUDumpDir\":\n      type = \"Directory\"\n      break\n\n    case undefined:\n      type = \"Unknown\"\n      break\n\n    case \"Link\":\n    case \"SymbolicLink\":\n    case \"CharacterDevice\":\n    case \"BlockDevice\":\n    case \"Directory\":\n    case \"FIFO\":\n    default:\n      type = tar.types[props.type]\n  }\n\n  this.type = type\n  this.path = props.path\n  this.size = props.size\n\n  // size is special, since it signals when the file needs to end.\n  this._remaining = props.size\n}\n\n// the parser may not call write if _abort is true. \n// useful for skipping data from some files quickly.\nEntry.prototype.abort = function(){\n  this._abort = true\n}\n\nEntry.prototype.warn = fstream.warn\nEntry.prototype.error = fstream.error\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}