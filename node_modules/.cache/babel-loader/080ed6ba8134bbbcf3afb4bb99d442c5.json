{"ast":null,"code":"'use strict';\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\nvar _assertThisInitialized = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _get = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _createClass = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar PackJob = /*#__PURE__*/_createClass(function PackJob(path, absolute) {\n  _classCallCheck(this, PackJob);\n  this.path = path || './';\n  this.absolute = absolute;\n  this.entry = null;\n  this.stat = null;\n  this.readdir = null;\n  this.pending = false;\n  this.ignore = false;\n  this.piped = false;\n});\nvar MiniPass = require('minipass');\nvar zlib = require('minizlib');\nvar ReadEntry = require('./read-entry.js');\nvar WriteEntry = require('./write-entry.js');\nvar WriteEntrySync = WriteEntry.Sync;\nvar WriteEntryTar = WriteEntry.Tar;\nvar Yallist = require('yallist');\nvar EOF = Buffer.alloc(1024);\nvar ONSTAT = Symbol('onStat');\nvar ENDED = Symbol('ended');\nvar QUEUE = Symbol('queue');\nvar CURRENT = Symbol('current');\nvar PROCESS = Symbol('process');\nvar PROCESSING = Symbol('processing');\nvar PROCESSJOB = Symbol('processJob');\nvar JOBS = Symbol('jobs');\nvar JOBDONE = Symbol('jobDone');\nvar ADDFSENTRY = Symbol('addFSEntry');\nvar ADDTARENTRY = Symbol('addTarEntry');\nvar STAT = Symbol('stat');\nvar READDIR = Symbol('readdir');\nvar ONREADDIR = Symbol('onreaddir');\nvar PIPE = Symbol('pipe');\nvar ENTRY = Symbol('entry');\nvar ENTRYOPT = Symbol('entryOpt');\nvar WRITEENTRYCLASS = Symbol('writeEntryClass');\nvar WRITE = Symbol('write');\nvar ONDRAIN = Symbol('ondrain');\nvar fs = require('fs');\nvar path = require('path');\nvar warner = require('./warn-mixin.js');\nvar normPath = require('./normalize-windows-path.js');\nvar Pack = warner( /*#__PURE__*/function (_MiniPass) {\n  _inherits(Pack, _MiniPass);\n  var _super = _createSuper(Pack);\n  function Pack(opt) {\n    var _thisSuper, _thisSuper2, _this;\n    _classCallCheck(this, Pack);\n    _this = _super.call(this, opt);\n    opt = opt || Object.create(null);\n    _this.opt = opt;\n    _this.file = opt.file || '';\n    _this.cwd = opt.cwd || process.cwd();\n    _this.maxReadSize = opt.maxReadSize;\n    _this.preservePaths = !!opt.preservePaths;\n    _this.strict = !!opt.strict;\n    _this.noPax = !!opt.noPax;\n    _this.prefix = normPath(opt.prefix || '');\n    _this.linkCache = opt.linkCache || new Map();\n    _this.statCache = opt.statCache || new Map();\n    _this.readdirCache = opt.readdirCache || new Map();\n    _this[WRITEENTRYCLASS] = WriteEntry;\n    if (typeof opt.onwarn === 'function') _this.on('warn', opt.onwarn);\n    _this.portable = !!opt.portable;\n    _this.zip = null;\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object') opt.gzip = {};\n      if (_this.portable) opt.gzip.portable = true;\n      _this.zip = new zlib.Gzip(opt.gzip);\n      _this.zip.on('data', function (chunk) {\n        return _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(Pack.prototype)), \"write\", _thisSuper).call(_thisSuper, chunk);\n      });\n      _this.zip.on('end', function (_) {\n        return _get((_thisSuper2 = _assertThisInitialized(_this), _getPrototypeOf(Pack.prototype)), \"end\", _thisSuper2).call(_thisSuper2);\n      });\n      _this.zip.on('drain', function (_) {\n        return _this[ONDRAIN]();\n      });\n      _this.on('resume', function (_) {\n        return _this.zip.resume();\n      });\n    } else _this.on('drain', _this[ONDRAIN]);\n    _this.noDirRecurse = !!opt.noDirRecurse;\n    _this.follow = !!opt.follow;\n    _this.noMtime = !!opt.noMtime;\n    _this.mtime = opt.mtime || null;\n    _this.filter = typeof opt.filter === 'function' ? opt.filter : function (_) {\n      return true;\n    };\n    _this[QUEUE] = new Yallist();\n    _this[JOBS] = 0;\n    _this.jobs = +opt.jobs || 4;\n    _this[PROCESSING] = false;\n    _this[ENDED] = false;\n    return _this;\n  }\n  _createClass(Pack, [{\n    key: WRITE,\n    value: function value(chunk) {\n      return _get(_getPrototypeOf(Pack.prototype), \"write\", this).call(this, chunk);\n    }\n  }, {\n    key: \"add\",\n    value: function add(path) {\n      this.write(path);\n      return this;\n    }\n  }, {\n    key: \"end\",\n    value: function end(path) {\n      if (path) this.write(path);\n      this[ENDED] = true;\n      this[PROCESS]();\n      return this;\n    }\n  }, {\n    key: \"write\",\n    value: function write(path) {\n      if (this[ENDED]) throw new Error('write after end');\n      if (path instanceof ReadEntry) this[ADDTARENTRY](path);else this[ADDFSENTRY](path);\n      return this.flowing;\n    }\n  }, {\n    key: ADDTARENTRY,\n    value: function value(p) {\n      var _this2 = this;\n      var absolute = normPath(path.resolve(this.cwd, p.path));\n      // in this case, we don't have to wait for the stat\n      if (!this.filter(p.path, p)) p.resume();else {\n        var job = new PackJob(p.path, absolute, false);\n        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));\n        job.entry.on('end', function (_) {\n          return _this2[JOBDONE](job);\n        });\n        this[JOBS] += 1;\n        this[QUEUE].push(job);\n      }\n      this[PROCESS]();\n    }\n  }, {\n    key: ADDFSENTRY,\n    value: function value(p) {\n      var absolute = normPath(path.resolve(this.cwd, p));\n      this[QUEUE].push(new PackJob(p, absolute));\n      this[PROCESS]();\n    }\n  }, {\n    key: STAT,\n    value: function value(job) {\n      var _this3 = this;\n      job.pending = true;\n      this[JOBS] += 1;\n      var stat = this.follow ? 'stat' : 'lstat';\n      fs[stat](job.absolute, function (er, stat) {\n        job.pending = false;\n        _this3[JOBS] -= 1;\n        if (er) _this3.emit('error', er);else _this3[ONSTAT](job, stat);\n      });\n    }\n  }, {\n    key: ONSTAT,\n    value: function value(job, stat) {\n      this.statCache.set(job.absolute, stat);\n      job.stat = stat;\n\n      // now we have the stat, we can filter it.\n      if (!this.filter(job.path, stat)) job.ignore = true;\n      this[PROCESS]();\n    }\n  }, {\n    key: READDIR,\n    value: function value(job) {\n      var _this4 = this;\n      job.pending = true;\n      this[JOBS] += 1;\n      fs.readdir(job.absolute, function (er, entries) {\n        job.pending = false;\n        _this4[JOBS] -= 1;\n        if (er) return _this4.emit('error', er);\n        _this4[ONREADDIR](job, entries);\n      });\n    }\n  }, {\n    key: ONREADDIR,\n    value: function value(job, entries) {\n      this.readdirCache.set(job.absolute, entries);\n      job.readdir = entries;\n      this[PROCESS]();\n    }\n  }, {\n    key: PROCESS,\n    value: function value() {\n      if (this[PROCESSING]) return;\n      this[PROCESSING] = true;\n      for (var w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {\n        this[PROCESSJOB](w.value);\n        if (w.value.ignore) {\n          var p = w.next;\n          this[QUEUE].removeNode(w);\n          w.next = p;\n        }\n      }\n      this[PROCESSING] = false;\n      if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n        if (this.zip) this.zip.end(EOF);else {\n          _get(_getPrototypeOf(Pack.prototype), \"write\", this).call(this, EOF);\n          _get(_getPrototypeOf(Pack.prototype), \"end\", this).call(this);\n        }\n      }\n    }\n  }, {\n    key: CURRENT,\n    get: function get() {\n      return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;\n    }\n  }, {\n    key: JOBDONE,\n    value: function value(job) {\n      this[QUEUE].shift();\n      this[JOBS] -= 1;\n      this[PROCESS]();\n    }\n  }, {\n    key: PROCESSJOB,\n    value: function value(job) {\n      if (job.pending) return;\n      if (job.entry) {\n        if (job === this[CURRENT] && !job.piped) this[PIPE](job);\n        return;\n      }\n      if (!job.stat) {\n        if (this.statCache.has(job.absolute)) this[ONSTAT](job, this.statCache.get(job.absolute));else this[STAT](job);\n      }\n      if (!job.stat) return;\n\n      // filtered out!\n      if (job.ignore) return;\n      if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n        if (this.readdirCache.has(job.absolute)) this[ONREADDIR](job, this.readdirCache.get(job.absolute));else this[READDIR](job);\n        if (!job.readdir) return;\n      }\n\n      // we know it doesn't have an entry, because that got checked above\n      job.entry = this[ENTRY](job);\n      if (!job.entry) {\n        job.ignore = true;\n        return;\n      }\n      if (job === this[CURRENT] && !job.piped) this[PIPE](job);\n    }\n  }, {\n    key: ENTRYOPT,\n    value: function value(job) {\n      var _this5 = this;\n      return {\n        onwarn: function onwarn(code, msg, data) {\n          return _this5.warn(code, msg, data);\n        },\n        noPax: this.noPax,\n        cwd: this.cwd,\n        absolute: job.absolute,\n        preservePaths: this.preservePaths,\n        maxReadSize: this.maxReadSize,\n        strict: this.strict,\n        portable: this.portable,\n        linkCache: this.linkCache,\n        statCache: this.statCache,\n        noMtime: this.noMtime,\n        mtime: this.mtime,\n        prefix: this.prefix\n      };\n    }\n  }, {\n    key: ENTRY,\n    value: function value(job) {\n      var _this6 = this;\n      this[JOBS] += 1;\n      try {\n        return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on('end', function () {\n          return _this6[JOBDONE](job);\n        }).on('error', function (er) {\n          return _this6.emit('error', er);\n        });\n      } catch (er) {\n        this.emit('error', er);\n      }\n    }\n  }, {\n    key: ONDRAIN,\n    value: function value() {\n      if (this[CURRENT] && this[CURRENT].entry) this[CURRENT].entry.resume();\n    }\n\n    // like .pipe() but using super, because our write() is special\n  }, {\n    key: PIPE,\n    value: function value(job) {\n      var _this7 = this;\n      job.piped = true;\n      if (job.readdir) {\n        job.readdir.forEach(function (entry) {\n          var p = job.path;\n          var base = p === './' ? '' : p.replace(/\\/*$/, '/');\n          _this7[ADDFSENTRY](base + entry);\n        });\n      }\n      var source = job.entry;\n      var zip = this.zip;\n      if (zip) {\n        source.on('data', function (chunk) {\n          if (!zip.write(chunk)) source.pause();\n        });\n      } else {\n        source.on('data', function (chunk) {\n          if (!_get(_getPrototypeOf(Pack.prototype), \"write\", _this7).call(_this7, chunk)) source.pause();\n        });\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.zip) this.zip.pause();\n      return _get(_getPrototypeOf(Pack.prototype), \"pause\", this).call(this);\n    }\n  }]);\n  return Pack;\n}(MiniPass));\nvar PackSync = /*#__PURE__*/function (_Pack) {\n  _inherits(PackSync, _Pack);\n  var _super2 = _createSuper(PackSync);\n  function PackSync(opt) {\n    var _this8;\n    _classCallCheck(this, PackSync);\n    _this8 = _super2.call(this, opt);\n    _this8[WRITEENTRYCLASS] = WriteEntrySync;\n    return _this8;\n  }\n\n  // pause/resume are no-ops in sync streams.\n  _createClass(PackSync, [{\n    key: \"pause\",\n    value: function pause() {}\n  }, {\n    key: \"resume\",\n    value: function resume() {}\n  }, {\n    key: STAT,\n    value: function value(job) {\n      var stat = this.follow ? 'statSync' : 'lstatSync';\n      this[ONSTAT](job, fs[stat](job.absolute));\n    }\n  }, {\n    key: READDIR,\n    value: function value(job, stat) {\n      this[ONREADDIR](job, fs.readdirSync(job.absolute));\n    }\n\n    // gotta get it all in this tick\n  }, {\n    key: PIPE,\n    value: function value(job) {\n      var _this9 = this;\n      var source = job.entry;\n      var zip = this.zip;\n      if (job.readdir) {\n        job.readdir.forEach(function (entry) {\n          var p = job.path;\n          var base = p === './' ? '' : p.replace(/\\/*$/, '/');\n          _this9[ADDFSENTRY](base + entry);\n        });\n      }\n      if (zip) {\n        source.on('data', function (chunk) {\n          zip.write(chunk);\n        });\n      } else {\n        source.on('data', function (chunk) {\n          _get(_getPrototypeOf(PackSync.prototype), WRITE, _this9).call(_this9, chunk);\n        });\n      }\n    }\n  }]);\n  return PackSync;\n}(Pack);\nPack.Sync = PackSync;\nmodule.exports = Pack;","map":{"version":3,"names":["PackJob","path","absolute","entry","stat","readdir","pending","ignore","piped","MiniPass","require","zlib","ReadEntry","WriteEntry","WriteEntrySync","Sync","WriteEntryTar","Tar","Yallist","EOF","Buffer","alloc","ONSTAT","Symbol","ENDED","QUEUE","CURRENT","PROCESS","PROCESSING","PROCESSJOB","JOBS","JOBDONE","ADDFSENTRY","ADDTARENTRY","STAT","READDIR","ONREADDIR","PIPE","ENTRY","ENTRYOPT","WRITEENTRYCLASS","WRITE","ONDRAIN","fs","warner","normPath","Pack","opt","Object","create","file","cwd","process","maxReadSize","preservePaths","strict","noPax","prefix","linkCache","Map","statCache","readdirCache","onwarn","on","portable","zip","gzip","Gzip","chunk","_","resume","noDirRecurse","follow","noMtime","mtime","filter","jobs","write","Error","flowing","p","resolve","job","push","er","emit","set","entries","w","head","next","value","removeNode","length","end","shift","has","get","isDirectory","code","msg","data","warn","forEach","base","replace","source","pause","PackSync","readdirSync","module","exports"],"sources":["/Users/lieo/diabetes/CUT2DMTest/node_modules/tar/lib/pack.js"],"sourcesContent":["'use strict'\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst MiniPass = require('minipass')\nconst zlib = require('minizlib')\nconst ReadEntry = require('./read-entry.js')\nconst WriteEntry = require('./write-entry.js')\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = require('yallist')\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = require('fs')\nconst path = require('path')\nconst warner = require('./warn-mixin.js')\nconst normPath = require('./normalize-windows-path.js')\n\nconst Pack = warner(class Pack extends MiniPass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = normPath(opt.prefix || '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    this.portable = !!opt.portable\n    this.zip = null\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object')\n        opt.gzip = {}\n      if (this.portable)\n        opt.gzip.portable = true\n      this.zip = new zlib.Gzip(opt.gzip)\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else\n      this.on('drain', this[ONDRAIN])\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist()\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path)\n      this.write(path)\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED])\n      throw new Error('write after end')\n\n    if (path instanceof ReadEntry)\n      this[ADDTARENTRY](path)\n    else\n      this[ADDFSENTRY](path)\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path))\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p))\n      p.resume()\n    else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p))\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        this.emit('error', er)\n      else\n        this[ONSTAT](job, stat)\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat))\n      job.ignore = true\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        return this.emit('error', er)\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING])\n      return\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n      w !== null && this[JOBS] < this.jobs;\n      w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip)\n        this.zip.end(EOF)\n      else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending)\n      return\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped)\n        this[PIPE](job)\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute))\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      else\n        this[STAT](job)\n    }\n    if (!job.stat)\n      return\n\n    // filtered out!\n    if (job.ignore)\n      return\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute))\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      else\n        this[READDIR](job)\n      if (!job.readdir)\n        return\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped)\n      this[PIPE](job)\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix,\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry)\n      this[CURRENT].entry.resume()\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk))\n          source.pause()\n      })\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk))\n          source.pause()\n      })\n    }\n  }\n\n  pause () {\n    if (this.zip)\n      this.zip.pause()\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n    }\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}