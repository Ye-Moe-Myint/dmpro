{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _objectSpread = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar debug = require('debug')('nock.request_overrider');\nvar _require = require('http'),\n  IncomingMessage = _require.IncomingMessage,\n  ClientRequest = _require.ClientRequest,\n  originalHttpRequest = _require.request;\nvar _require2 = require('https'),\n  originalHttpsRequest = _require2.request;\nvar propagate = require('propagate');\nvar common = require('./common');\nvar globalEmitter = require('./global_emitter');\nvar Socket = require('./socket');\nvar _require3 = require('./playback_interceptor'),\n  playbackInterceptor = _require3.playbackInterceptor;\nfunction socketOnClose(req) {\n  debug('socket close');\n  if (!req.res && !req.socket._hadError) {\n    // If we don't have a response then we know that the socket\n    // ended prematurely and we need to emit an error on the request.\n    req.socket._hadError = true;\n    var err = new Error('socket hang up');\n    err.code = 'ECONNRESET';\n    req.emit('error', err);\n  }\n  req.emit('close');\n}\n\n/**\n * Given a group of interceptors, appropriately route an outgoing request.\n * Identify which interceptor ought to respond, if any, then delegate to\n * `playbackInterceptor()` to consume the request itself.\n */\nvar InterceptedRequestRouter = /*#__PURE__*/function () {\n  function InterceptedRequestRouter(_ref) {\n    var _this = this;\n    var req = _ref.req,\n      options = _ref.options,\n      interceptors = _ref.interceptors;\n    _classCallCheck(this, InterceptedRequestRouter);\n    this.req = req;\n    this.options = _objectSpread(_objectSpread({}, options), {}, {\n      // We use lower-case header field names throughout Nock.\n      headers: common.headersFieldNamesToLowerCase(options.headers || {}, false)\n    });\n    this.interceptors = interceptors;\n    this.socket = new Socket(options);\n\n    // support setting `timeout` using request `options`\n    // https://nodejs.org/docs/latest-v12.x/api/http.html#http_http_request_url_options_callback\n    // any timeout in the request options override any timeout in the agent options.\n    // per https://github.com/nodejs/node/pull/21204\n    var timeout = options.timeout || options.agent && options.agent.options && options.agent.options.timeout;\n    if (timeout) {\n      this.socket.setTimeout(timeout);\n    }\n    this.response = new IncomingMessage(this.socket);\n    this.requestBodyBuffers = [];\n    this.playbackStarted = false;\n\n    // For parity with Node, it's important the socket event is emitted before we begin playback.\n    // This flag is set when playback is triggered if we haven't yet gotten the\n    // socket event to indicate that playback should start as soon as it comes in.\n    this.readyToStartPlaybackOnSocketEvent = false;\n    this.attachToReq();\n\n    // Emit a fake socket event on the next tick to mimic what would happen on a real request.\n    // Some clients listen for a 'socket' event to be emitted before calling end(),\n    // which causes Nock to hang.\n    process.nextTick(function () {\n      return _this.connectSocket();\n    });\n  }\n  _createClass(InterceptedRequestRouter, [{\n    key: \"attachToReq\",\n    value: function attachToReq() {\n      var _this2 = this;\n      var req = this.req,\n        options = this.options;\n      for (var _i = 0, _Object$entries = Object.entries(options.headers); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          name = _Object$entries$_i[0],\n          val = _Object$entries$_i[1];\n        req.setHeader(name.toLowerCase(), val);\n      }\n      if (options.auth && !options.headers.authorization) {\n        req.setHeader(\n        // We use lower-case header field names throughout Nock.\n        'authorization', \"Basic \".concat(Buffer.from(options.auth).toString('base64')));\n      }\n      req.path = options.path;\n      req.method = options.method;\n      req.write = function () {\n        return _this2.handleWrite.apply(_this2, arguments);\n      };\n      req.end = function () {\n        return _this2.handleEnd.apply(_this2, arguments);\n      };\n      req.flushHeaders = function () {\n        return _this2.handleFlushHeaders.apply(_this2, arguments);\n      };\n\n      // https://github.com/nock/nock/issues/256\n      if (options.headers.expect === '100-continue') {\n        common.setImmediate(function () {\n          debug('continue');\n          req.emit('continue');\n        });\n      }\n    }\n  }, {\n    key: \"connectSocket\",\n    value: function connectSocket() {\n      var req = this.req,\n        socket = this.socket;\n      if (common.isRequestDestroyed(req)) {\n        return;\n      }\n\n      // ClientRequest.connection is an alias for ClientRequest.socket\n      // https://nodejs.org/api/http.html#http_request_socket\n      // https://github.com/nodejs/node/blob/b0f75818f39ed4e6bd80eb7c4010c1daf5823ef7/lib/_http_client.js#L640-L641\n      // The same Socket is shared between the request and response to mimic native behavior.\n      req.socket = req.connection = socket;\n      propagate(['error', 'timeout'], socket, req);\n      socket.on('close', function () {\n        return socketOnClose(req);\n      });\n      socket.connecting = false;\n      req.emit('socket', socket);\n\n      // https://nodejs.org/api/net.html#net_event_connect\n      socket.emit('connect');\n\n      // https://nodejs.org/api/tls.html#tls_event_secureconnect\n      if (socket.authorized) {\n        socket.emit('secureConnect');\n      }\n      if (this.readyToStartPlaybackOnSocketEvent) {\n        this.maybeStartPlayback();\n      }\n    }\n\n    // from docs: When write function is called with empty string or buffer, it does nothing and waits for more input.\n    // However, actually implementation checks the state of finished and aborted before checking if the first arg is empty.\n  }, {\n    key: \"handleWrite\",\n    value: function handleWrite() {\n      debug('request write');\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      var buffer = args[0],\n        encoding = args[1];\n      var req = this.req;\n      if (req.finished) {\n        var err = new Error('write after end');\n        err.code = 'ERR_STREAM_WRITE_AFTER_END';\n        process.nextTick(function () {\n          return req.emit('error', err);\n        });\n\n        // It seems odd to return `true` here, not sure why you'd want to have\n        // the stream potentially written to more, but it's what Node does.\n        // https://github.com/nodejs/node/blob/a9270dcbeba4316b1e179b77ecb6c46af5aa8c20/lib/_http_outgoing.js#L662-L665\n        return true;\n      }\n      if (req.socket && req.socket.destroyed) {\n        return false;\n      }\n      if (!buffer) {\n        return true;\n      }\n      if (!Buffer.isBuffer(buffer)) {\n        buffer = Buffer.from(buffer, encoding);\n      }\n      this.requestBodyBuffers.push(buffer);\n\n      // writable.write encoding param is optional\n      // so if callback is present it's the last argument\n      var callback = args.length > 1 ? args[args.length - 1] : undefined;\n      // can't use instanceof Function because some test runners\n      // run tests in vm.runInNewContext where Function is not same\n      // as that in the current context\n      // https://github.com/nock/nock/pull/1754#issuecomment-571531407\n      if (typeof callback === 'function') {\n        callback();\n      }\n      common.setImmediate(function () {\n        req.emit('drain');\n      });\n      return false;\n    }\n  }, {\n    key: \"handleEnd\",\n    value: function handleEnd(chunk, encoding, callback) {\n      debug('request end');\n      var req = this.req;\n\n      // handle the different overloaded arg signatures\n      if (typeof chunk === 'function') {\n        callback = chunk;\n        chunk = null;\n      } else if (typeof encoding === 'function') {\n        callback = encoding;\n        encoding = null;\n      }\n      if (typeof callback === 'function') {\n        req.once('finish', callback);\n      }\n      if (chunk) {\n        req.write(chunk, encoding);\n      }\n      req.finished = true;\n      this.maybeStartPlayback();\n      return req;\n    }\n  }, {\n    key: \"handleFlushHeaders\",\n    value: function handleFlushHeaders() {\n      debug('request flushHeaders');\n      this.maybeStartPlayback();\n    }\n\n    /**\n     * Set request headers of the given request. This is needed both during the\n     * routing phase, in case header filters were specified, and during the\n     * interceptor-playback phase, to correctly pass mocked request headers.\n     * TODO There are some problems with this; see https://github.com/nock/nock/issues/1718\n     */\n  }, {\n    key: \"setHostHeaderUsingInterceptor\",\n    value: function setHostHeaderUsingInterceptor(interceptor) {\n      var req = this.req,\n        options = this.options;\n\n      // If a filtered scope is being used we have to use scope's host in the\n      // header, otherwise 'host' header won't match.\n      // NOTE: We use lower-case header field names throughout Nock.\n      var HOST_HEADER = 'host';\n      if (interceptor.__nock_filteredScope && interceptor.__nock_scopeHost) {\n        options.headers[HOST_HEADER] = interceptor.__nock_scopeHost;\n        req.setHeader(HOST_HEADER, interceptor.__nock_scopeHost);\n      } else {\n        // For all other cases, we always add host header equal to the requested\n        // host unless it was already defined.\n        if (options.host && !req.getHeader(HOST_HEADER)) {\n          var hostHeader = options.host;\n          if (options.port === 80 || options.port === 443) {\n            hostHeader = hostHeader.split(':')[0];\n          }\n          req.setHeader(HOST_HEADER, hostHeader);\n        }\n      }\n    }\n  }, {\n    key: \"maybeStartPlayback\",\n    value: function maybeStartPlayback() {\n      var req = this.req,\n        socket = this.socket,\n        playbackStarted = this.playbackStarted;\n\n      // In order to get the events in the right order we need to delay playback\n      // if we get here before the `socket` event is emitted.\n      if (socket.connecting) {\n        this.readyToStartPlaybackOnSocketEvent = true;\n        return;\n      }\n      if (!common.isRequestDestroyed(req) && !playbackStarted) {\n        this.startPlayback();\n      }\n    }\n  }, {\n    key: \"startPlayback\",\n    value: function startPlayback() {\n      var _this3 = this;\n      debug('ending');\n      this.playbackStarted = true;\n      var req = this.req,\n        response = this.response,\n        socket = this.socket,\n        options = this.options,\n        interceptors = this.interceptors;\n      Object.assign(options, {\n        // Re-update `options` with the current value of `req.path` because badly\n        // behaving agents like superagent like to change `req.path` mid-flight.\n        path: req.path,\n        // Similarly, node-http-proxy will modify headers in flight, so we have\n        // to put the headers back into options.\n        // https://github.com/nock/nock/pull/1484\n        headers: req.getHeaders(),\n        // Fixes https://github.com/nock/nock/issues/976\n        protocol: \"\".concat(options.proto, \":\")\n      });\n      interceptors.forEach(function (interceptor) {\n        _this3.setHostHeaderUsingInterceptor(interceptor);\n      });\n      var requestBodyBuffer = Buffer.concat(this.requestBodyBuffers);\n      // When request body is a binary buffer we internally use in its hexadecimal\n      // representation.\n      var requestBodyIsUtf8Representable = common.isUtf8Representable(requestBodyBuffer);\n      var requestBodyString = requestBodyBuffer.toString(requestBodyIsUtf8Representable ? 'utf8' : 'hex');\n      var matchedInterceptor = interceptors.find(function (i) {\n        return i.match(req, options, requestBodyString);\n      });\n      if (matchedInterceptor) {\n        matchedInterceptor.scope.logger('interceptor identified, starting mocking');\n        matchedInterceptor.markConsumed();\n\n        // wait to emit the finish event until we know for sure an Interceptor is going to playback.\n        // otherwise an unmocked request might emit finish twice.\n        req.emit('finish');\n        playbackInterceptor({\n          req: req,\n          socket: socket,\n          options: options,\n          requestBodyString: requestBodyString,\n          requestBodyIsUtf8Representable: requestBodyIsUtf8Representable,\n          response: response,\n          interceptor: matchedInterceptor\n        });\n      } else {\n        globalEmitter.emit('no match', req, options, requestBodyString);\n\n        // Try to find a hostname match that allows unmocked.\n        var allowUnmocked = interceptors.some(function (i) {\n          return i.matchHostName(options) && i.options.allowUnmocked;\n        });\n        if (allowUnmocked && req instanceof ClientRequest) {\n          var newReq = options.proto === 'https' ? originalHttpsRequest(options) : originalHttpRequest(options);\n          propagate(newReq, req);\n          // We send the raw buffer as we received it, not as we interpreted it.\n          newReq.end(requestBodyBuffer);\n        } else {\n          var reqStr = common.stringifyRequest(options, requestBodyString);\n          var err = new Error(\"Nock: No match for request \".concat(reqStr));\n          err.code = 'ERR_NOCK_NO_MATCH';\n          err.statusCode = err.status = 404;\n          req.destroy(err);\n        }\n      }\n    }\n  }]);\n  return InterceptedRequestRouter;\n}();\nmodule.exports = {\n  InterceptedRequestRouter: InterceptedRequestRouter\n};","map":{"version":3,"names":["debug","require","IncomingMessage","ClientRequest","originalHttpRequest","request","originalHttpsRequest","propagate","common","globalEmitter","Socket","playbackInterceptor","socketOnClose","req","res","socket","_hadError","err","Error","code","emit","InterceptedRequestRouter","options","interceptors","headers","headersFieldNamesToLowerCase","timeout","agent","setTimeout","response","requestBodyBuffers","playbackStarted","readyToStartPlaybackOnSocketEvent","attachToReq","process","nextTick","connectSocket","Object","entries","name","val","setHeader","toLowerCase","auth","authorization","Buffer","from","toString","path","method","write","handleWrite","end","handleEnd","flushHeaders","handleFlushHeaders","expect","setImmediate","isRequestDestroyed","connection","on","connecting","authorized","maybeStartPlayback","args","buffer","encoding","finished","destroyed","isBuffer","push","callback","length","undefined","chunk","once","interceptor","HOST_HEADER","__nock_filteredScope","__nock_scopeHost","host","getHeader","hostHeader","port","split","startPlayback","assign","getHeaders","protocol","proto","forEach","setHostHeaderUsingInterceptor","requestBodyBuffer","concat","requestBodyIsUtf8Representable","isUtf8Representable","requestBodyString","matchedInterceptor","find","i","match","scope","logger","markConsumed","allowUnmocked","some","matchHostName","newReq","reqStr","stringifyRequest","statusCode","status","destroy","module","exports"],"sources":["/Users/lieo/diabetes/CUT2DMTest/node_modules/nock/lib/intercepted_request_router.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')('nock.request_overrider')\nconst {\n  IncomingMessage,\n  ClientRequest,\n  request: originalHttpRequest,\n} = require('http')\nconst { request: originalHttpsRequest } = require('https')\nconst propagate = require('propagate')\nconst common = require('./common')\nconst globalEmitter = require('./global_emitter')\nconst Socket = require('./socket')\nconst { playbackInterceptor } = require('./playback_interceptor')\n\nfunction socketOnClose(req) {\n  debug('socket close')\n\n  if (!req.res && !req.socket._hadError) {\n    // If we don't have a response then we know that the socket\n    // ended prematurely and we need to emit an error on the request.\n    req.socket._hadError = true\n    const err = new Error('socket hang up')\n    err.code = 'ECONNRESET'\n    req.emit('error', err)\n  }\n  req.emit('close')\n}\n\n/**\n * Given a group of interceptors, appropriately route an outgoing request.\n * Identify which interceptor ought to respond, if any, then delegate to\n * `playbackInterceptor()` to consume the request itself.\n */\nclass InterceptedRequestRouter {\n  constructor({ req, options, interceptors }) {\n    this.req = req\n    this.options = {\n      // We may be changing the options object and we don't want those changes\n      // affecting the user so we use a clone of the object.\n      ...options,\n      // We use lower-case header field names throughout Nock.\n      headers: common.headersFieldNamesToLowerCase(\n        options.headers || {},\n        false\n      ),\n    }\n    this.interceptors = interceptors\n\n    this.socket = new Socket(options)\n\n    // support setting `timeout` using request `options`\n    // https://nodejs.org/docs/latest-v12.x/api/http.html#http_http_request_url_options_callback\n    // any timeout in the request options override any timeout in the agent options.\n    // per https://github.com/nodejs/node/pull/21204\n    const timeout =\n      options.timeout ||\n      (options.agent && options.agent.options && options.agent.options.timeout)\n\n    if (timeout) {\n      this.socket.setTimeout(timeout)\n    }\n\n    this.response = new IncomingMessage(this.socket)\n    this.requestBodyBuffers = []\n    this.playbackStarted = false\n\n    // For parity with Node, it's important the socket event is emitted before we begin playback.\n    // This flag is set when playback is triggered if we haven't yet gotten the\n    // socket event to indicate that playback should start as soon as it comes in.\n    this.readyToStartPlaybackOnSocketEvent = false\n\n    this.attachToReq()\n\n    // Emit a fake socket event on the next tick to mimic what would happen on a real request.\n    // Some clients listen for a 'socket' event to be emitted before calling end(),\n    // which causes Nock to hang.\n    process.nextTick(() => this.connectSocket())\n  }\n\n  attachToReq() {\n    const { req, options } = this\n\n    for (const [name, val] of Object.entries(options.headers)) {\n      req.setHeader(name.toLowerCase(), val)\n    }\n\n    if (options.auth && !options.headers.authorization) {\n      req.setHeader(\n        // We use lower-case header field names throughout Nock.\n        'authorization',\n        `Basic ${Buffer.from(options.auth).toString('base64')}`\n      )\n    }\n\n    req.path = options.path\n    req.method = options.method\n\n    req.write = (...args) => this.handleWrite(...args)\n    req.end = (...args) => this.handleEnd(...args)\n    req.flushHeaders = (...args) => this.handleFlushHeaders(...args)\n\n    // https://github.com/nock/nock/issues/256\n    if (options.headers.expect === '100-continue') {\n      common.setImmediate(() => {\n        debug('continue')\n        req.emit('continue')\n      })\n    }\n  }\n\n  connectSocket() {\n    const { req, socket } = this\n\n    if (common.isRequestDestroyed(req)) {\n      return\n    }\n\n    // ClientRequest.connection is an alias for ClientRequest.socket\n    // https://nodejs.org/api/http.html#http_request_socket\n    // https://github.com/nodejs/node/blob/b0f75818f39ed4e6bd80eb7c4010c1daf5823ef7/lib/_http_client.js#L640-L641\n    // The same Socket is shared between the request and response to mimic native behavior.\n    req.socket = req.connection = socket\n\n    propagate(['error', 'timeout'], socket, req)\n    socket.on('close', () => socketOnClose(req))\n\n    socket.connecting = false\n    req.emit('socket', socket)\n\n    // https://nodejs.org/api/net.html#net_event_connect\n    socket.emit('connect')\n\n    // https://nodejs.org/api/tls.html#tls_event_secureconnect\n    if (socket.authorized) {\n      socket.emit('secureConnect')\n    }\n\n    if (this.readyToStartPlaybackOnSocketEvent) {\n      this.maybeStartPlayback()\n    }\n  }\n\n  // from docs: When write function is called with empty string or buffer, it does nothing and waits for more input.\n  // However, actually implementation checks the state of finished and aborted before checking if the first arg is empty.\n  handleWrite(...args) {\n    debug('request write')\n\n    let [buffer, encoding] = args\n\n    const { req } = this\n\n    if (req.finished) {\n      const err = new Error('write after end')\n      err.code = 'ERR_STREAM_WRITE_AFTER_END'\n      process.nextTick(() => req.emit('error', err))\n\n      // It seems odd to return `true` here, not sure why you'd want to have\n      // the stream potentially written to more, but it's what Node does.\n      // https://github.com/nodejs/node/blob/a9270dcbeba4316b1e179b77ecb6c46af5aa8c20/lib/_http_outgoing.js#L662-L665\n      return true\n    }\n\n    if (req.socket && req.socket.destroyed) {\n      return false\n    }\n\n    if (!buffer) {\n      return true\n    }\n\n    if (!Buffer.isBuffer(buffer)) {\n      buffer = Buffer.from(buffer, encoding)\n    }\n    this.requestBodyBuffers.push(buffer)\n\n    // writable.write encoding param is optional\n    // so if callback is present it's the last argument\n    const callback = args.length > 1 ? args[args.length - 1] : undefined\n    // can't use instanceof Function because some test runners\n    // run tests in vm.runInNewContext where Function is not same\n    // as that in the current context\n    // https://github.com/nock/nock/pull/1754#issuecomment-571531407\n    if (typeof callback === 'function') {\n      callback()\n    }\n\n    common.setImmediate(function () {\n      req.emit('drain')\n    })\n\n    return false\n  }\n\n  handleEnd(chunk, encoding, callback) {\n    debug('request end')\n    const { req } = this\n\n    // handle the different overloaded arg signatures\n    if (typeof chunk === 'function') {\n      callback = chunk\n      chunk = null\n    } else if (typeof encoding === 'function') {\n      callback = encoding\n      encoding = null\n    }\n\n    if (typeof callback === 'function') {\n      req.once('finish', callback)\n    }\n\n    if (chunk) {\n      req.write(chunk, encoding)\n    }\n    req.finished = true\n    this.maybeStartPlayback()\n\n    return req\n  }\n\n  handleFlushHeaders() {\n    debug('request flushHeaders')\n    this.maybeStartPlayback()\n  }\n\n  /**\n   * Set request headers of the given request. This is needed both during the\n   * routing phase, in case header filters were specified, and during the\n   * interceptor-playback phase, to correctly pass mocked request headers.\n   * TODO There are some problems with this; see https://github.com/nock/nock/issues/1718\n   */\n  setHostHeaderUsingInterceptor(interceptor) {\n    const { req, options } = this\n\n    // If a filtered scope is being used we have to use scope's host in the\n    // header, otherwise 'host' header won't match.\n    // NOTE: We use lower-case header field names throughout Nock.\n    const HOST_HEADER = 'host'\n    if (interceptor.__nock_filteredScope && interceptor.__nock_scopeHost) {\n      options.headers[HOST_HEADER] = interceptor.__nock_scopeHost\n      req.setHeader(HOST_HEADER, interceptor.__nock_scopeHost)\n    } else {\n      // For all other cases, we always add host header equal to the requested\n      // host unless it was already defined.\n      if (options.host && !req.getHeader(HOST_HEADER)) {\n        let hostHeader = options.host\n\n        if (options.port === 80 || options.port === 443) {\n          hostHeader = hostHeader.split(':')[0]\n        }\n\n        req.setHeader(HOST_HEADER, hostHeader)\n      }\n    }\n  }\n\n  maybeStartPlayback() {\n    const { req, socket, playbackStarted } = this\n\n    // In order to get the events in the right order we need to delay playback\n    // if we get here before the `socket` event is emitted.\n    if (socket.connecting) {\n      this.readyToStartPlaybackOnSocketEvent = true\n      return\n    }\n\n    if (!common.isRequestDestroyed(req) && !playbackStarted) {\n      this.startPlayback()\n    }\n  }\n\n  startPlayback() {\n    debug('ending')\n    this.playbackStarted = true\n\n    const { req, response, socket, options, interceptors } = this\n\n    Object.assign(options, {\n      // Re-update `options` with the current value of `req.path` because badly\n      // behaving agents like superagent like to change `req.path` mid-flight.\n      path: req.path,\n      // Similarly, node-http-proxy will modify headers in flight, so we have\n      // to put the headers back into options.\n      // https://github.com/nock/nock/pull/1484\n      headers: req.getHeaders(),\n      // Fixes https://github.com/nock/nock/issues/976\n      protocol: `${options.proto}:`,\n    })\n\n    interceptors.forEach(interceptor => {\n      this.setHostHeaderUsingInterceptor(interceptor)\n    })\n\n    const requestBodyBuffer = Buffer.concat(this.requestBodyBuffers)\n    // When request body is a binary buffer we internally use in its hexadecimal\n    // representation.\n    const requestBodyIsUtf8Representable =\n      common.isUtf8Representable(requestBodyBuffer)\n    const requestBodyString = requestBodyBuffer.toString(\n      requestBodyIsUtf8Representable ? 'utf8' : 'hex'\n    )\n\n    const matchedInterceptor = interceptors.find(i =>\n      i.match(req, options, requestBodyString)\n    )\n\n    if (matchedInterceptor) {\n      matchedInterceptor.scope.logger(\n        'interceptor identified, starting mocking'\n      )\n\n      matchedInterceptor.markConsumed()\n\n      // wait to emit the finish event until we know for sure an Interceptor is going to playback.\n      // otherwise an unmocked request might emit finish twice.\n      req.emit('finish')\n\n      playbackInterceptor({\n        req,\n        socket,\n        options,\n        requestBodyString,\n        requestBodyIsUtf8Representable,\n        response,\n        interceptor: matchedInterceptor,\n      })\n    } else {\n      globalEmitter.emit('no match', req, options, requestBodyString)\n\n      // Try to find a hostname match that allows unmocked.\n      const allowUnmocked = interceptors.some(\n        i => i.matchHostName(options) && i.options.allowUnmocked\n      )\n\n      if (allowUnmocked && req instanceof ClientRequest) {\n        const newReq =\n          options.proto === 'https'\n            ? originalHttpsRequest(options)\n            : originalHttpRequest(options)\n\n        propagate(newReq, req)\n        // We send the raw buffer as we received it, not as we interpreted it.\n        newReq.end(requestBodyBuffer)\n      } else {\n        const reqStr = common.stringifyRequest(options, requestBodyString)\n        const err = new Error(`Nock: No match for request ${reqStr}`)\n        err.code = 'ERR_NOCK_NO_MATCH'\n        err.statusCode = err.status = 404\n        req.destroy(err)\n      }\n    }\n  }\n}\n\nmodule.exports = { InterceptedRequestRouter }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}