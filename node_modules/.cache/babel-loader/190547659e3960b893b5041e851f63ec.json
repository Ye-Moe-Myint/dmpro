{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _toConsumableArray = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _slicedToArray = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar stream = require('stream');\nvar util = require('util');\nvar zlib = require('zlib');\nvar debug = require('debug')('nock.playback_interceptor');\nvar common = require('./common');\nfunction parseJSONRequestBody(req, requestBody) {\n  if (!requestBody || !common.isJSONContent(req.headers)) {\n    return requestBody;\n  }\n  if (common.contentEncoding(req.headers, 'gzip')) {\n    requestBody = String(zlib.gunzipSync(Buffer.from(requestBody, 'hex')));\n  } else if (common.contentEncoding(req.headers, 'deflate')) {\n    requestBody = String(zlib.inflateSync(Buffer.from(requestBody, 'hex')));\n  }\n  return JSON.parse(requestBody);\n}\nfunction parseFullReplyResult(response, fullReplyResult) {\n  var _response$rawHeaders;\n  debug('full response from callback result: %j', fullReplyResult);\n  if (!Array.isArray(fullReplyResult)) {\n    throw Error('A single function provided to .reply MUST return an array');\n  }\n  if (fullReplyResult.length > 3) {\n    throw Error('The array returned from the .reply callback contains too many values');\n  }\n  var _fullReplyResult = _slicedToArray(fullReplyResult, 3),\n    status = _fullReplyResult[0],\n    _fullReplyResult$ = _fullReplyResult[1],\n    body = _fullReplyResult$ === void 0 ? '' : _fullReplyResult$,\n    headers = _fullReplyResult[2];\n  if (!Number.isInteger(status)) {\n    throw new Error(\"Invalid \".concat(typeof status, \" value for status code\"));\n  }\n  response.statusCode = status;\n  (_response$rawHeaders = response.rawHeaders).push.apply(_response$rawHeaders, _toConsumableArray(common.headersInputToRawArray(headers)));\n  debug('response.rawHeaders after reply: %j', response.rawHeaders);\n  return body;\n}\n\n/**\n * Determine which of the default headers should be added to the response.\n *\n * Don't include any defaults whose case-insensitive keys are already on the response.\n */\nfunction selectDefaultHeaders(existingHeaders, defaultHeaders) {\n  if (!defaultHeaders.length) {\n    return []; // return early if we don't need to bother\n  }\n\n  var definedHeaders = new Set();\n  var result = [];\n  common.forEachHeader(existingHeaders, function (_, fieldName) {\n    definedHeaders.add(fieldName.toLowerCase());\n  });\n  common.forEachHeader(defaultHeaders, function (value, fieldName) {\n    if (!definedHeaders.has(fieldName.toLowerCase())) {\n      result.push(fieldName, value);\n    }\n  });\n  return result;\n}\n\n// Presents a list of Buffers as a Readable\nvar ReadableBuffers = /*#__PURE__*/function (_stream$Readable) {\n  _inherits(ReadableBuffers, _stream$Readable);\n  var _super = _createSuper(ReadableBuffers);\n  function ReadableBuffers(buffers) {\n    var _this;\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, ReadableBuffers);\n    _this = _super.call(this, opts);\n    _this.buffers = buffers;\n    return _this;\n  }\n  _createClass(ReadableBuffers, [{\n    key: \"_read\",\n    value: function _read(_size) {\n      while (this.buffers.length) {\n        if (!this.push(this.buffers.shift())) {\n          return;\n        }\n      }\n      this.push(null);\n    }\n  }]);\n  return ReadableBuffers;\n}(stream.Readable);\nfunction convertBodyToStream(body) {\n  if (common.isStream(body)) {\n    return body;\n  }\n  if (body === undefined) {\n    return new ReadableBuffers([]);\n  }\n  if (Buffer.isBuffer(body)) {\n    return new ReadableBuffers([body]);\n  }\n  if (typeof body !== 'string') {\n    body = JSON.stringify(body);\n  }\n  return new ReadableBuffers([Buffer.from(body)]);\n}\n\n/**\n * Play back an interceptor using the given request and mock response.\n */\nfunction playbackInterceptor(_ref) {\n  var req = _ref.req,\n    socket = _ref.socket,\n    options = _ref.options,\n    requestBodyString = _ref.requestBodyString,\n    requestBodyIsUtf8Representable = _ref.requestBodyIsUtf8Representable,\n    response = _ref.response,\n    interceptor = _ref.interceptor;\n  var logger = interceptor.scope.logger;\n  function start() {\n    req.headers = req.getHeaders();\n    interceptor.scope.emit('request', req, interceptor, requestBodyString);\n    if (typeof interceptor.errorMessage !== 'undefined') {\n      var error;\n      if (typeof interceptor.errorMessage === 'object') {\n        error = interceptor.errorMessage;\n      } else {\n        error = new Error(interceptor.errorMessage);\n      }\n      var delay = interceptor.delayBodyInMs + interceptor.delayConnectionInMs;\n      common.setTimeout(function () {\n        return req.destroy(error);\n      }, delay);\n      return;\n    }\n\n    // This will be null if we have a fullReplyFunction,\n    // in that case status code will be set in `parseFullReplyResult`\n    response.statusCode = interceptor.statusCode;\n\n    // Clone headers/rawHeaders to not override them when evaluating later\n    response.rawHeaders = _toConsumableArray(interceptor.rawHeaders);\n    logger('response.rawHeaders:', response.rawHeaders);\n\n    // TODO: MAJOR: Don't tack the request onto the interceptor.\n    // The only reason we do this is so that it's available inside reply functions.\n    // It would be better to pass the request as an argument to the functions instead.\n    // Not adding the req as a third arg now because it should first be decided if (path, body, req)\n    // is the signature we want to go with going forward.\n    interceptor.req = req;\n    if (interceptor.replyFunction) {\n      var parsedRequestBody = parseJSONRequestBody(req, requestBodyString);\n      var fn = interceptor.replyFunction;\n      if (fn.length === 3) {\n        // Handle the case of an async reply function, the third parameter being the callback.\n        fn = util.promisify(fn);\n      }\n\n      // At this point `fn` is either a synchronous function or a promise-returning function;\n      // wrapping in `Promise.resolve` makes it into a promise either way.\n      Promise.resolve(fn.call(interceptor, options.path, parsedRequestBody)).then(continueWithResponseBody).catch(function (err) {\n        return req.destroy(err);\n      });\n      return;\n    }\n    if (interceptor.fullReplyFunction) {\n      var _parsedRequestBody = parseJSONRequestBody(req, requestBodyString);\n      var _fn = interceptor.fullReplyFunction;\n      if (_fn.length === 3) {\n        _fn = util.promisify(_fn);\n      }\n      Promise.resolve(_fn.call(interceptor, options.path, _parsedRequestBody)).then(continueWithFullResponse).catch(function (err) {\n        return req.destroy(err);\n      });\n      return;\n    }\n    if (common.isContentEncoded(interceptor.headers) && !common.isStream(interceptor.body)) {\n      //  If the content is encoded we know that the response body *must* be an array\n      //  of response buffers which should be mocked one by one.\n      //  (otherwise decompressions after the first one fails as unzip expects to receive\n      //  buffer by buffer and not one single merged buffer)\n      var bufferData = Array.isArray(interceptor.body) ? interceptor.body : [interceptor.body];\n      var responseBuffers = bufferData.map(function (data) {\n        return Buffer.from(data, 'hex');\n      });\n      var _responseBody = new ReadableBuffers(responseBuffers);\n      continueWithResponseBody(_responseBody);\n      return;\n    }\n\n    // If we get to this point, the body is either a string or an object that\n    // will eventually be JSON stringified.\n    var responseBody = interceptor.body;\n\n    // If the request was not UTF8-representable then we assume that the\n    // response won't be either. In that case we send the response as a Buffer\n    // object as that's what the client will expect.\n    if (!requestBodyIsUtf8Representable && typeof responseBody === 'string') {\n      // Try to create the buffer from the interceptor's body response as hex.\n      responseBody = Buffer.from(responseBody, 'hex');\n\n      // Creating buffers does not necessarily throw errors; check for difference in size.\n      if (!responseBody || interceptor.body.length > 0 && responseBody.length === 0) {\n        // We fallback on constructing buffer from utf8 representation of the body.\n        responseBody = Buffer.from(interceptor.body, 'utf8');\n      }\n    }\n    return continueWithResponseBody(responseBody);\n  }\n  function continueWithFullResponse(fullReplyResult) {\n    var responseBody;\n    try {\n      responseBody = parseFullReplyResult(response, fullReplyResult);\n    } catch (err) {\n      req.destroy(err);\n      return;\n    }\n    continueWithResponseBody(responseBody);\n  }\n  function prepareResponseHeaders(body) {\n    var _response$rawHeaders2;\n    var defaultHeaders = _toConsumableArray(interceptor.scope._defaultReplyHeaders);\n\n    // Include a JSON content type when JSON.stringify is called on the body.\n    // This is a convenience added by Nock that has no analog in Node. It's added to the\n    // defaults, so it will be ignored if the caller explicitly provided the header already.\n    var isJSON = body !== undefined && typeof body !== 'string' && !Buffer.isBuffer(body) && !common.isStream(body);\n    if (isJSON) {\n      defaultHeaders.push('Content-Type', 'application/json');\n    }\n    (_response$rawHeaders2 = response.rawHeaders).push.apply(_response$rawHeaders2, _toConsumableArray(selectDefaultHeaders(response.rawHeaders, defaultHeaders)));\n\n    // Evaluate functional headers.\n    common.forEachHeader(response.rawHeaders, function (value, fieldName, i) {\n      if (typeof value === 'function') {\n        response.rawHeaders[i + 1] = value(req, response, body);\n      }\n    });\n    response.headers = common.headersArrayToObject(response.rawHeaders);\n  }\n  function continueWithResponseBody(rawBody) {\n    prepareResponseHeaders(rawBody);\n    var bodyAsStream = convertBodyToStream(rawBody);\n    bodyAsStream.pause();\n\n    // IncomingMessage extends Readable so we can't simply pipe.\n    bodyAsStream.on('data', function (chunk) {\n      response.push(chunk);\n    });\n    bodyAsStream.on('end', function () {\n      // https://nodejs.org/dist/latest-v10.x/docs/api/http.html#http_message_complete\n      response.complete = true;\n      response.push(null);\n      interceptor.scope.emit('replied', req, interceptor);\n    });\n    bodyAsStream.on('error', function (err) {\n      response.emit('error', err);\n    });\n    var delayBodyInMs = interceptor.delayBodyInMs,\n      delayConnectionInMs = interceptor.delayConnectionInMs;\n    function respond() {\n      if (common.isRequestDestroyed(req)) {\n        return;\n      }\n\n      // Even though we've had the response object for awhile at this point,\n      // we only attach it to the request immediately before the `response`\n      // event because, as in Node, it alters the error handling around aborts.\n      req.res = response;\n      response.req = req;\n      logger('emitting response');\n      req.emit('response', response);\n      common.setTimeout(function () {\n        return bodyAsStream.resume();\n      }, delayBodyInMs);\n    }\n    socket.applyDelay(delayConnectionInMs);\n    common.setTimeout(respond, delayConnectionInMs);\n  }\n\n  // Calling `start` immediately could take the request all the way to the connection delay\n  // during a single microtask execution. This setImmediate stalls the playback to ensure the\n  // correct events are emitted first ('socket', 'finish') and any aborts in the queue or\n  // called during a 'finish' listener can be called.\n  common.setImmediate(function () {\n    if (!common.isRequestDestroyed(req)) {\n      start();\n    }\n  });\n}\nmodule.exports = {\n  playbackInterceptor: playbackInterceptor\n};","map":{"version":3,"names":["stream","require","util","zlib","debug","common","parseJSONRequestBody","req","requestBody","isJSONContent","headers","contentEncoding","String","gunzipSync","Buffer","from","inflateSync","JSON","parse","parseFullReplyResult","response","fullReplyResult","Array","isArray","Error","length","status","body","Number","isInteger","statusCode","rawHeaders","push","headersInputToRawArray","selectDefaultHeaders","existingHeaders","defaultHeaders","definedHeaders","Set","result","forEachHeader","_","fieldName","add","toLowerCase","value","has","ReadableBuffers","buffers","opts","_size","shift","Readable","convertBodyToStream","isStream","undefined","isBuffer","stringify","playbackInterceptor","socket","options","requestBodyString","requestBodyIsUtf8Representable","interceptor","logger","scope","start","getHeaders","emit","errorMessage","error","delay","delayBodyInMs","delayConnectionInMs","setTimeout","destroy","replyFunction","parsedRequestBody","fn","promisify","Promise","resolve","call","path","then","continueWithResponseBody","catch","err","fullReplyFunction","continueWithFullResponse","isContentEncoded","bufferData","responseBuffers","map","data","responseBody","prepareResponseHeaders","_defaultReplyHeaders","isJSON","i","headersArrayToObject","rawBody","bodyAsStream","pause","on","chunk","complete","respond","isRequestDestroyed","res","resume","applyDelay","setImmediate","module","exports"],"sources":["/Users/lieo/diabetes/CUT2DMTest/node_modules/nock/lib/playback_interceptor.js"],"sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst util = require('util')\nconst zlib = require('zlib')\nconst debug = require('debug')('nock.playback_interceptor')\nconst common = require('./common')\n\nfunction parseJSONRequestBody(req, requestBody) {\n  if (!requestBody || !common.isJSONContent(req.headers)) {\n    return requestBody\n  }\n\n  if (common.contentEncoding(req.headers, 'gzip')) {\n    requestBody = String(zlib.gunzipSync(Buffer.from(requestBody, 'hex')))\n  } else if (common.contentEncoding(req.headers, 'deflate')) {\n    requestBody = String(zlib.inflateSync(Buffer.from(requestBody, 'hex')))\n  }\n\n  return JSON.parse(requestBody)\n}\n\nfunction parseFullReplyResult(response, fullReplyResult) {\n  debug('full response from callback result: %j', fullReplyResult)\n\n  if (!Array.isArray(fullReplyResult)) {\n    throw Error('A single function provided to .reply MUST return an array')\n  }\n\n  if (fullReplyResult.length > 3) {\n    throw Error(\n      'The array returned from the .reply callback contains too many values'\n    )\n  }\n\n  const [status, body = '', headers] = fullReplyResult\n\n  if (!Number.isInteger(status)) {\n    throw new Error(`Invalid ${typeof status} value for status code`)\n  }\n\n  response.statusCode = status\n  response.rawHeaders.push(...common.headersInputToRawArray(headers))\n  debug('response.rawHeaders after reply: %j', response.rawHeaders)\n\n  return body\n}\n\n/**\n * Determine which of the default headers should be added to the response.\n *\n * Don't include any defaults whose case-insensitive keys are already on the response.\n */\nfunction selectDefaultHeaders(existingHeaders, defaultHeaders) {\n  if (!defaultHeaders.length) {\n    return [] // return early if we don't need to bother\n  }\n\n  const definedHeaders = new Set()\n  const result = []\n\n  common.forEachHeader(existingHeaders, (_, fieldName) => {\n    definedHeaders.add(fieldName.toLowerCase())\n  })\n  common.forEachHeader(defaultHeaders, (value, fieldName) => {\n    if (!definedHeaders.has(fieldName.toLowerCase())) {\n      result.push(fieldName, value)\n    }\n  })\n\n  return result\n}\n\n// Presents a list of Buffers as a Readable\nclass ReadableBuffers extends stream.Readable {\n  constructor(buffers, opts = {}) {\n    super(opts)\n\n    this.buffers = buffers\n  }\n\n  _read(_size) {\n    while (this.buffers.length) {\n      if (!this.push(this.buffers.shift())) {\n        return\n      }\n    }\n    this.push(null)\n  }\n}\n\nfunction convertBodyToStream(body) {\n  if (common.isStream(body)) {\n    return body\n  }\n\n  if (body === undefined) {\n    return new ReadableBuffers([])\n  }\n\n  if (Buffer.isBuffer(body)) {\n    return new ReadableBuffers([body])\n  }\n\n  if (typeof body !== 'string') {\n    body = JSON.stringify(body)\n  }\n\n  return new ReadableBuffers([Buffer.from(body)])\n}\n\n/**\n * Play back an interceptor using the given request and mock response.\n */\nfunction playbackInterceptor({\n  req,\n  socket,\n  options,\n  requestBodyString,\n  requestBodyIsUtf8Representable,\n  response,\n  interceptor,\n}) {\n  const { logger } = interceptor.scope\n\n  function start() {\n    req.headers = req.getHeaders()\n\n    interceptor.scope.emit('request', req, interceptor, requestBodyString)\n\n    if (typeof interceptor.errorMessage !== 'undefined') {\n      let error\n      if (typeof interceptor.errorMessage === 'object') {\n        error = interceptor.errorMessage\n      } else {\n        error = new Error(interceptor.errorMessage)\n      }\n\n      const delay = interceptor.delayBodyInMs + interceptor.delayConnectionInMs\n      common.setTimeout(() => req.destroy(error), delay)\n      return\n    }\n\n    // This will be null if we have a fullReplyFunction,\n    // in that case status code will be set in `parseFullReplyResult`\n    response.statusCode = interceptor.statusCode\n\n    // Clone headers/rawHeaders to not override them when evaluating later\n    response.rawHeaders = [...interceptor.rawHeaders]\n    logger('response.rawHeaders:', response.rawHeaders)\n\n    // TODO: MAJOR: Don't tack the request onto the interceptor.\n    // The only reason we do this is so that it's available inside reply functions.\n    // It would be better to pass the request as an argument to the functions instead.\n    // Not adding the req as a third arg now because it should first be decided if (path, body, req)\n    // is the signature we want to go with going forward.\n    interceptor.req = req\n\n    if (interceptor.replyFunction) {\n      const parsedRequestBody = parseJSONRequestBody(req, requestBodyString)\n\n      let fn = interceptor.replyFunction\n      if (fn.length === 3) {\n        // Handle the case of an async reply function, the third parameter being the callback.\n        fn = util.promisify(fn)\n      }\n\n      // At this point `fn` is either a synchronous function or a promise-returning function;\n      // wrapping in `Promise.resolve` makes it into a promise either way.\n      Promise.resolve(fn.call(interceptor, options.path, parsedRequestBody))\n        .then(continueWithResponseBody)\n        .catch(err => req.destroy(err))\n      return\n    }\n\n    if (interceptor.fullReplyFunction) {\n      const parsedRequestBody = parseJSONRequestBody(req, requestBodyString)\n\n      let fn = interceptor.fullReplyFunction\n      if (fn.length === 3) {\n        fn = util.promisify(fn)\n      }\n\n      Promise.resolve(fn.call(interceptor, options.path, parsedRequestBody))\n        .then(continueWithFullResponse)\n        .catch(err => req.destroy(err))\n      return\n    }\n\n    if (\n      common.isContentEncoded(interceptor.headers) &&\n      !common.isStream(interceptor.body)\n    ) {\n      //  If the content is encoded we know that the response body *must* be an array\n      //  of response buffers which should be mocked one by one.\n      //  (otherwise decompressions after the first one fails as unzip expects to receive\n      //  buffer by buffer and not one single merged buffer)\n      const bufferData = Array.isArray(interceptor.body)\n        ? interceptor.body\n        : [interceptor.body]\n      const responseBuffers = bufferData.map(data => Buffer.from(data, 'hex'))\n      const responseBody = new ReadableBuffers(responseBuffers)\n      continueWithResponseBody(responseBody)\n      return\n    }\n\n    // If we get to this point, the body is either a string or an object that\n    // will eventually be JSON stringified.\n    let responseBody = interceptor.body\n\n    // If the request was not UTF8-representable then we assume that the\n    // response won't be either. In that case we send the response as a Buffer\n    // object as that's what the client will expect.\n    if (!requestBodyIsUtf8Representable && typeof responseBody === 'string') {\n      // Try to create the buffer from the interceptor's body response as hex.\n      responseBody = Buffer.from(responseBody, 'hex')\n\n      // Creating buffers does not necessarily throw errors; check for difference in size.\n      if (\n        !responseBody ||\n        (interceptor.body.length > 0 && responseBody.length === 0)\n      ) {\n        // We fallback on constructing buffer from utf8 representation of the body.\n        responseBody = Buffer.from(interceptor.body, 'utf8')\n      }\n    }\n\n    return continueWithResponseBody(responseBody)\n  }\n\n  function continueWithFullResponse(fullReplyResult) {\n    let responseBody\n    try {\n      responseBody = parseFullReplyResult(response, fullReplyResult)\n    } catch (err) {\n      req.destroy(err)\n      return\n    }\n\n    continueWithResponseBody(responseBody)\n  }\n\n  function prepareResponseHeaders(body) {\n    const defaultHeaders = [...interceptor.scope._defaultReplyHeaders]\n\n    // Include a JSON content type when JSON.stringify is called on the body.\n    // This is a convenience added by Nock that has no analog in Node. It's added to the\n    // defaults, so it will be ignored if the caller explicitly provided the header already.\n    const isJSON =\n      body !== undefined &&\n      typeof body !== 'string' &&\n      !Buffer.isBuffer(body) &&\n      !common.isStream(body)\n\n    if (isJSON) {\n      defaultHeaders.push('Content-Type', 'application/json')\n    }\n\n    response.rawHeaders.push(\n      ...selectDefaultHeaders(response.rawHeaders, defaultHeaders)\n    )\n\n    // Evaluate functional headers.\n    common.forEachHeader(response.rawHeaders, (value, fieldName, i) => {\n      if (typeof value === 'function') {\n        response.rawHeaders[i + 1] = value(req, response, body)\n      }\n    })\n\n    response.headers = common.headersArrayToObject(response.rawHeaders)\n  }\n\n  function continueWithResponseBody(rawBody) {\n    prepareResponseHeaders(rawBody)\n    const bodyAsStream = convertBodyToStream(rawBody)\n    bodyAsStream.pause()\n\n    // IncomingMessage extends Readable so we can't simply pipe.\n    bodyAsStream.on('data', function (chunk) {\n      response.push(chunk)\n    })\n    bodyAsStream.on('end', function () {\n      // https://nodejs.org/dist/latest-v10.x/docs/api/http.html#http_message_complete\n      response.complete = true\n      response.push(null)\n\n      interceptor.scope.emit('replied', req, interceptor)\n    })\n    bodyAsStream.on('error', function (err) {\n      response.emit('error', err)\n    })\n\n    const { delayBodyInMs, delayConnectionInMs } = interceptor\n\n    function respond() {\n      if (common.isRequestDestroyed(req)) {\n        return\n      }\n\n      // Even though we've had the response object for awhile at this point,\n      // we only attach it to the request immediately before the `response`\n      // event because, as in Node, it alters the error handling around aborts.\n      req.res = response\n      response.req = req\n\n      logger('emitting response')\n      req.emit('response', response)\n\n      common.setTimeout(() => bodyAsStream.resume(), delayBodyInMs)\n    }\n\n    socket.applyDelay(delayConnectionInMs)\n    common.setTimeout(respond, delayConnectionInMs)\n  }\n\n  // Calling `start` immediately could take the request all the way to the connection delay\n  // during a single microtask execution. This setImmediate stalls the playback to ensure the\n  // correct events are emitted first ('socket', 'finish') and any aborts in the queue or\n  // called during a 'finish' listener can be called.\n  common.setImmediate(() => {\n    if (!common.isRequestDestroyed(req)) {\n      start()\n    }\n  })\n}\n\nmodule.exports = { playbackInterceptor }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}