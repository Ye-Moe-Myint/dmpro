{"ast":null,"code":"// write data to it, and it'll emit data in 512 byte blocks.\n// if you .end() or .flush(), it'll emit whatever it's got,\n// padded with nulls to 512 bytes.\n\nmodule.exports = BlockStream;\nvar Stream = require(\"stream\").Stream,\n  inherits = require(\"inherits\"),\n  assert = require(\"assert\").ok,\n  debug = process.env.DEBUG ? console.error : function () {};\nfunction BlockStream(size, opt) {\n  this.writable = this.readable = true;\n  this._opt = opt || {};\n  this._chunkSize = size || 512;\n  this._offset = 0;\n  this._buffer = [];\n  this._bufferLength = 0;\n  if (this._opt.nopad) this._zeroes = false;else {\n    this._zeroes = new Buffer(this._chunkSize);\n    for (var i = 0; i < this._chunkSize; i++) {\n      this._zeroes[i] = 0;\n    }\n  }\n}\ninherits(BlockStream, Stream);\nBlockStream.prototype.write = function (c) {\n  // debug(\"   BS write\", c)\n  if (this._ended) throw new Error(\"BlockStream: write after end\");\n  if (c && !Buffer.isBuffer(c)) c = new Buffer(c + \"\");\n  if (c.length) {\n    this._buffer.push(c);\n    this._bufferLength += c.length;\n  }\n  // debug(\"pushed onto buffer\", this._bufferLength)\n  if (this._bufferLength >= this._chunkSize) {\n    if (this._paused) {\n      // debug(\"   BS paused, return false, need drain\")\n      this._needDrain = true;\n      return false;\n    }\n    this._emitChunk();\n  }\n  return true;\n};\nBlockStream.prototype.pause = function () {\n  // debug(\"   BS pausing\")\n  this._paused = true;\n};\nBlockStream.prototype.resume = function () {\n  // debug(\"   BS resume\")\n  this._paused = false;\n  return this._emitChunk();\n};\nBlockStream.prototype.end = function (chunk) {\n  // debug(\"end\", chunk)\n  if (typeof chunk === \"function\") cb = chunk, chunk = null;\n  if (chunk) this.write(chunk);\n  this._ended = true;\n  this.flush();\n};\nBlockStream.prototype.flush = function () {\n  this._emitChunk(true);\n};\nBlockStream.prototype._emitChunk = function (flush) {\n  // debug(\"emitChunk flush=%j emitting=%j paused=%j\", flush, this._emitting, this._paused)\n\n  // emit a <chunkSize> chunk\n  if (flush && this._zeroes) {\n    // debug(\"    BS push zeroes\", this._bufferLength)\n    // push a chunk of zeroes\n    var padBytes = this._bufferLength % this._chunkSize;\n    if (padBytes !== 0) padBytes = this._chunkSize - padBytes;\n    if (padBytes > 0) {\n      // debug(\"padBytes\", padBytes, this._zeroes.slice(0, padBytes))\n      this._buffer.push(this._zeroes.slice(0, padBytes));\n      this._bufferLength += padBytes;\n      // debug(this._buffer[this._buffer.length - 1].length, this._bufferLength)\n    }\n  }\n\n  if (this._emitting || this._paused) return;\n  this._emitting = true;\n\n  // debug(\"    BS entering loops\")\n  var bufferIndex = 0;\n  while (this._bufferLength >= this._chunkSize && (flush || !this._paused)) {\n    // debug(\"     BS data emission loop\", this._bufferLength)\n\n    var out,\n      outOffset = 0,\n      outHas = this._chunkSize;\n    while (outHas > 0 && (flush || !this._paused)) {\n      // debug(\"    BS data inner emit loop\", this._bufferLength)\n      var cur = this._buffer[bufferIndex],\n        curHas = cur.length - this._offset;\n      // debug(\"cur=\", cur)\n      // debug(\"curHas=%j\", curHas)\n      // If it's not big enough to fill the whole thing, then we'll need\n      // to copy multiple buffers into one.  However, if it is big enough,\n      // then just slice out the part we want, to save unnecessary copying.\n      // Also, need to copy if we've already done some copying, since buffers\n      // can't be joined like cons strings.\n      if (out || curHas < outHas) {\n        out = out || new Buffer(this._chunkSize);\n        cur.copy(out, outOffset, this._offset, this._offset + Math.min(curHas, outHas));\n      } else if (cur.length === outHas && this._offset === 0) {\n        // shortcut -- cur is exactly long enough, and no offset.\n        out = cur;\n      } else {\n        // slice out the piece of cur that we need.\n        out = cur.slice(this._offset, this._offset + outHas);\n      }\n      if (curHas > outHas) {\n        // means that the current buffer couldn't be completely output\n        // update this._offset to reflect how much WAS written\n        this._offset += outHas;\n        outHas = 0;\n      } else {\n        // output the entire current chunk.\n        // toss it away\n        outHas -= curHas;\n        outOffset += curHas;\n        bufferIndex++;\n        this._offset = 0;\n      }\n    }\n    this._bufferLength -= this._chunkSize;\n    assert(out.length === this._chunkSize);\n    // debug(\"emitting data\", out)\n    // debug(\"   BS emitting, paused=%j\", this._paused, this._bufferLength)\n    this.emit(\"data\", out);\n    out = null;\n  }\n  // debug(\"    BS out of loops\", this._bufferLength)\n\n  // whatever is left, it's not enough to fill up a block, or we're paused\n  this._buffer = this._buffer.slice(bufferIndex);\n  if (this._paused) {\n    // debug(\"    BS paused, leaving\", this._bufferLength)\n    this._needsDrain = true;\n    this._emitting = false;\n    return;\n  }\n\n  // if flushing, and not using null-padding, then need to emit the last\n  // chunk(s) sitting in the queue.  We know that it's not enough to\n  // fill up a whole block, because otherwise it would have been emitted\n  // above, but there may be some offset.\n  var l = this._buffer.length;\n  if (flush && !this._zeroes && l) {\n    if (l === 1) {\n      if (this._offset) {\n        this.emit(\"data\", this._buffer[0].slice(this._offset));\n      } else {\n        this.emit(\"data\", this._buffer[0]);\n      }\n    } else {\n      var outHas = this._bufferLength,\n        out = new Buffer(outHas),\n        outOffset = 0;\n      for (var i = 0; i < l; i++) {\n        var cur = this._buffer[i],\n          curHas = cur.length - this._offset;\n        cur.copy(out, outOffset, this._offset);\n        this._offset = 0;\n        outOffset += curHas;\n        this._bufferLength -= curHas;\n      }\n      this.emit(\"data\", out);\n    }\n    // truncate\n    this._buffer.length = 0;\n    this._bufferLength = 0;\n    this._offset = 0;\n  }\n\n  // now either drained or ended\n  // debug(\"either draining, or ended\", this._bufferLength, this._ended)\n  // means that we've flushed out all that we can so far.\n  if (this._needDrain) {\n    // debug(\"emitting drain\", this._bufferLength)\n    this._needDrain = false;\n    this.emit(\"drain\");\n  }\n  if (this._bufferLength === 0 && this._ended && !this._endEmitted) {\n    // debug(\"emitting end\", this._bufferLength)\n    this._endEmitted = true;\n    this.emit(\"end\");\n  }\n  this._emitting = false;\n\n  // debug(\"    BS no longer emitting\", flush, this._paused, this._emitting, this._bufferLength, this._chunkSize)\n};","map":{"version":3,"names":["module","exports","BlockStream","Stream","require","inherits","assert","ok","debug","process","env","DEBUG","console","error","size","opt","writable","readable","_opt","_chunkSize","_offset","_buffer","_bufferLength","nopad","_zeroes","Buffer","i","prototype","write","c","_ended","Error","isBuffer","length","push","_paused","_needDrain","_emitChunk","pause","resume","end","chunk","cb","flush","padBytes","slice","_emitting","bufferIndex","out","outOffset","outHas","cur","curHas","copy","Math","min","emit","_needsDrain","l","_endEmitted"],"sources":["/Users/lieo/diabetes/CUT2DMTest/node_modules/block-stream/block-stream.js"],"sourcesContent":["// write data to it, and it'll emit data in 512 byte blocks.\n// if you .end() or .flush(), it'll emit whatever it's got,\n// padded with nulls to 512 bytes.\n\nmodule.exports = BlockStream\n\nvar Stream = require(\"stream\").Stream\n  , inherits = require(\"inherits\")\n  , assert = require(\"assert\").ok\n  , debug = process.env.DEBUG ? console.error : function () {}\n\nfunction BlockStream (size, opt) {\n  this.writable = this.readable = true\n  this._opt = opt || {}\n  this._chunkSize = size || 512\n  this._offset = 0\n  this._buffer = []\n  this._bufferLength = 0\n  if (this._opt.nopad) this._zeroes = false\n  else {\n    this._zeroes = new Buffer(this._chunkSize)\n    for (var i = 0; i < this._chunkSize; i ++) {\n      this._zeroes[i] = 0\n    }\n  }\n}\n\ninherits(BlockStream, Stream)\n\nBlockStream.prototype.write = function (c) {\n  // debug(\"   BS write\", c)\n  if (this._ended) throw new Error(\"BlockStream: write after end\")\n  if (c && !Buffer.isBuffer(c)) c = new Buffer(c + \"\")\n  if (c.length) {\n    this._buffer.push(c)\n    this._bufferLength += c.length\n  }\n  // debug(\"pushed onto buffer\", this._bufferLength)\n  if (this._bufferLength >= this._chunkSize) {\n    if (this._paused) {\n      // debug(\"   BS paused, return false, need drain\")\n      this._needDrain = true\n      return false\n    }\n    this._emitChunk()\n  }\n  return true\n}\n\nBlockStream.prototype.pause = function () {\n  // debug(\"   BS pausing\")\n  this._paused = true\n}\n\nBlockStream.prototype.resume = function () {\n  // debug(\"   BS resume\")\n  this._paused = false\n  return this._emitChunk()\n}\n\nBlockStream.prototype.end = function (chunk) {\n  // debug(\"end\", chunk)\n  if (typeof chunk === \"function\") cb = chunk, chunk = null\n  if (chunk) this.write(chunk)\n  this._ended = true\n  this.flush()\n}\n\nBlockStream.prototype.flush = function () {\n  this._emitChunk(true)\n}\n\nBlockStream.prototype._emitChunk = function (flush) {\n  // debug(\"emitChunk flush=%j emitting=%j paused=%j\", flush, this._emitting, this._paused)\n\n  // emit a <chunkSize> chunk\n  if (flush && this._zeroes) {\n    // debug(\"    BS push zeroes\", this._bufferLength)\n    // push a chunk of zeroes\n    var padBytes = (this._bufferLength % this._chunkSize)\n    if (padBytes !== 0) padBytes = this._chunkSize - padBytes\n    if (padBytes > 0) {\n      // debug(\"padBytes\", padBytes, this._zeroes.slice(0, padBytes))\n      this._buffer.push(this._zeroes.slice(0, padBytes))\n      this._bufferLength += padBytes\n      // debug(this._buffer[this._buffer.length - 1].length, this._bufferLength)\n    }\n  }\n\n  if (this._emitting || this._paused) return\n  this._emitting = true\n\n  // debug(\"    BS entering loops\")\n  var bufferIndex = 0\n  while (this._bufferLength >= this._chunkSize &&\n         (flush || !this._paused)) {\n    // debug(\"     BS data emission loop\", this._bufferLength)\n\n    var out\n      , outOffset = 0\n      , outHas = this._chunkSize\n\n    while (outHas > 0 && (flush || !this._paused) ) {\n      // debug(\"    BS data inner emit loop\", this._bufferLength)\n      var cur = this._buffer[bufferIndex]\n        , curHas = cur.length - this._offset\n      // debug(\"cur=\", cur)\n      // debug(\"curHas=%j\", curHas)\n      // If it's not big enough to fill the whole thing, then we'll need\n      // to copy multiple buffers into one.  However, if it is big enough,\n      // then just slice out the part we want, to save unnecessary copying.\n      // Also, need to copy if we've already done some copying, since buffers\n      // can't be joined like cons strings.\n      if (out || curHas < outHas) {\n        out = out || new Buffer(this._chunkSize)\n        cur.copy(out, outOffset,\n                 this._offset, this._offset + Math.min(curHas, outHas))\n      } else if (cur.length === outHas && this._offset === 0) {\n        // shortcut -- cur is exactly long enough, and no offset.\n        out = cur\n      } else {\n        // slice out the piece of cur that we need.\n        out = cur.slice(this._offset, this._offset + outHas)\n      }\n\n      if (curHas > outHas) {\n        // means that the current buffer couldn't be completely output\n        // update this._offset to reflect how much WAS written\n        this._offset += outHas\n        outHas = 0\n      } else {\n        // output the entire current chunk.\n        // toss it away\n        outHas -= curHas\n        outOffset += curHas\n        bufferIndex ++\n        this._offset = 0\n      }\n    }\n\n    this._bufferLength -= this._chunkSize\n    assert(out.length === this._chunkSize)\n    // debug(\"emitting data\", out)\n    // debug(\"   BS emitting, paused=%j\", this._paused, this._bufferLength)\n    this.emit(\"data\", out)\n    out = null\n  }\n  // debug(\"    BS out of loops\", this._bufferLength)\n\n  // whatever is left, it's not enough to fill up a block, or we're paused\n  this._buffer = this._buffer.slice(bufferIndex)\n  if (this._paused) {\n    // debug(\"    BS paused, leaving\", this._bufferLength)\n    this._needsDrain = true\n    this._emitting = false\n    return\n  }\n\n  // if flushing, and not using null-padding, then need to emit the last\n  // chunk(s) sitting in the queue.  We know that it's not enough to\n  // fill up a whole block, because otherwise it would have been emitted\n  // above, but there may be some offset.\n  var l = this._buffer.length\n  if (flush && !this._zeroes && l) {\n    if (l === 1) {\n      if (this._offset) {\n        this.emit(\"data\", this._buffer[0].slice(this._offset))\n      } else {\n        this.emit(\"data\", this._buffer[0])\n      }\n    } else {\n      var outHas = this._bufferLength\n        , out = new Buffer(outHas)\n        , outOffset = 0\n      for (var i = 0; i < l; i ++) {\n        var cur = this._buffer[i]\n          , curHas = cur.length - this._offset\n        cur.copy(out, outOffset, this._offset)\n        this._offset = 0\n        outOffset += curHas\n        this._bufferLength -= curHas\n      }\n      this.emit(\"data\", out)\n    }\n    // truncate\n    this._buffer.length = 0\n    this._bufferLength = 0\n    this._offset = 0\n  }\n\n  // now either drained or ended\n  // debug(\"either draining, or ended\", this._bufferLength, this._ended)\n  // means that we've flushed out all that we can so far.\n  if (this._needDrain) {\n    // debug(\"emitting drain\", this._bufferLength)\n    this._needDrain = false\n    this.emit(\"drain\")\n  }\n\n  if ((this._bufferLength === 0) && this._ended && !this._endEmitted) {\n    // debug(\"emitting end\", this._bufferLength)\n    this._endEmitted = true\n    this.emit(\"end\")\n  }\n\n  this._emitting = false\n\n  // debug(\"    BS no longer emitting\", flush, this._paused, this._emitting, this._bufferLength, this._chunkSize)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}