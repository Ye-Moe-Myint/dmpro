{"ast":null,"code":"module.exports = exports = function exports(gyp, argv, callback) {\n  return install(fs, gyp, argv, callback);\n};\nmodule.exports.test = {\n  download: download,\n  install: install,\n  readCAFile: readCAFile\n};\nexports.usage = 'Install node development files for the specified node version.';\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('graceful-fs'),\n  osenv = require('osenv'),\n  tar = require('tar'),\n  rm = require('rimraf'),\n  path = require('path'),\n  crypto = require('crypto'),\n  zlib = require('zlib'),\n  log = require('npmlog'),\n  semver = require('semver'),\n  fstream = require('fstream'),\n  request = require('request'),\n  mkdir = require('mkdirp'),\n  processRelease = require('./process-release'),\n  win = process.platform == 'win32';\nfunction install(fs, gyp, argv, callback) {\n  var release = processRelease(argv, gyp, process.version, process.release);\n\n  // ensure no double-callbacks happen\n  function cb(err) {\n    if (cb.done) return;\n    cb.done = true;\n    if (err) {\n      log.warn('install', 'got an error, rolling back install');\n      // roll-back the install if anything went wrong\n      gyp.commands.remove([release.versionDir], function (err2) {\n        callback(err);\n      });\n    } else {\n      callback(null, release.version);\n    }\n  }\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version);\n  if (!release.semver) {\n    // could not parse the version string with semver\n    return callback(new Error('Invalid version number: ' + release.version));\n  }\n  if (semver.lt(release.version, '0.8.0')) {\n    return callback(new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version));\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version);\n    if (gyp.opts.nodedir) {\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n      callback();\n    } else {\n      callback(new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead'));\n    }\n    return;\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir);\n\n  // the directory where the dev files will be installed\n  var devDir = path.resolve(gyp.devDir, release.versionDir);\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n    fs.stat(devDir, function (err, stat) {\n      if (err) {\n        if (err.code == 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version);\n          go();\n        } else if (err.code == 'EACCES') {\n          eaccesFallback(err);\n        } else {\n          cb(err);\n        }\n        return;\n      }\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n      var installVersionFile = path.resolve(devDir, 'installVersion');\n      fs.readFile(installVersionFile, 'ascii', function (err, ver) {\n        if (err && err.code != 'ENOENT') {\n          return cb(err);\n        }\n        var installVersion = parseInt(ver, 10) || 0;\n        log.verbose('got \"installVersion\"', installVersion);\n        log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n        if (installVersion < gyp.package.installVersion) {\n          log.verbose('install', 'version is no good; reinstalling');\n          go();\n        } else {\n          log.verbose('install', 'version is good');\n          cb();\n        }\n      });\n    });\n  } else {\n    go();\n  }\n  function getContentSha(res, callback) {\n    var shasum = crypto.createHash('sha256');\n    res.on('data', function (chunk) {\n      shasum.update(chunk);\n    }).on('end', function () {\n      callback(null, shasum.digest('hex'));\n    });\n  }\n  function go() {\n    log.verbose('ensuring nodedir is created', devDir);\n\n    // first create the dir for the node dev files\n    mkdir(devDir, function (err, created) {\n      if (err) {\n        if (err.code == 'EACCES') {\n          eaccesFallback(err);\n        } else {\n          cb(err);\n        }\n        return;\n      }\n      if (created) {\n        log.verbose('created nodedir', created);\n      }\n\n      // now download the node tarball\n      var tarPath = gyp.opts.tarball;\n      var badDownload = false,\n        extractCount = 0,\n        gunzip = zlib.createGunzip(),\n        extracter = tar.Extract({\n          path: devDir,\n          strip: 1,\n          filter: isValid\n        });\n      var contentShasums = {};\n      var expectShasums = {};\n\n      // checks if a file to be extracted from the tarball is valid.\n      // only .h header files and the gyp files get extracted\n      function isValid() {\n        var name = this.path.substring(devDir.length + 1);\n        var isValid = valid(name);\n        if (name === '' && this.type === 'Directory') {\n          // the first directory entry is ok\n          return true;\n        }\n        if (isValid) {\n          log.verbose('extracted file from tarball', name);\n          extractCount++;\n        } else {\n          // invalid\n          log.silly('ignoring from tarball', name);\n        }\n        return isValid;\n      }\n      gunzip.on('error', cb);\n      extracter.on('error', cb);\n      extracter.on('end', afterTarball);\n\n      // download the tarball, gunzip and extract!\n\n      if (tarPath) {\n        var input = fs.createReadStream(tarPath);\n        input.pipe(gunzip).pipe(extracter);\n        return;\n      }\n      try {\n        var req = download(gyp, process.env, release.tarballUrl);\n      } catch (e) {\n        return cb(e);\n      }\n\n      // something went wrong downloading the tarball?\n      req.on('error', function (err) {\n        if (err.code === 'ENOTFOUND') {\n          return cb(new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.'));\n        }\n        badDownload = true;\n        cb(err);\n      });\n      req.on('close', function () {\n        if (extractCount === 0) {\n          cb(new Error('Connection closed while downloading tarball file'));\n        }\n      });\n      req.on('response', function (res) {\n        if (res.statusCode !== 200) {\n          badDownload = true;\n          cb(new Error(res.statusCode + ' response downloading ' + release.tarballUrl));\n          return;\n        }\n        // content checksum\n        getContentSha(res, function (_, checksum) {\n          var filename = path.basename(release.tarballUrl).trim();\n          contentShasums[filename] = checksum;\n          log.verbose('content checksum', filename, checksum);\n        });\n\n        // start unzipping and untaring\n        req.pipe(gunzip).pipe(extracter);\n      });\n\n      // invoked after the tarball has finished being extracted\n      function afterTarball() {\n        if (badDownload) return;\n        if (extractCount === 0) {\n          return cb(new Error('There was a fatal problem while downloading/extracting the tarball'));\n        }\n        log.verbose('tarball', 'done parsing tarball');\n        var async = 0;\n        if (win) {\n          // need to download node.lib\n          async++;\n          downloadNodeLib(deref);\n        }\n\n        // write the \"installVersion\" file\n        async++;\n        var installVersionPath = path.resolve(devDir, 'installVersion');\n        fs.writeFile(installVersionPath, gyp.package.installVersion + '\\n', deref);\n\n        // Only download SHASUMS.txt if not using tarPath override\n        if (!tarPath) {\n          // download SHASUMS.txt\n          async++;\n          downloadShasums(deref);\n        }\n        if (async === 0) {\n          // no async tasks required\n          cb();\n        }\n        function deref(err) {\n          if (err) return cb(err);\n          async--;\n          if (!async) {\n            log.verbose('download contents checksum', JSON.stringify(contentShasums));\n            // check content shasums\n            for (var k in contentShasums) {\n              log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n              if (contentShasums[k] !== expectShasums[k]) {\n                cb(new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]));\n                return;\n              }\n            }\n            cb();\n          }\n        }\n      }\n      function downloadShasums(done) {\n        log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n        var shasumsPath = path.resolve(devDir, 'SHASUMS256.txt');\n        log.verbose('checksum url', release.shasumsUrl);\n        try {\n          var req = download(gyp, process.env, release.shasumsUrl);\n        } catch (e) {\n          return cb(e);\n        }\n        req.on('error', done);\n        req.on('response', function (res) {\n          if (res.statusCode !== 200) {\n            done(new Error(res.statusCode + ' status code downloading checksum'));\n            return;\n          }\n          var chunks = [];\n          res.on('data', function (chunk) {\n            chunks.push(chunk);\n          });\n          res.on('end', function () {\n            var lines = Buffer.concat(chunks).toString().trim().split('\\n');\n            lines.forEach(function (line) {\n              var items = line.trim().split(/\\s+/);\n              if (items.length !== 2) return;\n\n              // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n              var name = items[1].replace(/^\\.\\//, '');\n              expectShasums[name] = items[0];\n            });\n            log.verbose('checksum data', JSON.stringify(expectShasums));\n            done();\n          });\n        });\n      }\n      function downloadNodeLib(done) {\n        log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n        var dir32 = path.resolve(devDir, 'ia32'),\n          dir64 = path.resolve(devDir, 'x64'),\n          libPath32 = path.resolve(dir32, release.name + '.lib'),\n          libPath64 = path.resolve(dir64, release.name + '.lib');\n        log.verbose('32-bit ' + release.name + '.lib dir', dir32);\n        log.verbose('64-bit ' + release.name + '.lib dir', dir64);\n        log.verbose('`' + release.name + '.lib` 32-bit url', release.libUrl32);\n        log.verbose('`' + release.name + '.lib` 64-bit url', release.libUrl64);\n        var async = 2;\n        mkdir(dir32, function (err) {\n          if (err) return done(err);\n          log.verbose('streaming 32-bit ' + release.name + '.lib to:', libPath32);\n          try {\n            var req = download(gyp, process.env, release.libUrl32, cb);\n          } catch (e) {\n            return cb(e);\n          }\n          req.on('error', done);\n          req.on('response', function (res) {\n            if (res.statusCode !== 200) {\n              done(new Error(res.statusCode + ' status code downloading 32-bit ' + release.name + '.lib'));\n              return;\n            }\n            getContentSha(res, function (_, checksum) {\n              contentShasums[release.libPath32] = checksum;\n              log.verbose('content checksum', release.libPath32, checksum);\n            });\n            var ws = fs.createWriteStream(libPath32);\n            ws.on('error', cb);\n            req.pipe(ws);\n          });\n          req.on('end', function () {\n            --async || done();\n          });\n        });\n        mkdir(dir64, function (err) {\n          if (err) return done(err);\n          log.verbose('streaming 64-bit ' + release.name + '.lib to:', libPath64);\n          try {\n            var req = download(gyp, process.env, release.libUrl64, cb);\n          } catch (e) {\n            return cb(e);\n          }\n          req.on('error', done);\n          req.on('response', function (res) {\n            if (res.statusCode !== 200) {\n              done(new Error(res.statusCode + ' status code downloading 64-bit ' + release.name + '.lib'));\n              return;\n            }\n            getContentSha(res, function (_, checksum) {\n              contentShasums[release.libPath64] = checksum;\n              log.verbose('content checksum', release.libPath64, checksum);\n            });\n            var ws = fs.createWriteStream(libPath64);\n            ws.on('error', cb);\n            req.pipe(ws);\n          });\n          req.on('end', function () {\n            --async || done();\n          });\n        });\n      } // downloadNodeLib()\n    }); // mkdir()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid(file) {\n    // header files\n    var extname = path.extname(file);\n    return extname === '.h' || extname === '.gypi';\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  function eaccesFallback(err) {\n    var noretry = '--node_gyp_internal_noretry';\n    if (-1 !== argv.indexOf(noretry)) return cb(err);\n    var tmpdir = osenv.tmpdir();\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n    log.warn('EACCES', 'user \"%s\" does not have permission to access the dev dir \"%s\"', osenv.user(), devDir);\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n    if (process.cwd() == tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n      gyp.todo.push({\n        name: 'remove',\n        args: argv\n      });\n    }\n    gyp.commands.install([noretry].concat(argv), cb);\n  }\n}\nfunction download(gyp, env, url) {\n  log.http('GET', url);\n  var requestOpts = {\n    uri: url,\n    headers: {\n      'User-Agent': 'node-gyp v' + gyp.version + ' (node ' + process.version + ')'\n    }\n  };\n  var cafile = gyp.opts.cafile;\n  if (cafile) {\n    requestOpts.ca = readCAFile(cafile);\n  }\n\n  // basic support for a proxy server\n  var proxyUrl = gyp.opts.proxy || env.http_proxy || env.HTTP_PROXY || env.npm_config_proxy;\n  if (proxyUrl) {\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl);\n      requestOpts.proxy = proxyUrl;\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl);\n    }\n  }\n  var req = request(requestOpts);\n  req.on('response', function (res) {\n    log.http(res.statusCode, url);\n  });\n  return req;\n}\nfunction readCAFile(filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  var ca = fs.readFileSync(filename, 'utf8');\n  var re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n  return ca.match(re);\n}","map":{"version":3,"names":["module","exports","gyp","argv","callback","install","fs","test","download","readCAFile","usage","require","osenv","tar","rm","path","crypto","zlib","log","semver","fstream","request","mkdir","processRelease","win","process","platform","release","version","cb","err","done","warn","commands","remove","versionDir","err2","verbose","Error","lt","prerelease","opts","nodedir","devDir","resolve","ensure","stat","code","go","eaccesFallback","installVersionFile","readFile","ver","installVersion","parseInt","package","getContentSha","res","shasum","createHash","on","chunk","update","digest","created","tarPath","tarball","badDownload","extractCount","gunzip","createGunzip","extracter","Extract","strip","filter","isValid","contentShasums","expectShasums","name","substring","length","valid","type","silly","afterTarball","input","createReadStream","pipe","req","env","tarballUrl","e","statusCode","_","checksum","filename","basename","trim","async","downloadNodeLib","deref","installVersionPath","writeFile","downloadShasums","JSON","stringify","k","shasumsPath","shasumsUrl","chunks","push","lines","Buffer","concat","toString","split","forEach","line","items","replace","dir32","dir64","libPath32","libPath64","libUrl32","libUrl64","ws","createWriteStream","file","extname","noretry","indexOf","tmpdir","user","cwd","todo","args","url","http","requestOpts","uri","headers","cafile","ca","proxyUrl","proxy","http_proxy","HTTP_PROXY","npm_config_proxy","readFileSync","re","match"],"sources":["/Users/lieo/diabetes/CUT2DMTest/node_modules/node-gyp/lib/install.js"],"sourcesContent":["module.exports = exports = function (gyp, argv, callback) {\n  return install(fs, gyp, argv, callback)\n}\n\nmodule.exports.test = {\n  download: download,\n  install: install,\n  readCAFile: readCAFile,\n}\n\nexports.usage = 'Install node development files for the specified node version.'\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('graceful-fs')\n  , osenv = require('osenv')\n  , tar = require('tar')\n  , rm = require('rimraf')\n  , path = require('path')\n  , crypto = require('crypto')\n  , zlib = require('zlib')\n  , log = require('npmlog')\n  , semver = require('semver')\n  , fstream = require('fstream')\n  , request = require('request')\n  , mkdir = require('mkdirp')\n  , processRelease = require('./process-release')\n  , win = process.platform == 'win32'\n\nfunction install (fs, gyp, argv, callback) {\n\n  var release = processRelease(argv, gyp, process.version, process.release)\n\n  // ensure no double-callbacks happen\n  function cb (err) {\n    if (cb.done) return\n    cb.done = true\n    if (err) {\n      log.warn('install', 'got an error, rolling back install')\n      // roll-back the install if anything went wrong\n      gyp.commands.remove([ release.versionDir ], function (err2) {\n        callback(err)\n      })\n    } else {\n      callback(null, release.version)\n    }\n  }\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version)\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    return callback(new Error('Invalid version number: ' + release.version))\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    return callback(new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version))\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version)\n    if (gyp.opts.nodedir) {\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\n      callback()\n    } else {\n      callback(new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead'))\n    }\n    return\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir)\n\n  // the directory where the dev files will be installed\n  var devDir = path.resolve(gyp.devDir, release.versionDir)\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\n    fs.stat(devDir, function (err, stat) {\n      if (err) {\n        if (err.code == 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version)\n          go()\n        } else if (err.code == 'EACCES') {\n          eaccesFallback(err)\n        } else {\n          cb(err)\n        }\n        return\n      }\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"')\n      var installVersionFile = path.resolve(devDir, 'installVersion')\n      fs.readFile(installVersionFile, 'ascii', function (err, ver) {\n        if (err && err.code != 'ENOENT') {\n          return cb(err)\n        }\n        var installVersion = parseInt(ver, 10) || 0\n        log.verbose('got \"installVersion\"', installVersion)\n        log.verbose('needs \"installVersion\"', gyp.package.installVersion)\n        if (installVersion < gyp.package.installVersion) {\n          log.verbose('install', 'version is no good; reinstalling')\n          go()\n        } else {\n          log.verbose('install', 'version is good')\n          cb()\n        }\n      })\n    })\n  } else {\n    go()\n  }\n\n  function getContentSha(res, callback) {\n    var shasum = crypto.createHash('sha256')\n    res.on('data', function (chunk) {\n      shasum.update(chunk)\n    }).on('end', function () {\n      callback(null, shasum.digest('hex'))\n    })\n  }\n\n  function go () {\n\n    log.verbose('ensuring nodedir is created', devDir)\n\n    // first create the dir for the node dev files\n    mkdir(devDir, function (err, created) {\n      if (err) {\n        if (err.code == 'EACCES') {\n          eaccesFallback(err)\n        } else {\n          cb(err)\n        }\n        return\n      }\n\n      if (created) {\n        log.verbose('created nodedir', created)\n      }\n\n      // now download the node tarball\n      var tarPath = gyp.opts.tarball\n      var badDownload = false\n        , extractCount = 0\n        , gunzip = zlib.createGunzip()\n        , extracter = tar.Extract({ path: devDir, strip: 1, filter: isValid })\n\n      var contentShasums = {}\n      var expectShasums = {}\n\n      // checks if a file to be extracted from the tarball is valid.\n      // only .h header files and the gyp files get extracted\n      function isValid () {\n        var name = this.path.substring(devDir.length + 1)\n        var isValid = valid(name)\n        if (name === '' && this.type === 'Directory') {\n          // the first directory entry is ok\n          return true\n        }\n        if (isValid) {\n          log.verbose('extracted file from tarball', name)\n          extractCount++\n        } else {\n          // invalid\n          log.silly('ignoring from tarball', name)\n        }\n        return isValid\n      }\n\n      gunzip.on('error', cb)\n      extracter.on('error', cb)\n      extracter.on('end', afterTarball)\n\n      // download the tarball, gunzip and extract!\n\n      if (tarPath) {\n        var input = fs.createReadStream(tarPath)\n        input.pipe(gunzip).pipe(extracter)\n        return\n      }\n\n      try {\n        var req = download(gyp, process.env, release.tarballUrl)\n      } catch (e) {\n        return cb(e)\n      }\n\n      // something went wrong downloading the tarball?\n      req.on('error', function (err) {\n        if (err.code === 'ENOTFOUND') {\n          return cb(new Error('This is most likely not a problem with node-gyp or the package itself and\\n' +\n            'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\n            'network settings.'))\n        }\n        badDownload = true\n        cb(err)\n      })\n\n      req.on('close', function () {\n        if (extractCount === 0) {\n          cb(new Error('Connection closed while downloading tarball file'))\n        }\n      })\n\n      req.on('response', function (res) {\n        if (res.statusCode !== 200) {\n          badDownload = true\n          cb(new Error(res.statusCode + ' response downloading ' + release.tarballUrl))\n          return\n        }\n        // content checksum\n        getContentSha(res, function (_, checksum) {\n          var filename = path.basename(release.tarballUrl).trim()\n          contentShasums[filename] = checksum\n          log.verbose('content checksum', filename, checksum)\n        })\n\n        // start unzipping and untaring\n        req.pipe(gunzip).pipe(extracter)\n      })\n\n      // invoked after the tarball has finished being extracted\n      function afterTarball () {\n        if (badDownload) return\n        if (extractCount === 0) {\n          return cb(new Error('There was a fatal problem while downloading/extracting the tarball'))\n        }\n        log.verbose('tarball', 'done parsing tarball')\n        var async = 0\n\n        if (win) {\n          // need to download node.lib\n          async++\n          downloadNodeLib(deref)\n        }\n\n        // write the \"installVersion\" file\n        async++\n        var installVersionPath = path.resolve(devDir, 'installVersion')\n        fs.writeFile(installVersionPath, gyp.package.installVersion + '\\n', deref)\n\n        // Only download SHASUMS.txt if not using tarPath override\n        if (!tarPath) {\n          // download SHASUMS.txt\n          async++\n          downloadShasums(deref)\n        }\n\n        if (async === 0) {\n          // no async tasks required\n          cb()\n        }\n\n        function deref (err) {\n          if (err) return cb(err)\n\n          async--\n          if (!async) {\n            log.verbose('download contents checksum', JSON.stringify(contentShasums))\n            // check content shasums\n            for (var k in contentShasums) {\n              log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\n              if (contentShasums[k] !== expectShasums[k]) {\n                cb(new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]))\n                return\n              }\n            }\n            cb()\n          }\n        }\n      }\n\n      function downloadShasums(done) {\n        log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\n        var shasumsPath = path.resolve(devDir, 'SHASUMS256.txt')\n\n        log.verbose('checksum url', release.shasumsUrl)\n        try {\n          var req = download(gyp, process.env, release.shasumsUrl)\n        } catch (e) {\n          return cb(e)\n        }\n\n        req.on('error', done)\n        req.on('response', function (res) {\n          if (res.statusCode !== 200) {\n            done(new Error(res.statusCode + ' status code downloading checksum'))\n            return\n          }\n\n          var chunks = []\n          res.on('data', function (chunk) {\n            chunks.push(chunk)\n          })\n          res.on('end', function () {\n            var lines = Buffer.concat(chunks).toString().trim().split('\\n')\n            lines.forEach(function (line) {\n              var items = line.trim().split(/\\s+/)\n              if (items.length !== 2) return\n\n              // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n              var name = items[1].replace(/^\\.\\//, '')\n              expectShasums[name] = items[0]\n            })\n\n            log.verbose('checksum data', JSON.stringify(expectShasums))\n            done()\n          })\n        })\n      }\n\n      function downloadNodeLib (done) {\n        log.verbose('on Windows; need to download `' + release.name + '.lib`...')\n        var dir32 = path.resolve(devDir, 'ia32')\n          , dir64 = path.resolve(devDir, 'x64')\n          , libPath32 = path.resolve(dir32, release.name + '.lib')\n          , libPath64 = path.resolve(dir64, release.name + '.lib')\n\n        log.verbose('32-bit ' + release.name + '.lib dir', dir32)\n        log.verbose('64-bit ' + release.name + '.lib dir', dir64)\n        log.verbose('`' + release.name + '.lib` 32-bit url', release.libUrl32)\n        log.verbose('`' + release.name + '.lib` 64-bit url', release.libUrl64)\n\n        var async = 2\n        mkdir(dir32, function (err) {\n          if (err) return done(err)\n          log.verbose('streaming 32-bit ' + release.name + '.lib to:', libPath32)\n\n          try {\n            var req = download(gyp, process.env, release.libUrl32, cb)\n          } catch (e) {\n            return cb(e)\n          }\n\n          req.on('error', done)\n          req.on('response', function (res) {\n            if (res.statusCode !== 200) {\n              done(new Error(res.statusCode + ' status code downloading 32-bit ' + release.name + '.lib'))\n              return\n            }\n\n            getContentSha(res, function (_, checksum) {\n              contentShasums[release.libPath32] = checksum\n              log.verbose('content checksum', release.libPath32, checksum)\n            })\n\n            var ws = fs.createWriteStream(libPath32)\n            ws.on('error', cb)\n            req.pipe(ws)\n          })\n          req.on('end', function () {\n            --async || done()\n          })\n        })\n        mkdir(dir64, function (err) {\n          if (err) return done(err)\n          log.verbose('streaming 64-bit ' + release.name + '.lib to:', libPath64)\n\n          try {\n            var req = download(gyp, process.env, release.libUrl64, cb)\n          } catch (e) {\n            return cb(e)\n          }\n\n          req.on('error', done)\n          req.on('response', function (res) {\n            if (res.statusCode !== 200) {\n              done(new Error(res.statusCode + ' status code downloading 64-bit ' + release.name + '.lib'))\n              return\n            }\n\n            getContentSha(res, function (_, checksum) {\n              contentShasums[release.libPath64] = checksum\n              log.verbose('content checksum', release.libPath64, checksum)\n            })\n\n            var ws = fs.createWriteStream(libPath64)\n            ws.on('error', cb)\n            req.pipe(ws)\n          })\n          req.on('end', function () {\n            --async || done()\n          })\n        })\n      } // downloadNodeLib()\n\n    }) // mkdir()\n\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid (file) {\n    // header files\n    var extname = path.extname(file);\n    return extname === '.h' || extname === '.gypi';\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  function eaccesFallback (err) {\n    var noretry = '--node_gyp_internal_noretry'\n    if (-1 !== argv.indexOf(noretry)) return cb(err)\n    var tmpdir = osenv.tmpdir()\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp')\n    log.warn('EACCES', 'user \"%s\" does not have permission to access the dev dir \"%s\"', osenv.user(), devDir)\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\n    if (process.cwd() == tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\n      gyp.todo.push({ name: 'remove', args: argv })\n    }\n    gyp.commands.install([noretry].concat(argv), cb)\n  }\n\n}\n\nfunction download (gyp, env, url) {\n  log.http('GET', url)\n\n  var requestOpts = {\n      uri: url\n    , headers: {\n        'User-Agent': 'node-gyp v' + gyp.version + ' (node ' + process.version + ')'\n      }\n  }\n\n  var cafile = gyp.opts.cafile\n  if (cafile) {\n    requestOpts.ca = readCAFile(cafile)\n  }\n\n  // basic support for a proxy server\n  var proxyUrl = gyp.opts.proxy\n              || env.http_proxy\n              || env.HTTP_PROXY\n              || env.npm_config_proxy\n  if (proxyUrl) {\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl)\n      requestOpts.proxy = proxyUrl\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl)\n    }\n  }\n\n  var req = request(requestOpts)\n  req.on('response', function (res) {\n    log.http(res.statusCode, url)\n  })\n\n  return req\n}\n\nfunction readCAFile (filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  var ca = fs.readFileSync(filename, 'utf8')\n  var re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\n  return ca.match(re)\n}\n"],"mappings":"AAAAA,MAAM,CAACC,OAAO,GAAGA,OAAO,GAAG,iBAAUC,GAAG,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EACxD,OAAOC,OAAO,CAACC,EAAE,EAAEJ,GAAG,EAAEC,IAAI,EAAEC,QAAQ,CAAC;AACzC,CAAC;AAEDJ,MAAM,CAACC,OAAO,CAACM,IAAI,GAAG;EACpBC,QAAQ,EAAEA,QAAQ;EAClBH,OAAO,EAAEA,OAAO;EAChBI,UAAU,EAAEA;AACd,CAAC;AAEDR,OAAO,CAACS,KAAK,GAAG,gEAAgE;;AAEhF;AACA;AACA;;AAEA,IAAIJ,EAAE,GAAGK,OAAO,CAAC,aAAa,CAAC;EAC3BC,KAAK,GAAGD,OAAO,CAAC,OAAO,CAAC;EACxBE,GAAG,GAAGF,OAAO,CAAC,KAAK,CAAC;EACpBG,EAAE,GAAGH,OAAO,CAAC,QAAQ,CAAC;EACtBI,IAAI,GAAGJ,OAAO,CAAC,MAAM,CAAC;EACtBK,MAAM,GAAGL,OAAO,CAAC,QAAQ,CAAC;EAC1BM,IAAI,GAAGN,OAAO,CAAC,MAAM,CAAC;EACtBO,GAAG,GAAGP,OAAO,CAAC,QAAQ,CAAC;EACvBQ,MAAM,GAAGR,OAAO,CAAC,QAAQ,CAAC;EAC1BS,OAAO,GAAGT,OAAO,CAAC,SAAS,CAAC;EAC5BU,OAAO,GAAGV,OAAO,CAAC,SAAS,CAAC;EAC5BW,KAAK,GAAGX,OAAO,CAAC,QAAQ,CAAC;EACzBY,cAAc,GAAGZ,OAAO,CAAC,mBAAmB,CAAC;EAC7Ca,GAAG,GAAGC,OAAO,CAACC,QAAQ,IAAI,OAAO;AAErC,SAASrB,OAAO,CAAEC,EAAE,EAAEJ,GAAG,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EAEzC,IAAIuB,OAAO,GAAGJ,cAAc,CAACpB,IAAI,EAAED,GAAG,EAAEuB,OAAO,CAACG,OAAO,EAAEH,OAAO,CAACE,OAAO,CAAC;;EAEzE;EACA,SAASE,EAAE,CAAEC,GAAG,EAAE;IAChB,IAAID,EAAE,CAACE,IAAI,EAAE;IACbF,EAAE,CAACE,IAAI,GAAG,IAAI;IACd,IAAID,GAAG,EAAE;MACPZ,GAAG,CAACc,IAAI,CAAC,SAAS,EAAE,oCAAoC,CAAC;MACzD;MACA9B,GAAG,CAAC+B,QAAQ,CAACC,MAAM,CAAC,CAAEP,OAAO,CAACQ,UAAU,CAAE,EAAE,UAAUC,IAAI,EAAE;QAC1DhC,QAAQ,CAAC0B,GAAG,CAAC;MACf,CAAC,CAAC;IACJ,CAAC,MAAM;MACL1B,QAAQ,CAAC,IAAI,EAAEuB,OAAO,CAACC,OAAO,CAAC;IACjC;EACF;;EAEA;EACAV,GAAG,CAACmB,OAAO,CAAC,SAAS,EAAE,yBAAyB,EAAEV,OAAO,CAACC,OAAO,CAAC;EAElE,IAAI,CAACD,OAAO,CAACR,MAAM,EAAE;IACnB;IACA,OAAOf,QAAQ,CAAC,IAAIkC,KAAK,CAAC,0BAA0B,GAAGX,OAAO,CAACC,OAAO,CAAC,CAAC;EAC1E;EAEA,IAAIT,MAAM,CAACoB,EAAE,CAACZ,OAAO,CAACC,OAAO,EAAE,OAAO,CAAC,EAAE;IACvC,OAAOxB,QAAQ,CAAC,IAAIkC,KAAK,CAAC,qDAAqD,GAAGX,OAAO,CAACC,OAAO,CAAC,CAAC;EACrG;;EAEA;EACA,IAAID,OAAO,CAACR,MAAM,CAACqB,UAAU,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;IAC1CtB,GAAG,CAACmB,OAAO,CAAC,6BAA6B,EAAEV,OAAO,CAACC,OAAO,CAAC;IAC3D,IAAI1B,GAAG,CAACuC,IAAI,CAACC,OAAO,EAAE;MACpBxB,GAAG,CAACmB,OAAO,CAAC,6CAA6C,EAAEnC,GAAG,CAACuC,IAAI,CAACC,OAAO,CAAC;MAC5EtC,QAAQ,EAAE;IACZ,CAAC,MAAM;MACLA,QAAQ,CAAC,IAAIkC,KAAK,CAAC,4EAA4E,CAAC,CAAC;IACnG;IACA;EACF;;EAEA;EACApB,GAAG,CAACmB,OAAO,CAAC,SAAS,EAAE,wBAAwB,EAAEV,OAAO,CAACQ,UAAU,CAAC;;EAEpE;EACA,IAAIQ,MAAM,GAAG5B,IAAI,CAAC6B,OAAO,CAAC1C,GAAG,CAACyC,MAAM,EAAEhB,OAAO,CAACQ,UAAU,CAAC;;EAEzD;EACA;EACA,IAAIjC,GAAG,CAACuC,IAAI,CAACI,MAAM,EAAE;IACnB3B,GAAG,CAACmB,OAAO,CAAC,SAAS,EAAE,+DAA+D,CAAC;IACvF/B,EAAE,CAACwC,IAAI,CAACH,MAAM,EAAE,UAAUb,GAAG,EAAEgB,IAAI,EAAE;MACnC,IAAIhB,GAAG,EAAE;QACP,IAAIA,GAAG,CAACiB,IAAI,IAAI,QAAQ,EAAE;UACxB7B,GAAG,CAACmB,OAAO,CAAC,SAAS,EAAE,wDAAwD,EAAEV,OAAO,CAACC,OAAO,CAAC;UACjGoB,EAAE,EAAE;QACN,CAAC,MAAM,IAAIlB,GAAG,CAACiB,IAAI,IAAI,QAAQ,EAAE;UAC/BE,cAAc,CAACnB,GAAG,CAAC;QACrB,CAAC,MAAM;UACLD,EAAE,CAACC,GAAG,CAAC;QACT;QACA;MACF;MACAZ,GAAG,CAACmB,OAAO,CAAC,SAAS,EAAE,8DAA8D,CAAC;MACtF,IAAIa,kBAAkB,GAAGnC,IAAI,CAAC6B,OAAO,CAACD,MAAM,EAAE,gBAAgB,CAAC;MAC/DrC,EAAE,CAAC6C,QAAQ,CAACD,kBAAkB,EAAE,OAAO,EAAE,UAAUpB,GAAG,EAAEsB,GAAG,EAAE;QAC3D,IAAItB,GAAG,IAAIA,GAAG,CAACiB,IAAI,IAAI,QAAQ,EAAE;UAC/B,OAAOlB,EAAE,CAACC,GAAG,CAAC;QAChB;QACA,IAAIuB,cAAc,GAAGC,QAAQ,CAACF,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC;QAC3ClC,GAAG,CAACmB,OAAO,CAAC,sBAAsB,EAAEgB,cAAc,CAAC;QACnDnC,GAAG,CAACmB,OAAO,CAAC,wBAAwB,EAAEnC,GAAG,CAACqD,OAAO,CAACF,cAAc,CAAC;QACjE,IAAIA,cAAc,GAAGnD,GAAG,CAACqD,OAAO,CAACF,cAAc,EAAE;UAC/CnC,GAAG,CAACmB,OAAO,CAAC,SAAS,EAAE,kCAAkC,CAAC;UAC1DW,EAAE,EAAE;QACN,CAAC,MAAM;UACL9B,GAAG,CAACmB,OAAO,CAAC,SAAS,EAAE,iBAAiB,CAAC;UACzCR,EAAE,EAAE;QACN;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,MAAM;IACLmB,EAAE,EAAE;EACN;EAEA,SAASQ,aAAa,CAACC,GAAG,EAAErD,QAAQ,EAAE;IACpC,IAAIsD,MAAM,GAAG1C,MAAM,CAAC2C,UAAU,CAAC,QAAQ,CAAC;IACxCF,GAAG,CAACG,EAAE,CAAC,MAAM,EAAE,UAAUC,KAAK,EAAE;MAC9BH,MAAM,CAACI,MAAM,CAACD,KAAK,CAAC;IACtB,CAAC,CAAC,CAACD,EAAE,CAAC,KAAK,EAAE,YAAY;MACvBxD,QAAQ,CAAC,IAAI,EAAEsD,MAAM,CAACK,MAAM,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC,CAAC;EACJ;EAEA,SAASf,EAAE,GAAI;IAEb9B,GAAG,CAACmB,OAAO,CAAC,6BAA6B,EAAEM,MAAM,CAAC;;IAElD;IACArB,KAAK,CAACqB,MAAM,EAAE,UAAUb,GAAG,EAAEkC,OAAO,EAAE;MACpC,IAAIlC,GAAG,EAAE;QACP,IAAIA,GAAG,CAACiB,IAAI,IAAI,QAAQ,EAAE;UACxBE,cAAc,CAACnB,GAAG,CAAC;QACrB,CAAC,MAAM;UACLD,EAAE,CAACC,GAAG,CAAC;QACT;QACA;MACF;MAEA,IAAIkC,OAAO,EAAE;QACX9C,GAAG,CAACmB,OAAO,CAAC,iBAAiB,EAAE2B,OAAO,CAAC;MACzC;;MAEA;MACA,IAAIC,OAAO,GAAG/D,GAAG,CAACuC,IAAI,CAACyB,OAAO;MAC9B,IAAIC,WAAW,GAAG,KAAK;QACnBC,YAAY,GAAG,CAAC;QAChBC,MAAM,GAAGpD,IAAI,CAACqD,YAAY,EAAE;QAC5BC,SAAS,GAAG1D,GAAG,CAAC2D,OAAO,CAAC;UAAEzD,IAAI,EAAE4B,MAAM;UAAE8B,KAAK,EAAE,CAAC;UAAEC,MAAM,EAAEC;QAAQ,CAAC,CAAC;MAExE,IAAIC,cAAc,GAAG,CAAC,CAAC;MACvB,IAAIC,aAAa,GAAG,CAAC,CAAC;;MAEtB;MACA;MACA,SAASF,OAAO,GAAI;QAClB,IAAIG,IAAI,GAAG,IAAI,CAAC/D,IAAI,CAACgE,SAAS,CAACpC,MAAM,CAACqC,MAAM,GAAG,CAAC,CAAC;QACjD,IAAIL,OAAO,GAAGM,KAAK,CAACH,IAAI,CAAC;QACzB,IAAIA,IAAI,KAAK,EAAE,IAAI,IAAI,CAACI,IAAI,KAAK,WAAW,EAAE;UAC5C;UACA,OAAO,IAAI;QACb;QACA,IAAIP,OAAO,EAAE;UACXzD,GAAG,CAACmB,OAAO,CAAC,6BAA6B,EAAEyC,IAAI,CAAC;UAChDV,YAAY,EAAE;QAChB,CAAC,MAAM;UACL;UACAlD,GAAG,CAACiE,KAAK,CAAC,uBAAuB,EAAEL,IAAI,CAAC;QAC1C;QACA,OAAOH,OAAO;MAChB;MAEAN,MAAM,CAACT,EAAE,CAAC,OAAO,EAAE/B,EAAE,CAAC;MACtB0C,SAAS,CAACX,EAAE,CAAC,OAAO,EAAE/B,EAAE,CAAC;MACzB0C,SAAS,CAACX,EAAE,CAAC,KAAK,EAAEwB,YAAY,CAAC;;MAEjC;;MAEA,IAAInB,OAAO,EAAE;QACX,IAAIoB,KAAK,GAAG/E,EAAE,CAACgF,gBAAgB,CAACrB,OAAO,CAAC;QACxCoB,KAAK,CAACE,IAAI,CAAClB,MAAM,CAAC,CAACkB,IAAI,CAAChB,SAAS,CAAC;QAClC;MACF;MAEA,IAAI;QACF,IAAIiB,GAAG,GAAGhF,QAAQ,CAACN,GAAG,EAAEuB,OAAO,CAACgE,GAAG,EAAE9D,OAAO,CAAC+D,UAAU,CAAC;MAC1D,CAAC,CAAC,OAAOC,CAAC,EAAE;QACV,OAAO9D,EAAE,CAAC8D,CAAC,CAAC;MACd;;MAEA;MACAH,GAAG,CAAC5B,EAAE,CAAC,OAAO,EAAE,UAAU9B,GAAG,EAAE;QAC7B,IAAIA,GAAG,CAACiB,IAAI,KAAK,WAAW,EAAE;UAC5B,OAAOlB,EAAE,CAAC,IAAIS,KAAK,CAAC,6EAA6E,GAC/F,yFAAyF,GACzF,mBAAmB,CAAC,CAAC;QACzB;QACA6B,WAAW,GAAG,IAAI;QAClBtC,EAAE,CAACC,GAAG,CAAC;MACT,CAAC,CAAC;MAEF0D,GAAG,CAAC5B,EAAE,CAAC,OAAO,EAAE,YAAY;QAC1B,IAAIQ,YAAY,KAAK,CAAC,EAAE;UACtBvC,EAAE,CAAC,IAAIS,KAAK,CAAC,kDAAkD,CAAC,CAAC;QACnE;MACF,CAAC,CAAC;MAEFkD,GAAG,CAAC5B,EAAE,CAAC,UAAU,EAAE,UAAUH,GAAG,EAAE;QAChC,IAAIA,GAAG,CAACmC,UAAU,KAAK,GAAG,EAAE;UAC1BzB,WAAW,GAAG,IAAI;UAClBtC,EAAE,CAAC,IAAIS,KAAK,CAACmB,GAAG,CAACmC,UAAU,GAAG,wBAAwB,GAAGjE,OAAO,CAAC+D,UAAU,CAAC,CAAC;UAC7E;QACF;QACA;QACAlC,aAAa,CAACC,GAAG,EAAE,UAAUoC,CAAC,EAAEC,QAAQ,EAAE;UACxC,IAAIC,QAAQ,GAAGhF,IAAI,CAACiF,QAAQ,CAACrE,OAAO,CAAC+D,UAAU,CAAC,CAACO,IAAI,EAAE;UACvDrB,cAAc,CAACmB,QAAQ,CAAC,GAAGD,QAAQ;UACnC5E,GAAG,CAACmB,OAAO,CAAC,kBAAkB,EAAE0D,QAAQ,EAAED,QAAQ,CAAC;QACrD,CAAC,CAAC;;QAEF;QACAN,GAAG,CAACD,IAAI,CAAClB,MAAM,CAAC,CAACkB,IAAI,CAAChB,SAAS,CAAC;MAClC,CAAC,CAAC;;MAEF;MACA,SAASa,YAAY,GAAI;QACvB,IAAIjB,WAAW,EAAE;QACjB,IAAIC,YAAY,KAAK,CAAC,EAAE;UACtB,OAAOvC,EAAE,CAAC,IAAIS,KAAK,CAAC,oEAAoE,CAAC,CAAC;QAC5F;QACApB,GAAG,CAACmB,OAAO,CAAC,SAAS,EAAE,sBAAsB,CAAC;QAC9C,IAAI6D,KAAK,GAAG,CAAC;QAEb,IAAI1E,GAAG,EAAE;UACP;UACA0E,KAAK,EAAE;UACPC,eAAe,CAACC,KAAK,CAAC;QACxB;;QAEA;QACAF,KAAK,EAAE;QACP,IAAIG,kBAAkB,GAAGtF,IAAI,CAAC6B,OAAO,CAACD,MAAM,EAAE,gBAAgB,CAAC;QAC/DrC,EAAE,CAACgG,SAAS,CAACD,kBAAkB,EAAEnG,GAAG,CAACqD,OAAO,CAACF,cAAc,GAAG,IAAI,EAAE+C,KAAK,CAAC;;QAE1E;QACA,IAAI,CAACnC,OAAO,EAAE;UACZ;UACAiC,KAAK,EAAE;UACPK,eAAe,CAACH,KAAK,CAAC;QACxB;QAEA,IAAIF,KAAK,KAAK,CAAC,EAAE;UACf;UACArE,EAAE,EAAE;QACN;QAEA,SAASuE,KAAK,CAAEtE,GAAG,EAAE;UACnB,IAAIA,GAAG,EAAE,OAAOD,EAAE,CAACC,GAAG,CAAC;UAEvBoE,KAAK,EAAE;UACP,IAAI,CAACA,KAAK,EAAE;YACVhF,GAAG,CAACmB,OAAO,CAAC,4BAA4B,EAAEmE,IAAI,CAACC,SAAS,CAAC7B,cAAc,CAAC,CAAC;YACzE;YACA,KAAK,IAAI8B,CAAC,IAAI9B,cAAc,EAAE;cAC5B1D,GAAG,CAACmB,OAAO,CAAC,mCAAmC,GAAGqE,CAAC,EAAE,YAAY,EAAE9B,cAAc,CAAC8B,CAAC,CAAC,EAAE7B,aAAa,CAAC6B,CAAC,CAAC,CAAC;cACvG,IAAI9B,cAAc,CAAC8B,CAAC,CAAC,KAAK7B,aAAa,CAAC6B,CAAC,CAAC,EAAE;gBAC1C7E,EAAE,CAAC,IAAIS,KAAK,CAACoE,CAAC,GAAG,kBAAkB,GAAG9B,cAAc,CAAC8B,CAAC,CAAC,GAAG,oBAAoB,GAAG7B,aAAa,CAAC6B,CAAC,CAAC,CAAC,CAAC;gBACnG;cACF;YACF;YACA7E,EAAE,EAAE;UACN;QACF;MACF;MAEA,SAAS0E,eAAe,CAACxE,IAAI,EAAE;QAC7Bb,GAAG,CAACmB,OAAO,CAAC,uEAAuE,CAAC;QACpF,IAAIsE,WAAW,GAAG5F,IAAI,CAAC6B,OAAO,CAACD,MAAM,EAAE,gBAAgB,CAAC;QAExDzB,GAAG,CAACmB,OAAO,CAAC,cAAc,EAAEV,OAAO,CAACiF,UAAU,CAAC;QAC/C,IAAI;UACF,IAAIpB,GAAG,GAAGhF,QAAQ,CAACN,GAAG,EAAEuB,OAAO,CAACgE,GAAG,EAAE9D,OAAO,CAACiF,UAAU,CAAC;QAC1D,CAAC,CAAC,OAAOjB,CAAC,EAAE;UACV,OAAO9D,EAAE,CAAC8D,CAAC,CAAC;QACd;QAEAH,GAAG,CAAC5B,EAAE,CAAC,OAAO,EAAE7B,IAAI,CAAC;QACrByD,GAAG,CAAC5B,EAAE,CAAC,UAAU,EAAE,UAAUH,GAAG,EAAE;UAChC,IAAIA,GAAG,CAACmC,UAAU,KAAK,GAAG,EAAE;YAC1B7D,IAAI,CAAC,IAAIO,KAAK,CAACmB,GAAG,CAACmC,UAAU,GAAG,mCAAmC,CAAC,CAAC;YACrE;UACF;UAEA,IAAIiB,MAAM,GAAG,EAAE;UACfpD,GAAG,CAACG,EAAE,CAAC,MAAM,EAAE,UAAUC,KAAK,EAAE;YAC9BgD,MAAM,CAACC,IAAI,CAACjD,KAAK,CAAC;UACpB,CAAC,CAAC;UACFJ,GAAG,CAACG,EAAE,CAAC,KAAK,EAAE,YAAY;YACxB,IAAImD,KAAK,GAAGC,MAAM,CAACC,MAAM,CAACJ,MAAM,CAAC,CAACK,QAAQ,EAAE,CAACjB,IAAI,EAAE,CAACkB,KAAK,CAAC,IAAI,CAAC;YAC/DJ,KAAK,CAACK,OAAO,CAAC,UAAUC,IAAI,EAAE;cAC5B,IAAIC,KAAK,GAAGD,IAAI,CAACpB,IAAI,EAAE,CAACkB,KAAK,CAAC,KAAK,CAAC;cACpC,IAAIG,KAAK,CAACtC,MAAM,KAAK,CAAC,EAAE;;cAExB;cACA,IAAIF,IAAI,GAAGwC,KAAK,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;cACxC1C,aAAa,CAACC,IAAI,CAAC,GAAGwC,KAAK,CAAC,CAAC,CAAC;YAChC,CAAC,CAAC;YAEFpG,GAAG,CAACmB,OAAO,CAAC,eAAe,EAAEmE,IAAI,CAACC,SAAS,CAAC5B,aAAa,CAAC,CAAC;YAC3D9C,IAAI,EAAE;UACR,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ;MAEA,SAASoE,eAAe,CAAEpE,IAAI,EAAE;QAC9Bb,GAAG,CAACmB,OAAO,CAAC,gCAAgC,GAAGV,OAAO,CAACmD,IAAI,GAAG,UAAU,CAAC;QACzE,IAAI0C,KAAK,GAAGzG,IAAI,CAAC6B,OAAO,CAACD,MAAM,EAAE,MAAM,CAAC;UACpC8E,KAAK,GAAG1G,IAAI,CAAC6B,OAAO,CAACD,MAAM,EAAE,KAAK,CAAC;UACnC+E,SAAS,GAAG3G,IAAI,CAAC6B,OAAO,CAAC4E,KAAK,EAAE7F,OAAO,CAACmD,IAAI,GAAG,MAAM,CAAC;UACtD6C,SAAS,GAAG5G,IAAI,CAAC6B,OAAO,CAAC6E,KAAK,EAAE9F,OAAO,CAACmD,IAAI,GAAG,MAAM,CAAC;QAE1D5D,GAAG,CAACmB,OAAO,CAAC,SAAS,GAAGV,OAAO,CAACmD,IAAI,GAAG,UAAU,EAAE0C,KAAK,CAAC;QACzDtG,GAAG,CAACmB,OAAO,CAAC,SAAS,GAAGV,OAAO,CAACmD,IAAI,GAAG,UAAU,EAAE2C,KAAK,CAAC;QACzDvG,GAAG,CAACmB,OAAO,CAAC,GAAG,GAAGV,OAAO,CAACmD,IAAI,GAAG,kBAAkB,EAAEnD,OAAO,CAACiG,QAAQ,CAAC;QACtE1G,GAAG,CAACmB,OAAO,CAAC,GAAG,GAAGV,OAAO,CAACmD,IAAI,GAAG,kBAAkB,EAAEnD,OAAO,CAACkG,QAAQ,CAAC;QAEtE,IAAI3B,KAAK,GAAG,CAAC;QACb5E,KAAK,CAACkG,KAAK,EAAE,UAAU1F,GAAG,EAAE;UAC1B,IAAIA,GAAG,EAAE,OAAOC,IAAI,CAACD,GAAG,CAAC;UACzBZ,GAAG,CAACmB,OAAO,CAAC,mBAAmB,GAAGV,OAAO,CAACmD,IAAI,GAAG,UAAU,EAAE4C,SAAS,CAAC;UAEvE,IAAI;YACF,IAAIlC,GAAG,GAAGhF,QAAQ,CAACN,GAAG,EAAEuB,OAAO,CAACgE,GAAG,EAAE9D,OAAO,CAACiG,QAAQ,EAAE/F,EAAE,CAAC;UAC5D,CAAC,CAAC,OAAO8D,CAAC,EAAE;YACV,OAAO9D,EAAE,CAAC8D,CAAC,CAAC;UACd;UAEAH,GAAG,CAAC5B,EAAE,CAAC,OAAO,EAAE7B,IAAI,CAAC;UACrByD,GAAG,CAAC5B,EAAE,CAAC,UAAU,EAAE,UAAUH,GAAG,EAAE;YAChC,IAAIA,GAAG,CAACmC,UAAU,KAAK,GAAG,EAAE;cAC1B7D,IAAI,CAAC,IAAIO,KAAK,CAACmB,GAAG,CAACmC,UAAU,GAAG,kCAAkC,GAAGjE,OAAO,CAACmD,IAAI,GAAG,MAAM,CAAC,CAAC;cAC5F;YACF;YAEAtB,aAAa,CAACC,GAAG,EAAE,UAAUoC,CAAC,EAAEC,QAAQ,EAAE;cACxClB,cAAc,CAACjD,OAAO,CAAC+F,SAAS,CAAC,GAAG5B,QAAQ;cAC5C5E,GAAG,CAACmB,OAAO,CAAC,kBAAkB,EAAEV,OAAO,CAAC+F,SAAS,EAAE5B,QAAQ,CAAC;YAC9D,CAAC,CAAC;YAEF,IAAIgC,EAAE,GAAGxH,EAAE,CAACyH,iBAAiB,CAACL,SAAS,CAAC;YACxCI,EAAE,CAAClE,EAAE,CAAC,OAAO,EAAE/B,EAAE,CAAC;YAClB2D,GAAG,CAACD,IAAI,CAACuC,EAAE,CAAC;UACd,CAAC,CAAC;UACFtC,GAAG,CAAC5B,EAAE,CAAC,KAAK,EAAE,YAAY;YACxB,EAAEsC,KAAK,IAAInE,IAAI,EAAE;UACnB,CAAC,CAAC;QACJ,CAAC,CAAC;QACFT,KAAK,CAACmG,KAAK,EAAE,UAAU3F,GAAG,EAAE;UAC1B,IAAIA,GAAG,EAAE,OAAOC,IAAI,CAACD,GAAG,CAAC;UACzBZ,GAAG,CAACmB,OAAO,CAAC,mBAAmB,GAAGV,OAAO,CAACmD,IAAI,GAAG,UAAU,EAAE6C,SAAS,CAAC;UAEvE,IAAI;YACF,IAAInC,GAAG,GAAGhF,QAAQ,CAACN,GAAG,EAAEuB,OAAO,CAACgE,GAAG,EAAE9D,OAAO,CAACkG,QAAQ,EAAEhG,EAAE,CAAC;UAC5D,CAAC,CAAC,OAAO8D,CAAC,EAAE;YACV,OAAO9D,EAAE,CAAC8D,CAAC,CAAC;UACd;UAEAH,GAAG,CAAC5B,EAAE,CAAC,OAAO,EAAE7B,IAAI,CAAC;UACrByD,GAAG,CAAC5B,EAAE,CAAC,UAAU,EAAE,UAAUH,GAAG,EAAE;YAChC,IAAIA,GAAG,CAACmC,UAAU,KAAK,GAAG,EAAE;cAC1B7D,IAAI,CAAC,IAAIO,KAAK,CAACmB,GAAG,CAACmC,UAAU,GAAG,kCAAkC,GAAGjE,OAAO,CAACmD,IAAI,GAAG,MAAM,CAAC,CAAC;cAC5F;YACF;YAEAtB,aAAa,CAACC,GAAG,EAAE,UAAUoC,CAAC,EAAEC,QAAQ,EAAE;cACxClB,cAAc,CAACjD,OAAO,CAACgG,SAAS,CAAC,GAAG7B,QAAQ;cAC5C5E,GAAG,CAACmB,OAAO,CAAC,kBAAkB,EAAEV,OAAO,CAACgG,SAAS,EAAE7B,QAAQ,CAAC;YAC9D,CAAC,CAAC;YAEF,IAAIgC,EAAE,GAAGxH,EAAE,CAACyH,iBAAiB,CAACJ,SAAS,CAAC;YACxCG,EAAE,CAAClE,EAAE,CAAC,OAAO,EAAE/B,EAAE,CAAC;YAClB2D,GAAG,CAACD,IAAI,CAACuC,EAAE,CAAC;UACd,CAAC,CAAC;UACFtC,GAAG,CAAC5B,EAAE,CAAC,KAAK,EAAE,YAAY;YACxB,EAAEsC,KAAK,IAAInE,IAAI,EAAE;UACnB,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ,CAAC,CAAC;IAEJ,CAAC,CAAC,EAAC;EAEL,CAAC,CAAC;;EAEF;AACF;AACA;;EAEE,SAASkD,KAAK,CAAE+C,IAAI,EAAE;IACpB;IACA,IAAIC,OAAO,GAAGlH,IAAI,CAACkH,OAAO,CAACD,IAAI,CAAC;IAChC,OAAOC,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,OAAO;EAChD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE,SAAShF,cAAc,CAAEnB,GAAG,EAAE;IAC5B,IAAIoG,OAAO,GAAG,6BAA6B;IAC3C,IAAI,CAAC,CAAC,KAAK/H,IAAI,CAACgI,OAAO,CAACD,OAAO,CAAC,EAAE,OAAOrG,EAAE,CAACC,GAAG,CAAC;IAChD,IAAIsG,MAAM,GAAGxH,KAAK,CAACwH,MAAM,EAAE;IAC3BlI,GAAG,CAACyC,MAAM,GAAG5B,IAAI,CAAC6B,OAAO,CAACwF,MAAM,EAAE,WAAW,CAAC;IAC9ClH,GAAG,CAACc,IAAI,CAAC,QAAQ,EAAE,+DAA+D,EAAEpB,KAAK,CAACyH,IAAI,EAAE,EAAE1F,MAAM,CAAC;IACzGzB,GAAG,CAACc,IAAI,CAAC,QAAQ,EAAE,sDAAsD,EAAE9B,GAAG,CAACyC,MAAM,CAAC;IACtF,IAAIlB,OAAO,CAAC6G,GAAG,EAAE,IAAIF,MAAM,EAAE;MAC3BlH,GAAG,CAACmB,OAAO,CAAC,eAAe,EAAE,8DAA8D,CAAC;MAC5FnC,GAAG,CAACqI,IAAI,CAACzB,IAAI,CAAC;QAAEhC,IAAI,EAAE,QAAQ;QAAE0D,IAAI,EAAErI;MAAK,CAAC,CAAC;IAC/C;IACAD,GAAG,CAAC+B,QAAQ,CAAC5B,OAAO,CAAC,CAAC6H,OAAO,CAAC,CAACjB,MAAM,CAAC9G,IAAI,CAAC,EAAE0B,EAAE,CAAC;EAClD;AAEF;AAEA,SAASrB,QAAQ,CAAEN,GAAG,EAAEuF,GAAG,EAAEgD,GAAG,EAAE;EAChCvH,GAAG,CAACwH,IAAI,CAAC,KAAK,EAAED,GAAG,CAAC;EAEpB,IAAIE,WAAW,GAAG;IACdC,GAAG,EAAEH,GAAG;IACRI,OAAO,EAAE;MACP,YAAY,EAAE,YAAY,GAAG3I,GAAG,CAAC0B,OAAO,GAAG,SAAS,GAAGH,OAAO,CAACG,OAAO,GAAG;IAC3E;EACJ,CAAC;EAED,IAAIkH,MAAM,GAAG5I,GAAG,CAACuC,IAAI,CAACqG,MAAM;EAC5B,IAAIA,MAAM,EAAE;IACVH,WAAW,CAACI,EAAE,GAAGtI,UAAU,CAACqI,MAAM,CAAC;EACrC;;EAEA;EACA,IAAIE,QAAQ,GAAG9I,GAAG,CAACuC,IAAI,CAACwG,KAAK,IACdxD,GAAG,CAACyD,UAAU,IACdzD,GAAG,CAAC0D,UAAU,IACd1D,GAAG,CAAC2D,gBAAgB;EACnC,IAAIJ,QAAQ,EAAE;IACZ,IAAI,eAAe,CAACzI,IAAI,CAACyI,QAAQ,CAAC,EAAE;MAClC9H,GAAG,CAACmB,OAAO,CAAC,UAAU,EAAE,uBAAuB,EAAE2G,QAAQ,CAAC;MAC1DL,WAAW,CAACM,KAAK,GAAGD,QAAQ;IAC9B,CAAC,MAAM;MACL9H,GAAG,CAACc,IAAI,CAAC,UAAU,EAAE,+CAA+C,EAAEgH,QAAQ,CAAC;IACjF;EACF;EAEA,IAAIxD,GAAG,GAAGnE,OAAO,CAACsH,WAAW,CAAC;EAC9BnD,GAAG,CAAC5B,EAAE,CAAC,UAAU,EAAE,UAAUH,GAAG,EAAE;IAChCvC,GAAG,CAACwH,IAAI,CAACjF,GAAG,CAACmC,UAAU,EAAE6C,GAAG,CAAC;EAC/B,CAAC,CAAC;EAEF,OAAOjD,GAAG;AACZ;AAEA,SAAS/E,UAAU,CAAEsF,QAAQ,EAAE;EAC7B;EACA;EACA,IAAIgD,EAAE,GAAGzI,EAAE,CAAC+I,YAAY,CAACtD,QAAQ,EAAE,MAAM,CAAC;EAC1C,IAAIuD,EAAE,GAAG,iEAAiE;EAC1E,OAAOP,EAAE,CAACQ,KAAK,CAACD,EAAE,CAAC;AACrB"},"metadata":{},"sourceType":"script"}