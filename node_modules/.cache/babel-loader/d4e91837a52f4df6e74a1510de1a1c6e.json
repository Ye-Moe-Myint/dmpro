{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _objectSpread = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _slicedToArray = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar debug = require('debug')('nock.recorder');\nvar querystring = require('querystring');\nvar _require = require('util'),\n  inspect = _require.inspect;\nvar common = require('./common');\nvar _require2 = require('./intercept'),\n  restoreOverriddenClientRequest = _require2.restoreOverriddenClientRequest;\nvar SEPARATOR = '\\n<<<<<<-- cut here -->>>>>>\\n';\nvar recordingInProgress = false;\nvar _outputs = [];\nfunction getScope(options) {\n  var _common$normalizeRequ = common.normalizeRequestOptions(options),\n    proto = _common$normalizeRequ.proto,\n    host = _common$normalizeRequ.host,\n    port = _common$normalizeRequ.port;\n  return common.normalizeOrigin(proto, host, port);\n}\nfunction getMethod(options) {\n  return options.method || 'GET';\n}\nfunction getBodyFromChunks(chunks, headers) {\n  // If we have headers and there is content-encoding it means that the body\n  // shouldn't be merged but instead persisted as an array of hex strings so\n  // that the response chunks can be mocked one by one.\n  if (headers && common.isContentEncoded(headers)) {\n    return {\n      body: chunks.map(function (chunk) {\n        return chunk.toString('hex');\n      })\n    };\n  }\n  var mergedBuffer = Buffer.concat(chunks);\n\n  // The merged buffer can be one of three things:\n  // 1. A UTF-8-representable string buffer which represents a JSON object.\n  // 2. A UTF-8-representable buffer which doesn't represent a JSON object.\n  // 3. A non-UTF-8-representable buffer which then has to be recorded as a hex string.\n  var isUtf8Representable = common.isUtf8Representable(mergedBuffer);\n  if (isUtf8Representable) {\n    var maybeStringifiedJson = mergedBuffer.toString('utf8');\n    try {\n      return {\n        isUtf8Representable: isUtf8Representable,\n        body: JSON.parse(maybeStringifiedJson)\n      };\n    } catch (err) {\n      return {\n        isUtf8Representable: isUtf8Representable,\n        body: maybeStringifiedJson\n      };\n    }\n  } else {\n    return {\n      isUtf8Representable: isUtf8Representable,\n      body: mergedBuffer.toString('hex')\n    };\n  }\n}\nfunction generateRequestAndResponseObject(_ref) {\n  var req = _ref.req,\n    bodyChunks = _ref.bodyChunks,\n    options = _ref.options,\n    res = _ref.res,\n    dataChunks = _ref.dataChunks,\n    reqheaders = _ref.reqheaders;\n  var _getBodyFromChunks = getBodyFromChunks(dataChunks, res.headers),\n    body = _getBodyFromChunks.body,\n    isUtf8Representable = _getBodyFromChunks.isUtf8Representable;\n  options.path = req.path;\n  return {\n    scope: getScope(options),\n    method: getMethod(options),\n    path: options.path,\n    // Is it deliberate that `getBodyFromChunks()` is called a second time?\n    body: getBodyFromChunks(bodyChunks).body,\n    status: res.statusCode,\n    response: body,\n    rawHeaders: res.rawHeaders,\n    reqheaders: reqheaders || undefined,\n    // When content-encoding is enabled, isUtf8Representable is `undefined`,\n    // so we explicitly check for `false`.\n    responseIsBinary: isUtf8Representable === false\n  };\n}\nfunction generateRequestAndResponse(_ref2) {\n  var req = _ref2.req,\n    bodyChunks = _ref2.bodyChunks,\n    options = _ref2.options,\n    res = _ref2.res,\n    dataChunks = _ref2.dataChunks,\n    reqheaders = _ref2.reqheaders;\n  var requestBody = getBodyFromChunks(bodyChunks).body;\n  var responseBody = getBodyFromChunks(dataChunks, res.headers).body;\n\n  // Remove any query params from options.path so they can be added in the query() function\n  var path = options.path;\n  var queryIndex = req.path.indexOf('?');\n  var queryObj = {};\n  if (queryIndex !== -1) {\n    // Remove the query from the path\n    path = path.substring(0, queryIndex);\n    var queryStr = req.path.slice(queryIndex + 1);\n    queryObj = querystring.parse(queryStr);\n  }\n\n  // Escape any single quotes in the path as the output uses them\n  path = path.replace(/'/g, \"\\\\'\");\n\n  // Always encode the query parameters when recording.\n  var encodedQueryObj = {};\n  for (var key in queryObj) {\n    var formattedPair = common.formatQueryValue(key, queryObj[key], common.percentEncode);\n    encodedQueryObj[formattedPair[0]] = formattedPair[1];\n  }\n  var lines = [];\n\n  // We want a leading newline.\n  lines.push('');\n  var scope = getScope(options);\n  lines.push(\"nock('\".concat(scope, \"', {\\\"encodedQueryParams\\\":true})\"));\n  var methodName = getMethod(options).toLowerCase();\n  if (requestBody) {\n    lines.push(\"  .\".concat(methodName, \"('\").concat(path, \"', \").concat(JSON.stringify(requestBody), \")\"));\n  } else {\n    lines.push(\"  .\".concat(methodName, \"('\").concat(path, \"')\"));\n  }\n  Object.entries(reqheaders || {}).forEach(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      fieldName = _ref4[0],\n      fieldValue = _ref4[1];\n    var safeName = JSON.stringify(fieldName);\n    var safeValue = JSON.stringify(fieldValue);\n    lines.push(\"  .matchHeader(\".concat(safeName, \", \").concat(safeValue, \")\"));\n  });\n  if (queryIndex !== -1) {\n    lines.push(\"  .query(\".concat(JSON.stringify(encodedQueryObj), \")\"));\n  }\n  var statusCode = res.statusCode.toString();\n  var stringifiedResponseBody = JSON.stringify(responseBody);\n  var headers = inspect(res.rawHeaders);\n  lines.push(\"  .reply(\".concat(statusCode, \", \").concat(stringifiedResponseBody, \", \").concat(headers, \");\"));\n  return lines.join('\\n');\n}\n\n//  This module variable is used to identify a unique recording ID in order to skip\n//  spurious requests that sometimes happen. This problem has been, so far,\n//  exclusively detected in nock's unit testing where 'checks if callback is specified'\n//  interferes with other tests as its t.end() is invoked without waiting for request\n//  to finish (which is the point of the test).\nvar currentRecordingId = 0;\nvar defaultRecordOptions = {\n  dont_print: false,\n  enable_reqheaders_recording: false,\n  logging: console.log,\n  // eslint-disable-line no-console\n  output_objects: false,\n  use_separator: true\n};\nfunction record(recOptions) {\n  //  Trying to start recording with recording already in progress implies an error\n  //  in the recording configuration (double recording makes no sense and used to lead\n  //  to duplicates in output)\n  if (recordingInProgress) {\n    throw new Error('Nock recording already in progress');\n  }\n  recordingInProgress = true;\n\n  // Set the new current recording ID and capture its value in this instance of record().\n  currentRecordingId = currentRecordingId + 1;\n  var thisRecordingId = currentRecordingId;\n\n  // Originally the parameter was a dont_print boolean flag.\n  // To keep the existing code compatible we take that case into account.\n  if (typeof recOptions === 'boolean') {\n    recOptions = {\n      dont_print: recOptions\n    };\n  }\n  recOptions = _objectSpread(_objectSpread({}, defaultRecordOptions), recOptions);\n  debug('start recording', thisRecordingId, recOptions);\n  var _recOptions = recOptions,\n    dontPrint = _recOptions.dont_print,\n    enableReqHeadersRecording = _recOptions.enable_reqheaders_recording,\n    logging = _recOptions.logging,\n    outputObjects = _recOptions.output_objects,\n    useSeparator = _recOptions.use_separator;\n  debug(thisRecordingId, 'restoring overridden requests before new overrides');\n  //  To preserve backward compatibility (starting recording wasn't throwing if nock was already active)\n  //  we restore any requests that may have been overridden by other parts of nock (e.g. intercept)\n  //  NOTE: This is hacky as hell but it keeps the backward compatibility *and* allows correct\n  //    behavior in the face of other modules also overriding ClientRequest.\n  common.restoreOverriddenRequests();\n  //  We restore ClientRequest as it messes with recording of modules that also override ClientRequest (e.g. xhr2)\n  restoreOverriddenClientRequest();\n\n  //  We override the requests so that we can save information on them before executing.\n  common.overrideRequests(function (proto, overriddenRequest, rawArgs) {\n    var _common$normalizeClie = common.normalizeClientRequestArgs.apply(common, _toConsumableArray(rawArgs)),\n      options = _common$normalizeClie.options,\n      callback = _common$normalizeClie.callback;\n    var bodyChunks = [];\n\n    // Node 0.11 https.request calls http.request -- don't want to record things\n    // twice.\n    /* istanbul ignore if */\n    if (options._recording) {\n      return overriddenRequest(options, callback);\n    }\n    options._recording = true;\n    var req = overriddenRequest(options, function (res) {\n      debug(thisRecordingId, 'intercepting', proto, 'request to record');\n\n      //  We put our 'end' listener to the front of the listener array.\n      res.once('end', function () {\n        debug(thisRecordingId, proto, 'intercepted request ended');\n        var reqheaders;\n        // Ignore request headers completely unless it was explicitly enabled by the user (see README)\n        if (enableReqHeadersRecording) {\n          // We never record user-agent headers as they are worse than useless -\n          // they actually make testing more difficult without providing any benefit (see README)\n          reqheaders = req.getHeaders();\n          common.deleteHeadersField(reqheaders, 'user-agent');\n        }\n        var generateFn = outputObjects ? generateRequestAndResponseObject : generateRequestAndResponse;\n        var out = generateFn({\n          req: req,\n          bodyChunks: bodyChunks,\n          options: options,\n          res: res,\n          dataChunks: dataChunks,\n          reqheaders: reqheaders\n        });\n        debug('out:', out);\n\n        //  Check that the request was made during the current recording.\n        //  If it hasn't then skip it. There is no other simple way to handle\n        //  this as it depends on the timing of requests and responses. Throwing\n        //  will make some recordings/unit tests fail randomly depending on how\n        //  fast/slow the response arrived.\n        //  If you are seeing this error then you need to make sure that all\n        //  the requests made during a single recording session finish before\n        //  ending the same recording session.\n        if (thisRecordingId !== currentRecordingId) {\n          debug('skipping recording of an out-of-order request', out);\n          return;\n        }\n        _outputs.push(out);\n        if (!dontPrint) {\n          if (useSeparator) {\n            if (typeof out !== 'string') {\n              out = JSON.stringify(out, null, 2);\n            }\n            logging(SEPARATOR + out + SEPARATOR);\n          } else {\n            logging(out);\n          }\n        }\n      });\n      var encoding;\n      // We need to be aware of changes to the stream's encoding so that we\n      // don't accidentally mangle the data.\n      var setEncoding = res.setEncoding;\n      res.setEncoding = function (newEncoding) {\n        encoding = newEncoding;\n        return setEncoding.apply(this, arguments);\n      };\n      var dataChunks = [];\n      // Replace res.push with our own implementation that stores chunks\n      var origResPush = res.push;\n      res.push = function (data) {\n        if (data) {\n          if (encoding) {\n            data = Buffer.from(data, encoding);\n          }\n          dataChunks.push(data);\n        }\n        return origResPush.call(res, data);\n      };\n      if (callback) {\n        callback(res, options, callback);\n      }\n      debug('finished setting up intercepting');\n\n      // We override both the http and the https modules; when we are\n      // serializing the request, we need to know which was called.\n      // By stuffing the state, we can make sure that nock records\n      // the intended protocol.\n      if (proto === 'https') {\n        options.proto = 'https';\n      }\n    });\n    var recordChunk = function recordChunk(chunk, encoding) {\n      debug(thisRecordingId, 'new', proto, 'body chunk');\n      if (!Buffer.isBuffer(chunk)) {\n        chunk = Buffer.from(chunk, encoding);\n      }\n      bodyChunks.push(chunk);\n    };\n    var oldWrite = req.write;\n    req.write = function (chunk, encoding) {\n      if (typeof chunk !== 'undefined') {\n        recordChunk(chunk, encoding);\n        oldWrite.apply(req, arguments);\n      } else {\n        throw new Error('Data was undefined.');\n      }\n    };\n\n    // Starting in Node 8, `OutgoingMessage.end()` directly calls an internal\n    // `write_` function instead of proxying to the public\n    // `OutgoingMessage.write()` method, so we have to wrap `end` too.\n    var oldEnd = req.end;\n    req.end = function (chunk, encoding, callback) {\n      debug('req.end');\n      if (typeof chunk === 'function') {\n        callback = chunk;\n        chunk = null;\n      } else if (typeof encoding === 'function') {\n        callback = encoding;\n        encoding = null;\n      }\n      if (chunk) {\n        recordChunk(chunk, encoding);\n      }\n      oldEnd.call(req, chunk, encoding, callback);\n    };\n    return req;\n  });\n}\n\n// Restore *all* the overridden http/https modules' properties.\nfunction restore() {\n  debug(currentRecordingId, 'restoring all the overridden http/https properties');\n  common.restoreOverriddenRequests();\n  restoreOverriddenClientRequest();\n  recordingInProgress = false;\n}\nfunction clear() {\n  _outputs = [];\n}\nmodule.exports = {\n  record: record,\n  outputs: function outputs() {\n    return _outputs;\n  },\n  restore: restore,\n  clear: clear\n};","map":{"version":3,"names":["debug","require","querystring","inspect","common","restoreOverriddenClientRequest","SEPARATOR","recordingInProgress","outputs","getScope","options","normalizeRequestOptions","proto","host","port","normalizeOrigin","getMethod","method","getBodyFromChunks","chunks","headers","isContentEncoded","body","map","chunk","toString","mergedBuffer","Buffer","concat","isUtf8Representable","maybeStringifiedJson","JSON","parse","err","generateRequestAndResponseObject","req","bodyChunks","res","dataChunks","reqheaders","path","scope","status","statusCode","response","rawHeaders","undefined","responseIsBinary","generateRequestAndResponse","requestBody","responseBody","queryIndex","indexOf","queryObj","substring","queryStr","slice","replace","encodedQueryObj","key","formattedPair","formatQueryValue","percentEncode","lines","push","methodName","toLowerCase","stringify","Object","entries","forEach","fieldName","fieldValue","safeName","safeValue","stringifiedResponseBody","join","currentRecordingId","defaultRecordOptions","dont_print","enable_reqheaders_recording","logging","console","log","output_objects","use_separator","record","recOptions","Error","thisRecordingId","dontPrint","enableReqHeadersRecording","outputObjects","useSeparator","restoreOverriddenRequests","overrideRequests","overriddenRequest","rawArgs","normalizeClientRequestArgs","callback","_recording","once","getHeaders","deleteHeadersField","generateFn","out","encoding","setEncoding","newEncoding","apply","arguments","origResPush","data","from","call","recordChunk","isBuffer","oldWrite","write","oldEnd","end","restore","clear","module","exports"],"sources":["/Users/lieo/diabetes/CUT2DMTest/node_modules/nock/lib/recorder.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')('nock.recorder')\nconst querystring = require('querystring')\nconst { inspect } = require('util')\n\nconst common = require('./common')\nconst { restoreOverriddenClientRequest } = require('./intercept')\n\nconst SEPARATOR = '\\n<<<<<<-- cut here -->>>>>>\\n'\nlet recordingInProgress = false\nlet outputs = []\n\nfunction getScope(options) {\n  const { proto, host, port } = common.normalizeRequestOptions(options)\n  return common.normalizeOrigin(proto, host, port)\n}\n\nfunction getMethod(options) {\n  return options.method || 'GET'\n}\n\nfunction getBodyFromChunks(chunks, headers) {\n  // If we have headers and there is content-encoding it means that the body\n  // shouldn't be merged but instead persisted as an array of hex strings so\n  // that the response chunks can be mocked one by one.\n  if (headers && common.isContentEncoded(headers)) {\n    return {\n      body: chunks.map(chunk => chunk.toString('hex')),\n    }\n  }\n\n  const mergedBuffer = Buffer.concat(chunks)\n\n  // The merged buffer can be one of three things:\n  // 1. A UTF-8-representable string buffer which represents a JSON object.\n  // 2. A UTF-8-representable buffer which doesn't represent a JSON object.\n  // 3. A non-UTF-8-representable buffer which then has to be recorded as a hex string.\n  const isUtf8Representable = common.isUtf8Representable(mergedBuffer)\n  if (isUtf8Representable) {\n    const maybeStringifiedJson = mergedBuffer.toString('utf8')\n    try {\n      return {\n        isUtf8Representable,\n        body: JSON.parse(maybeStringifiedJson),\n      }\n    } catch (err) {\n      return {\n        isUtf8Representable,\n        body: maybeStringifiedJson,\n      }\n    }\n  } else {\n    return {\n      isUtf8Representable,\n      body: mergedBuffer.toString('hex'),\n    }\n  }\n}\n\nfunction generateRequestAndResponseObject({\n  req,\n  bodyChunks,\n  options,\n  res,\n  dataChunks,\n  reqheaders,\n}) {\n  const { body, isUtf8Representable } = getBodyFromChunks(\n    dataChunks,\n    res.headers\n  )\n  options.path = req.path\n\n  return {\n    scope: getScope(options),\n    method: getMethod(options),\n    path: options.path,\n    // Is it deliberate that `getBodyFromChunks()` is called a second time?\n    body: getBodyFromChunks(bodyChunks).body,\n    status: res.statusCode,\n    response: body,\n    rawHeaders: res.rawHeaders,\n    reqheaders: reqheaders || undefined,\n    // When content-encoding is enabled, isUtf8Representable is `undefined`,\n    // so we explicitly check for `false`.\n    responseIsBinary: isUtf8Representable === false,\n  }\n}\n\nfunction generateRequestAndResponse({\n  req,\n  bodyChunks,\n  options,\n  res,\n  dataChunks,\n  reqheaders,\n}) {\n  const requestBody = getBodyFromChunks(bodyChunks).body\n  const responseBody = getBodyFromChunks(dataChunks, res.headers).body\n\n  // Remove any query params from options.path so they can be added in the query() function\n  let { path } = options\n  const queryIndex = req.path.indexOf('?')\n  let queryObj = {}\n  if (queryIndex !== -1) {\n    // Remove the query from the path\n    path = path.substring(0, queryIndex)\n\n    const queryStr = req.path.slice(queryIndex + 1)\n    queryObj = querystring.parse(queryStr)\n  }\n\n  // Escape any single quotes in the path as the output uses them\n  path = path.replace(/'/g, `\\\\'`)\n\n  // Always encode the query parameters when recording.\n  const encodedQueryObj = {}\n  for (const key in queryObj) {\n    const formattedPair = common.formatQueryValue(\n      key,\n      queryObj[key],\n      common.percentEncode\n    )\n    encodedQueryObj[formattedPair[0]] = formattedPair[1]\n  }\n\n  const lines = []\n\n  // We want a leading newline.\n  lines.push('')\n\n  const scope = getScope(options)\n  lines.push(`nock('${scope}', {\"encodedQueryParams\":true})`)\n\n  const methodName = getMethod(options).toLowerCase()\n  if (requestBody) {\n    lines.push(`  .${methodName}('${path}', ${JSON.stringify(requestBody)})`)\n  } else {\n    lines.push(`  .${methodName}('${path}')`)\n  }\n\n  Object.entries(reqheaders || {}).forEach(([fieldName, fieldValue]) => {\n    const safeName = JSON.stringify(fieldName)\n    const safeValue = JSON.stringify(fieldValue)\n    lines.push(`  .matchHeader(${safeName}, ${safeValue})`)\n  })\n\n  if (queryIndex !== -1) {\n    lines.push(`  .query(${JSON.stringify(encodedQueryObj)})`)\n  }\n\n  const statusCode = res.statusCode.toString()\n  const stringifiedResponseBody = JSON.stringify(responseBody)\n  const headers = inspect(res.rawHeaders)\n  lines.push(`  .reply(${statusCode}, ${stringifiedResponseBody}, ${headers});`)\n\n  return lines.join('\\n')\n}\n\n//  This module variable is used to identify a unique recording ID in order to skip\n//  spurious requests that sometimes happen. This problem has been, so far,\n//  exclusively detected in nock's unit testing where 'checks if callback is specified'\n//  interferes with other tests as its t.end() is invoked without waiting for request\n//  to finish (which is the point of the test).\nlet currentRecordingId = 0\n\nconst defaultRecordOptions = {\n  dont_print: false,\n  enable_reqheaders_recording: false,\n  logging: console.log, // eslint-disable-line no-console\n  output_objects: false,\n  use_separator: true,\n}\n\nfunction record(recOptions) {\n  //  Trying to start recording with recording already in progress implies an error\n  //  in the recording configuration (double recording makes no sense and used to lead\n  //  to duplicates in output)\n  if (recordingInProgress) {\n    throw new Error('Nock recording already in progress')\n  }\n\n  recordingInProgress = true\n\n  // Set the new current recording ID and capture its value in this instance of record().\n  currentRecordingId = currentRecordingId + 1\n  const thisRecordingId = currentRecordingId\n\n  // Originally the parameter was a dont_print boolean flag.\n  // To keep the existing code compatible we take that case into account.\n  if (typeof recOptions === 'boolean') {\n    recOptions = { dont_print: recOptions }\n  }\n\n  recOptions = { ...defaultRecordOptions, ...recOptions }\n\n  debug('start recording', thisRecordingId, recOptions)\n\n  const {\n    dont_print: dontPrint,\n    enable_reqheaders_recording: enableReqHeadersRecording,\n    logging,\n    output_objects: outputObjects,\n    use_separator: useSeparator,\n  } = recOptions\n\n  debug(thisRecordingId, 'restoring overridden requests before new overrides')\n  //  To preserve backward compatibility (starting recording wasn't throwing if nock was already active)\n  //  we restore any requests that may have been overridden by other parts of nock (e.g. intercept)\n  //  NOTE: This is hacky as hell but it keeps the backward compatibility *and* allows correct\n  //    behavior in the face of other modules also overriding ClientRequest.\n  common.restoreOverriddenRequests()\n  //  We restore ClientRequest as it messes with recording of modules that also override ClientRequest (e.g. xhr2)\n  restoreOverriddenClientRequest()\n\n  //  We override the requests so that we can save information on them before executing.\n  common.overrideRequests(function (proto, overriddenRequest, rawArgs) {\n    const { options, callback } = common.normalizeClientRequestArgs(...rawArgs)\n    const bodyChunks = []\n\n    // Node 0.11 https.request calls http.request -- don't want to record things\n    // twice.\n    /* istanbul ignore if */\n    if (options._recording) {\n      return overriddenRequest(options, callback)\n    }\n    options._recording = true\n\n    const req = overriddenRequest(options, function (res) {\n      debug(thisRecordingId, 'intercepting', proto, 'request to record')\n\n      //  We put our 'end' listener to the front of the listener array.\n      res.once('end', function () {\n        debug(thisRecordingId, proto, 'intercepted request ended')\n\n        let reqheaders\n        // Ignore request headers completely unless it was explicitly enabled by the user (see README)\n        if (enableReqHeadersRecording) {\n          // We never record user-agent headers as they are worse than useless -\n          // they actually make testing more difficult without providing any benefit (see README)\n          reqheaders = req.getHeaders()\n          common.deleteHeadersField(reqheaders, 'user-agent')\n        }\n\n        const generateFn = outputObjects\n          ? generateRequestAndResponseObject\n          : generateRequestAndResponse\n        let out = generateFn({\n          req,\n          bodyChunks,\n          options,\n          res,\n          dataChunks,\n          reqheaders,\n        })\n\n        debug('out:', out)\n\n        //  Check that the request was made during the current recording.\n        //  If it hasn't then skip it. There is no other simple way to handle\n        //  this as it depends on the timing of requests and responses. Throwing\n        //  will make some recordings/unit tests fail randomly depending on how\n        //  fast/slow the response arrived.\n        //  If you are seeing this error then you need to make sure that all\n        //  the requests made during a single recording session finish before\n        //  ending the same recording session.\n        if (thisRecordingId !== currentRecordingId) {\n          debug('skipping recording of an out-of-order request', out)\n          return\n        }\n\n        outputs.push(out)\n\n        if (!dontPrint) {\n          if (useSeparator) {\n            if (typeof out !== 'string') {\n              out = JSON.stringify(out, null, 2)\n            }\n            logging(SEPARATOR + out + SEPARATOR)\n          } else {\n            logging(out)\n          }\n        }\n      })\n\n      let encoding\n      // We need to be aware of changes to the stream's encoding so that we\n      // don't accidentally mangle the data.\n      const { setEncoding } = res\n      res.setEncoding = function (newEncoding) {\n        encoding = newEncoding\n        return setEncoding.apply(this, arguments)\n      }\n\n      const dataChunks = []\n      // Replace res.push with our own implementation that stores chunks\n      const origResPush = res.push\n      res.push = function (data) {\n        if (data) {\n          if (encoding) {\n            data = Buffer.from(data, encoding)\n          }\n          dataChunks.push(data)\n        }\n\n        return origResPush.call(res, data)\n      }\n\n      if (callback) {\n        callback(res, options, callback)\n      }\n\n      debug('finished setting up intercepting')\n\n      // We override both the http and the https modules; when we are\n      // serializing the request, we need to know which was called.\n      // By stuffing the state, we can make sure that nock records\n      // the intended protocol.\n      if (proto === 'https') {\n        options.proto = 'https'\n      }\n    })\n\n    const recordChunk = (chunk, encoding) => {\n      debug(thisRecordingId, 'new', proto, 'body chunk')\n      if (!Buffer.isBuffer(chunk)) {\n        chunk = Buffer.from(chunk, encoding)\n      }\n      bodyChunks.push(chunk)\n    }\n\n    const oldWrite = req.write\n    req.write = function (chunk, encoding) {\n      if (typeof chunk !== 'undefined') {\n        recordChunk(chunk, encoding)\n        oldWrite.apply(req, arguments)\n      } else {\n        throw new Error('Data was undefined.')\n      }\n    }\n\n    // Starting in Node 8, `OutgoingMessage.end()` directly calls an internal\n    // `write_` function instead of proxying to the public\n    // `OutgoingMessage.write()` method, so we have to wrap `end` too.\n    const oldEnd = req.end\n    req.end = function (chunk, encoding, callback) {\n      debug('req.end')\n      if (typeof chunk === 'function') {\n        callback = chunk\n        chunk = null\n      } else if (typeof encoding === 'function') {\n        callback = encoding\n        encoding = null\n      }\n\n      if (chunk) {\n        recordChunk(chunk, encoding)\n      }\n      oldEnd.call(req, chunk, encoding, callback)\n    }\n\n    return req\n  })\n}\n\n// Restore *all* the overridden http/https modules' properties.\nfunction restore() {\n  debug(\n    currentRecordingId,\n    'restoring all the overridden http/https properties'\n  )\n\n  common.restoreOverriddenRequests()\n  restoreOverriddenClientRequest()\n  recordingInProgress = false\n}\n\nfunction clear() {\n  outputs = []\n}\n\nmodule.exports = {\n  record,\n  outputs: () => outputs,\n  restore,\n  clear,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}