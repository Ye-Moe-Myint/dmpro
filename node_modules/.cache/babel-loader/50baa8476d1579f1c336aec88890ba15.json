{"ast":null,"code":"// parse a 512-byte header block to a data object, or vice-versa\n// If the data won't fit nicely in a simple header, then generate\n// the appropriate extended header file, and return that.\n\nmodule.exports = TarHeader;\nvar tar = require(\"../tar.js\"),\n  fields = tar.fields,\n  fieldOffs = tar.fieldOffs,\n  fieldEnds = tar.fieldEnds,\n  fieldSize = tar.fieldSize,\n  numeric = tar.numeric,\n  assert = require(\"assert\").ok,\n  space = \" \".charCodeAt(0),\n  slash = \"/\".charCodeAt(0),\n  bslash = process.platform === \"win32\" ? \"\\\\\".charCodeAt(0) : null;\nfunction TarHeader(block) {\n  if (!(this instanceof TarHeader)) return new TarHeader(block);\n  if (block) this.decode(block);\n}\nTarHeader.prototype = {\n  decode: decode,\n  encode: encode,\n  calcSum: calcSum,\n  checkSum: checkSum\n};\nTarHeader.parseNumeric = parseNumeric;\nTarHeader.encode = encode;\nTarHeader.decode = decode;\n\n// note that this will only do the normal ustar header, not any kind\n// of extended posix header file.  If something doesn't fit comfortably,\n// then it will set obj.needExtended = true, and set the block to\n// the closest approximation.\nfunction encode(obj) {\n  if (!obj && !(this instanceof TarHeader)) throw new Error(\"encode must be called on a TarHeader, or supplied an object\");\n  obj = obj || this;\n  var block = obj.block = new Buffer(512);\n\n  // if the object has a \"prefix\", then that's actually an extension of\n  // the path field.\n  if (obj.prefix) {\n    // console.error(\"%% header encoding, got a prefix\", obj.prefix)\n    obj.path = obj.prefix + \"/\" + obj.path;\n    // console.error(\"%% header encoding, prefixed path\", obj.path)\n    obj.prefix = \"\";\n  }\n  obj.needExtended = false;\n  if (obj.mode) {\n    if (typeof obj.mode === \"string\") obj.mode = parseInt(obj.mode, 8);\n    obj.mode = obj.mode & 0777;\n  }\n  for (var f = 0; fields[f] !== null; f++) {\n    var field = fields[f],\n      off = fieldOffs[f],\n      end = fieldEnds[f],\n      ret;\n    switch (field) {\n      case \"cksum\":\n        // special, done below, after all the others\n        break;\n      case \"prefix\":\n        // special, this is an extension of the \"path\" field.\n        // console.error(\"%% header encoding, skip prefix later\")\n        break;\n      case \"type\":\n        // convert from long name to a single char.\n        var type = obj.type || \"0\";\n        if (type.length > 1) {\n          type = tar.types[obj.type];\n          if (!type) type = \"0\";\n        }\n        writeText(block, off, end, type);\n        break;\n      case \"path\":\n        // uses the \"prefix\" field if > 100 bytes, but <= 255\n        var pathLen = Buffer.byteLength(obj.path),\n          pathFSize = fieldSize[fields.path],\n          prefFSize = fieldSize[fields.prefix];\n\n        // paths between 100 and 255 should use the prefix field.\n        // longer than 255\n        if (pathLen > pathFSize && pathLen <= pathFSize + prefFSize) {\n          // need to find a slash somewhere in the middle so that\n          // path and prefix both fit in their respective fields\n          var searchStart = pathLen - 1 - pathFSize,\n            searchEnd = prefFSize,\n            found = false,\n            pathBuf = new Buffer(obj.path);\n          for (var s = searchStart; s <= searchEnd; s++) {\n            if (pathBuf[s] === slash || pathBuf[s] === bslash) {\n              found = s;\n              break;\n            }\n          }\n          if (found !== false) {\n            prefix = pathBuf.slice(0, found).toString(\"utf8\");\n            path = pathBuf.slice(found + 1).toString(\"utf8\");\n            ret = writeText(block, off, end, path);\n            off = fieldOffs[fields.prefix];\n            end = fieldEnds[fields.prefix];\n            // console.error(\"%% header writing prefix\", off, end, prefix)\n            ret = writeText(block, off, end, prefix) || ret;\n            break;\n          }\n        }\n\n        // paths less than 100 chars don't need a prefix\n        // and paths longer than 255 need an extended header and will fail\n        // on old implementations no matter what we do here.\n        // Null out the prefix, and fallthrough to default.\n        // console.error(\"%% header writing no prefix\")\n        var poff = fieldOffs[fields.prefix],\n          pend = fieldEnds[fields.prefix];\n        writeText(block, poff, pend, \"\");\n      // fallthrough\n\n      // all other fields are numeric or text\n      default:\n        ret = numeric[field] ? writeNumeric(block, off, end, obj[field]) : writeText(block, off, end, obj[field] || \"\");\n        break;\n    }\n    obj.needExtended = obj.needExtended || ret;\n  }\n  var off = fieldOffs[fields.cksum],\n    end = fieldEnds[fields.cksum];\n  writeNumeric(block, off, end, calcSum.call(this, block));\n  return block;\n}\n\n// if it's a negative number, or greater than will fit,\n// then use write256.\nvar MAXNUM = {\n  12: 077777777777,\n  11: 07777777777,\n  8: 07777777,\n  7: 0777777\n};\nfunction writeNumeric(block, off, end, num) {\n  var writeLen = end - off,\n    maxNum = MAXNUM[writeLen] || 0;\n  num = num || 0;\n  // console.error(\"  numeric\", num)\n\n  if (num instanceof Date || Object.prototype.toString.call(num) === \"[object Date]\") {\n    num = num.getTime() / 1000;\n  }\n  if (num > maxNum || num < 0) {\n    write256(block, off, end, num);\n    // need an extended header if negative or too big.\n    return true;\n  }\n\n  // god, tar is so annoying\n  // if the string is small enough, you should put a space\n  // between the octal string and the \\0, but if it doesn't\n  // fit, then don't.\n  var numStr = Math.floor(num).toString(8);\n  if (num < MAXNUM[writeLen - 1]) numStr += \" \";\n\n  // pad with \"0\" chars\n  if (numStr.length < writeLen) {\n    numStr = new Array(writeLen - numStr.length).join(\"0\") + numStr;\n  }\n  if (numStr.length !== writeLen - 1) {\n    throw new Error(\"invalid length: \" + JSON.stringify(numStr) + \"\\n\" + \"expected: \" + writeLen);\n  }\n  block.write(numStr, off, writeLen, \"utf8\");\n  block[end - 1] = 0;\n}\nfunction write256(block, off, end, num) {\n  var buf = block.slice(off, end);\n  var positive = num >= 0;\n  buf[0] = positive ? 0x80 : 0xFF;\n\n  // get the number as a base-256 tuple\n  if (!positive) num *= -1;\n  var tuple = [];\n  do {\n    var n = num % 256;\n    tuple.push(n);\n    num = (num - n) / 256;\n  } while (num);\n  var bytes = tuple.length;\n  var fill = buf.length - bytes;\n  for (var i = 1; i < fill; i++) {\n    buf[i] = positive ? 0 : 0xFF;\n  }\n\n  // tuple is a base256 number, with [0] as the *least* significant byte\n  // if it's negative, then we need to flip all the bits once we hit the\n  // first non-zero bit.  The 2's-complement is (0x100 - n), and the 1's-\n  // complement is (0xFF - n).\n  var zero = true;\n  for (i = bytes; i > 0; i--) {\n    var byte = tuple[bytes - i];\n    if (positive) buf[fill + i] = byte;else if (zero && byte === 0) buf[fill + i] = 0;else if (zero) {\n      zero = false;\n      buf[fill + i] = 0x100 - byte;\n    } else buf[fill + i] = 0xFF - byte;\n  }\n}\nfunction writeText(block, off, end, str) {\n  // strings are written as utf8, then padded with \\0\n  var strLen = Buffer.byteLength(str),\n    writeLen = Math.min(strLen, end - off)\n    // non-ascii fields need extended headers\n    // long fields get truncated\n    ,\n    needExtended = strLen !== str.length || strLen > writeLen;\n\n  // write the string, and null-pad\n  if (writeLen > 0) block.write(str, off, writeLen, \"utf8\");\n  for (var i = off + writeLen; i < end; i++) block[i] = 0;\n  return needExtended;\n}\nfunction calcSum(block) {\n  block = block || this.block;\n  assert(Buffer.isBuffer(block) && block.length === 512);\n  if (!block) throw new Error(\"Need block to checksum\");\n\n  // now figure out what it would be if the cksum was \"        \"\n  var sum = 0,\n    start = fieldOffs[fields.cksum],\n    end = fieldEnds[fields.cksum];\n  for (var i = 0; i < fieldOffs[fields.cksum]; i++) {\n    sum += block[i];\n  }\n  for (var i = start; i < end; i++) {\n    sum += space;\n  }\n  for (var i = end; i < 512; i++) {\n    sum += block[i];\n  }\n  return sum;\n}\nfunction checkSum(block) {\n  var sum = calcSum.call(this, block);\n  block = block || this.block;\n  var cksum = block.slice(fieldOffs[fields.cksum], fieldEnds[fields.cksum]);\n  cksum = parseNumeric(cksum);\n  return cksum === sum;\n}\nfunction decode(block) {\n  block = block || this.block;\n  assert(Buffer.isBuffer(block) && block.length === 512);\n  this.block = block;\n  this.cksumValid = this.checkSum();\n  var prefix = null;\n\n  // slice off each field.\n  for (var f = 0; fields[f] !== null; f++) {\n    var field = fields[f],\n      val = block.slice(fieldOffs[f], fieldEnds[f]);\n    switch (field) {\n      case \"ustar\":\n        // if not ustar, then everything after that is just padding.\n        if (val.toString() !== \"ustar\\0\") {\n          this.ustar = false;\n          return;\n        } else {\n          // console.error(\"ustar:\", val, val.toString())\n          this.ustar = val.toString();\n        }\n        break;\n\n      // prefix is special, since it might signal the xstar header\n      case \"prefix\":\n        var atime = parseNumeric(val.slice(131, 131 + 12)),\n          ctime = parseNumeric(val.slice(131 + 12, 131 + 12 + 12));\n        if ((val[130] === 0 || val[130] === space) && typeof atime === \"number\" && typeof ctime === \"number\" && val[131 + 12] === space && val[131 + 12 + 12] === space) {\n          this.atime = atime;\n          this.ctime = ctime;\n          val = val.slice(0, 130);\n        }\n        prefix = val.toString(\"utf8\").replace(/\\0+$/, \"\");\n        // console.error(\"%% header reading prefix\", prefix)\n        break;\n\n      // all other fields are null-padding text\n      // or a number.\n      default:\n        if (numeric[field]) {\n          this[field] = parseNumeric(val);\n        } else {\n          this[field] = val.toString(\"utf8\").replace(/\\0+$/, \"\");\n        }\n        break;\n    }\n  }\n\n  // if we got a prefix, then prepend it to the path.\n  if (prefix) {\n    this.path = prefix + \"/\" + this.path;\n    // console.error(\"%% header got a prefix\", this.path)\n  }\n}\n\nfunction parse256(buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  var positive;\n  if (buf[0] === 0x80) positive = true;else if (buf[0] === 0xFF) positive = false;else return null;\n\n  // build up a base-256 tuple from the least sig to the highest\n  var zero = false,\n    tuple = [];\n  for (var i = buf.length - 1; i > 0; i--) {\n    var byte = buf[i];\n    if (positive) tuple.push(byte);else if (zero && byte === 0) tuple.push(0);else if (zero) {\n      zero = false;\n      tuple.push(0x100 - byte);\n    } else tuple.push(0xFF - byte);\n  }\n  for (var sum = 0, i = 0, l = tuple.length; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i);\n  }\n  return positive ? sum : -1 * sum;\n}\nfunction parseNumeric(f) {\n  if (f[0] & 0x80) return parse256(f);\n  var str = f.toString(\"utf8\").split(\"\\0\")[0].trim(),\n    res = parseInt(str, 8);\n  return isNaN(res) ? null : res;\n}","map":{"version":3,"names":["module","exports","TarHeader","tar","require","fields","fieldOffs","fieldEnds","fieldSize","numeric","assert","ok","space","charCodeAt","slash","bslash","process","platform","block","decode","prototype","encode","calcSum","checkSum","parseNumeric","obj","Error","Buffer","prefix","path","needExtended","mode","parseInt","f","field","off","end","ret","type","length","types","writeText","pathLen","byteLength","pathFSize","prefFSize","searchStart","searchEnd","found","pathBuf","s","slice","toString","poff","pend","writeNumeric","cksum","call","MAXNUM","num","writeLen","maxNum","Date","Object","getTime","write256","numStr","Math","floor","Array","join","JSON","stringify","write","buf","positive","tuple","n","push","bytes","fill","i","zero","byte","str","strLen","min","isBuffer","sum","start","cksumValid","val","ustar","atime","ctime","replace","parse256","l","pow","split","trim","res","isNaN"],"sources":["/Users/lieo/diabetes/CUT2DMTest/node_modules/node-gyp/node_modules/tar/lib/header.js"],"sourcesContent":["// parse a 512-byte header block to a data object, or vice-versa\n// If the data won't fit nicely in a simple header, then generate\n// the appropriate extended header file, and return that.\n\nmodule.exports = TarHeader\n\nvar tar = require(\"../tar.js\")\n  , fields = tar.fields\n  , fieldOffs = tar.fieldOffs\n  , fieldEnds = tar.fieldEnds\n  , fieldSize = tar.fieldSize\n  , numeric = tar.numeric\n  , assert = require(\"assert\").ok\n  , space = \" \".charCodeAt(0)\n  , slash = \"/\".charCodeAt(0)\n  , bslash = process.platform === \"win32\" ? \"\\\\\".charCodeAt(0) : null\n\nfunction TarHeader (block) {\n  if (!(this instanceof TarHeader)) return new TarHeader(block)\n  if (block) this.decode(block)\n}\n\nTarHeader.prototype =\n  { decode : decode\n  , encode: encode\n  , calcSum: calcSum\n  , checkSum: checkSum\n  }\n\nTarHeader.parseNumeric = parseNumeric\nTarHeader.encode = encode\nTarHeader.decode = decode\n\n// note that this will only do the normal ustar header, not any kind\n// of extended posix header file.  If something doesn't fit comfortably,\n// then it will set obj.needExtended = true, and set the block to\n// the closest approximation.\nfunction encode (obj) {\n  if (!obj && !(this instanceof TarHeader)) throw new Error(\n    \"encode must be called on a TarHeader, or supplied an object\")\n\n  obj = obj || this\n  var block = obj.block = new Buffer(512)\n\n  // if the object has a \"prefix\", then that's actually an extension of\n  // the path field.\n  if (obj.prefix) {\n    // console.error(\"%% header encoding, got a prefix\", obj.prefix)\n    obj.path = obj.prefix + \"/\" + obj.path\n    // console.error(\"%% header encoding, prefixed path\", obj.path)\n    obj.prefix = \"\"\n  }\n\n  obj.needExtended = false\n\n  if (obj.mode) {\n    if (typeof obj.mode === \"string\") obj.mode = parseInt(obj.mode, 8)\n    obj.mode = obj.mode & 0777\n  }\n\n  for (var f = 0; fields[f] !== null; f ++) {\n    var field = fields[f]\n      , off = fieldOffs[f]\n      , end = fieldEnds[f]\n      , ret\n\n    switch (field) {\n      case \"cksum\":\n        // special, done below, after all the others\n        break\n\n      case \"prefix\":\n        // special, this is an extension of the \"path\" field.\n        // console.error(\"%% header encoding, skip prefix later\")\n        break\n\n      case \"type\":\n        // convert from long name to a single char.\n        var type = obj.type || \"0\"\n        if (type.length > 1) {\n          type = tar.types[obj.type]\n          if (!type) type = \"0\"\n        }\n        writeText(block, off, end, type)\n        break\n\n      case \"path\":\n        // uses the \"prefix\" field if > 100 bytes, but <= 255\n        var pathLen = Buffer.byteLength(obj.path)\n          , pathFSize = fieldSize[fields.path]\n          , prefFSize = fieldSize[fields.prefix]\n\n        // paths between 100 and 255 should use the prefix field.\n        // longer than 255\n        if (pathLen > pathFSize &&\n            pathLen <= pathFSize + prefFSize) {\n          // need to find a slash somewhere in the middle so that\n          // path and prefix both fit in their respective fields\n          var searchStart = pathLen - 1 - pathFSize\n            , searchEnd = prefFSize\n            , found = false\n            , pathBuf = new Buffer(obj.path)\n\n          for ( var s = searchStart\n              ; (s <= searchEnd)\n              ; s ++ ) {\n            if (pathBuf[s] === slash || pathBuf[s] === bslash) {\n              found = s\n              break\n            }\n          }\n\n          if (found !== false) {\n            prefix = pathBuf.slice(0, found).toString(\"utf8\")\n            path = pathBuf.slice(found + 1).toString(\"utf8\")\n\n            ret = writeText(block, off, end, path)\n            off = fieldOffs[fields.prefix]\n            end = fieldEnds[fields.prefix]\n            // console.error(\"%% header writing prefix\", off, end, prefix)\n            ret = writeText(block, off, end, prefix) || ret\n            break\n          }\n        }\n\n        // paths less than 100 chars don't need a prefix\n        // and paths longer than 255 need an extended header and will fail\n        // on old implementations no matter what we do here.\n        // Null out the prefix, and fallthrough to default.\n        // console.error(\"%% header writing no prefix\")\n        var poff = fieldOffs[fields.prefix]\n          , pend = fieldEnds[fields.prefix]\n        writeText(block, poff, pend, \"\")\n        // fallthrough\n\n      // all other fields are numeric or text\n      default:\n        ret = numeric[field]\n            ? writeNumeric(block, off, end, obj[field])\n            : writeText(block, off, end, obj[field] || \"\")\n        break\n    }\n    obj.needExtended = obj.needExtended || ret\n  }\n\n  var off = fieldOffs[fields.cksum]\n    , end = fieldEnds[fields.cksum]\n\n  writeNumeric(block, off, end, calcSum.call(this, block))\n\n  return block\n}\n\n// if it's a negative number, or greater than will fit,\n// then use write256.\nvar MAXNUM = { 12: 077777777777\n             , 11: 07777777777\n             , 8 : 07777777\n             , 7 : 0777777 }\nfunction writeNumeric (block, off, end, num) {\n  var writeLen = end - off\n    , maxNum = MAXNUM[writeLen] || 0\n\n  num = num || 0\n  // console.error(\"  numeric\", num)\n\n  if (num instanceof Date ||\n      Object.prototype.toString.call(num) === \"[object Date]\") {\n    num = num.getTime() / 1000\n  }\n\n  if (num > maxNum || num < 0) {\n    write256(block, off, end, num)\n    // need an extended header if negative or too big.\n    return true\n  }\n\n  // god, tar is so annoying\n  // if the string is small enough, you should put a space\n  // between the octal string and the \\0, but if it doesn't\n  // fit, then don't.\n  var numStr = Math.floor(num).toString(8)\n  if (num < MAXNUM[writeLen - 1]) numStr += \" \"\n\n  // pad with \"0\" chars\n  if (numStr.length < writeLen) {\n    numStr = (new Array(writeLen - numStr.length).join(\"0\")) + numStr\n  }\n\n  if (numStr.length !== writeLen - 1) {\n    throw new Error(\"invalid length: \" + JSON.stringify(numStr) + \"\\n\" +\n                    \"expected: \"+writeLen)\n  }\n  block.write(numStr, off, writeLen, \"utf8\")\n  block[end - 1] = 0\n}\n\nfunction write256 (block, off, end, num) {\n  var buf = block.slice(off, end)\n  var positive = num >= 0\n  buf[0] = positive ? 0x80 : 0xFF\n\n  // get the number as a base-256 tuple\n  if (!positive) num *= -1\n  var tuple = []\n  do {\n    var n = num % 256\n    tuple.push(n)\n    num = (num - n) / 256\n  } while (num)\n\n  var bytes = tuple.length\n\n  var fill = buf.length - bytes\n  for (var i = 1; i < fill; i ++) {\n    buf[i] = positive ? 0 : 0xFF\n  }\n\n  // tuple is a base256 number, with [0] as the *least* significant byte\n  // if it's negative, then we need to flip all the bits once we hit the\n  // first non-zero bit.  The 2's-complement is (0x100 - n), and the 1's-\n  // complement is (0xFF - n).\n  var zero = true\n  for (i = bytes; i > 0; i --) {\n    var byte = tuple[bytes - i]\n    if (positive) buf[fill + i] = byte\n    else if (zero && byte === 0) buf[fill + i] = 0\n    else if (zero) {\n      zero = false\n      buf[fill + i] = 0x100 - byte\n    } else buf[fill + i] = 0xFF - byte\n  }\n}\n\nfunction writeText (block, off, end, str) {\n  // strings are written as utf8, then padded with \\0\n  var strLen = Buffer.byteLength(str)\n    , writeLen = Math.min(strLen, end - off)\n    // non-ascii fields need extended headers\n    // long fields get truncated\n    , needExtended = strLen !== str.length || strLen > writeLen\n\n  // write the string, and null-pad\n  if (writeLen > 0) block.write(str, off, writeLen, \"utf8\")\n  for (var i = off + writeLen; i < end; i ++) block[i] = 0\n\n  return needExtended\n}\n\nfunction calcSum (block) {\n  block = block || this.block\n  assert(Buffer.isBuffer(block) && block.length === 512)\n\n  if (!block) throw new Error(\"Need block to checksum\")\n\n  // now figure out what it would be if the cksum was \"        \"\n  var sum = 0\n    , start = fieldOffs[fields.cksum]\n    , end = fieldEnds[fields.cksum]\n\n  for (var i = 0; i < fieldOffs[fields.cksum]; i ++) {\n    sum += block[i]\n  }\n\n  for (var i = start; i < end; i ++) {\n    sum += space\n  }\n\n  for (var i = end; i < 512; i ++) {\n    sum += block[i]\n  }\n\n  return sum\n}\n\n\nfunction checkSum (block) {\n  var sum = calcSum.call(this, block)\n  block = block || this.block\n\n  var cksum = block.slice(fieldOffs[fields.cksum], fieldEnds[fields.cksum])\n  cksum = parseNumeric(cksum)\n\n  return cksum === sum\n}\n\nfunction decode (block) {\n  block = block || this.block\n  assert(Buffer.isBuffer(block) && block.length === 512)\n\n  this.block = block\n  this.cksumValid = this.checkSum()\n\n  var prefix = null\n\n  // slice off each field.\n  for (var f = 0; fields[f] !== null; f ++) {\n    var field = fields[f]\n      , val = block.slice(fieldOffs[f], fieldEnds[f])\n\n    switch (field) {\n      case \"ustar\":\n        // if not ustar, then everything after that is just padding.\n        if (val.toString() !== \"ustar\\0\") {\n          this.ustar = false\n          return\n        } else {\n          // console.error(\"ustar:\", val, val.toString())\n          this.ustar = val.toString()\n        }\n        break\n\n      // prefix is special, since it might signal the xstar header\n      case \"prefix\":\n        var atime = parseNumeric(val.slice(131, 131 + 12))\n          , ctime = parseNumeric(val.slice(131 + 12, 131 + 12 + 12))\n        if ((val[130] === 0 || val[130] === space) &&\n            typeof atime === \"number\" &&\n            typeof ctime === \"number\" &&\n            val[131 + 12] === space &&\n            val[131 + 12 + 12] === space) {\n          this.atime = atime\n          this.ctime = ctime\n          val = val.slice(0, 130)\n        }\n        prefix = val.toString(\"utf8\").replace(/\\0+$/, \"\")\n        // console.error(\"%% header reading prefix\", prefix)\n        break\n\n      // all other fields are null-padding text\n      // or a number.\n      default:\n        if (numeric[field]) {\n          this[field] = parseNumeric(val)\n        } else {\n          this[field] = val.toString(\"utf8\").replace(/\\0+$/, \"\")\n        }\n        break\n    }\n  }\n\n  // if we got a prefix, then prepend it to the path.\n  if (prefix) {\n    this.path = prefix + \"/\" + this.path\n    // console.error(\"%% header got a prefix\", this.path)\n  }\n}\n\nfunction parse256 (buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  var positive\n  if (buf[0] === 0x80) positive = true\n  else if (buf[0] === 0xFF) positive = false\n  else return null\n\n  // build up a base-256 tuple from the least sig to the highest\n  var zero = false\n    , tuple = []\n  for (var i = buf.length - 1; i > 0; i --) {\n    var byte = buf[i]\n    if (positive) tuple.push(byte)\n    else if (zero && byte === 0) tuple.push(0)\n    else if (zero) {\n      zero = false\n      tuple.push(0x100 - byte)\n    } else tuple.push(0xFF - byte)\n  }\n\n  for (var sum = 0, i = 0, l = tuple.length; i < l; i ++) {\n    sum += tuple[i] * Math.pow(256, i)\n  }\n\n  return positive ? sum : -1 * sum\n}\n\nfunction parseNumeric (f) {\n  if (f[0] & 0x80) return parse256(f)\n\n  var str = f.toString(\"utf8\").split(\"\\0\")[0].trim()\n    , res = parseInt(str, 8)\n\n  return isNaN(res) ? null : res\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}