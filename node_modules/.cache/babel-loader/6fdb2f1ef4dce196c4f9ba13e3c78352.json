{"ast":null,"code":"'use strict';\n\n/**\n * @module nock/scope\n */\nvar _slicedToArray = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _objectSpread = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _require = require('./intercept'),\n  addInterceptor = _require.addInterceptor,\n  isOn = _require.isOn;\nvar common = require('./common');\nvar assert = require('assert');\nvar url = require('url');\nvar debug = require('debug')('nock.scope');\nvar _require2 = require('events'),\n  EventEmitter = _require2.EventEmitter;\nvar Interceptor = require('./interceptor');\nvar URL = url.URL,\n  LegacyUrl = url.Url;\nvar fs;\ntry {\n  fs = require('fs');\n} catch (err) {\n  // do nothing, we're in the browser\n}\n\n/**\n * Normalizes the passed url for consistent internal processing\n * @param {string|LegacyUrl|URL} u\n */\nfunction normalizeUrl(u) {\n  if (!(u instanceof URL)) {\n    if (u instanceof LegacyUrl) {\n      return normalizeUrl(new URL(url.format(u)));\n    }\n    // If the url is invalid, let the URL library report it\n    return normalizeUrl(new URL(u));\n  }\n  if (!/https?:/.test(u.protocol)) {\n    throw new TypeError(\"Protocol '\".concat(u.protocol, \"' not recognized. This commonly occurs when a hostname and port are included without a protocol, producing a URL that is valid but confusing, and probably not what you want.\"));\n  }\n  return {\n    href: u.href,\n    origin: u.origin,\n    protocol: u.protocol,\n    username: u.username,\n    password: u.password,\n    host: u.host,\n    hostname:\n    // strip brackets from IPv6\n    typeof u.hostname === 'string' && u.hostname.startsWith('[') ? u.hostname.slice(1, -1) : u.hostname,\n    port: u.port || (u.protocol === 'http:' ? 80 : 443),\n    pathname: u.pathname,\n    search: u.search,\n    searchParams: u.searchParams,\n    hash: u.hash\n  };\n}\n\n/**\n * @param  {string|RegExp|LegacyUrl|URL} basePath\n * @param  {Object}   options\n * @param  {boolean}  options.allowUnmocked\n * @param  {string[]} options.badheaders\n * @param  {function} options.conditionally\n * @param  {boolean}  options.encodedQueryParams\n * @param  {function} options.filteringScope\n * @param  {Object}   options.reqheaders\n * @constructor\n */\nvar Scope = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Scope, _EventEmitter);\n  var _super = _createSuper(Scope);\n  function Scope(basePath, options) {\n    var _this;\n    _classCallCheck(this, Scope);\n    _this = _super.call(this);\n    _this.keyedInterceptors = {};\n    _this.interceptors = [];\n    _this.transformPathFunction = null;\n    _this.transformRequestBodyFunction = null;\n    _this.matchHeaders = [];\n    _this.scopeOptions = options || {};\n    _this.urlParts = {};\n    _this._persist = false;\n    _this.contentLen = false;\n    _this.date = null;\n    _this.basePath = basePath;\n    _this.basePathname = '';\n    _this.port = null;\n    _this._defaultReplyHeaders = [];\n    var logNamespace = String(basePath);\n    if (!(basePath instanceof RegExp)) {\n      _this.urlParts = normalizeUrl(basePath);\n      _this.port = _this.urlParts.port;\n      _this.basePathname = _this.urlParts.pathname.replace(/\\/$/, '');\n      _this.basePath = \"\".concat(_this.urlParts.protocol, \"//\").concat(_this.urlParts.hostname, \":\").concat(_this.port);\n      logNamespace = _this.urlParts.host;\n    }\n    _this.logger = debug.extend(logNamespace);\n    return _this;\n  }\n  _createClass(Scope, [{\n    key: \"add\",\n    value: function add(key, interceptor) {\n      if (!(key in this.keyedInterceptors)) {\n        this.keyedInterceptors[key] = [];\n      }\n      this.keyedInterceptors[key].push(interceptor);\n      addInterceptor(this.basePath, interceptor, this, this.scopeOptions, this.urlParts.hostname);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key, interceptor) {\n      if (this._persist) {\n        return;\n      }\n      var arr = this.keyedInterceptors[key];\n      if (arr) {\n        arr.splice(arr.indexOf(interceptor), 1);\n        if (arr.length === 0) {\n          delete this.keyedInterceptors[key];\n        }\n      }\n    }\n  }, {\n    key: \"intercept\",\n    value: function intercept(uri, method, requestBody, interceptorOptions) {\n      var ic = new Interceptor(this, uri, method, requestBody, interceptorOptions);\n      this.interceptors.push(ic);\n      return ic;\n    }\n  }, {\n    key: \"get\",\n    value: function get(uri, requestBody, options) {\n      return this.intercept(uri, 'GET', requestBody, options);\n    }\n  }, {\n    key: \"post\",\n    value: function post(uri, requestBody, options) {\n      return this.intercept(uri, 'POST', requestBody, options);\n    }\n  }, {\n    key: \"put\",\n    value: function put(uri, requestBody, options) {\n      return this.intercept(uri, 'PUT', requestBody, options);\n    }\n  }, {\n    key: \"head\",\n    value: function head(uri, requestBody, options) {\n      return this.intercept(uri, 'HEAD', requestBody, options);\n    }\n  }, {\n    key: \"patch\",\n    value: function patch(uri, requestBody, options) {\n      return this.intercept(uri, 'PATCH', requestBody, options);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(uri, requestBody, options) {\n      return this.intercept(uri, 'MERGE', requestBody, options);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(uri, requestBody, options) {\n      return this.intercept(uri, 'DELETE', requestBody, options);\n    }\n  }, {\n    key: \"options\",\n    value: function options(uri, requestBody, _options) {\n      return this.intercept(uri, 'OPTIONS', requestBody, _options);\n    }\n\n    // Returns the list of keys for non-optional Interceptors that haven't been completed yet.\n    // TODO: This assumes that completed mocks are removed from the keyedInterceptors list\n    // (when persistence is off). We should change that (and this) in future.\n  }, {\n    key: \"pendingMocks\",\n    value: function pendingMocks() {\n      var _this2 = this;\n      return this.activeMocks().filter(function (key) {\n        return _this2.keyedInterceptors[key].some(function (_ref) {\n          var interceptionCounter = _ref.interceptionCounter,\n            optional = _ref.optional;\n          var persistedAndUsed = _this2._persist && interceptionCounter > 0;\n          return !persistedAndUsed && !optional;\n        });\n      });\n    }\n\n    // Returns all keyedInterceptors that are active.\n    // This includes incomplete interceptors, persisted but complete interceptors, and\n    // optional interceptors, but not non-persisted and completed interceptors.\n  }, {\n    key: \"activeMocks\",\n    value: function activeMocks() {\n      return Object.keys(this.keyedInterceptors);\n    }\n  }, {\n    key: \"isDone\",\n    value: function isDone() {\n      if (!isOn()) {\n        return true;\n      }\n      return this.pendingMocks().length === 0;\n    }\n  }, {\n    key: \"done\",\n    value: function done() {\n      assert.ok(this.isDone(), \"Mocks not yet satisfied:\\n\".concat(this.pendingMocks().join('\\n')));\n    }\n  }, {\n    key: \"buildFilter\",\n    value: function buildFilter() {\n      var filteringArguments = arguments;\n      if (arguments[0] instanceof RegExp) {\n        return function (candidate) {\n          /* istanbul ignore if */\n          if (typeof candidate !== 'string') {\n            // Given the way nock is written, it seems like `candidate` will always\n            // be a string, regardless of what options might be passed to it.\n            // However the code used to contain a truthiness test of `candidate`.\n            // The check is being preserved for now.\n            throw Error(\"Nock internal assertion failed: typeof candidate is \".concat(typeof candidate, \". If you encounter this error, please report it as a bug.\"));\n          }\n          return candidate.replace(filteringArguments[0], filteringArguments[1]);\n        };\n      } else if (typeof arguments[0] === 'function') {\n        return arguments[0];\n      }\n    }\n  }, {\n    key: \"filteringPath\",\n    value: function filteringPath() {\n      this.transformPathFunction = this.buildFilter.apply(this, arguments);\n      if (!this.transformPathFunction) {\n        throw new Error('Invalid arguments: filtering path should be a function or a regular expression');\n      }\n      return this;\n    }\n  }, {\n    key: \"filteringRequestBody\",\n    value: function filteringRequestBody() {\n      this.transformRequestBodyFunction = this.buildFilter.apply(this, arguments);\n      if (!this.transformRequestBodyFunction) {\n        throw new Error('Invalid arguments: filtering request body should be a function or a regular expression');\n      }\n      return this;\n    }\n  }, {\n    key: \"matchHeader\",\n    value: function matchHeader(name, value) {\n      //  We use lower-case header field names throughout Nock.\n      this.matchHeaders.push({\n        name: name.toLowerCase(),\n        value: value\n      });\n      return this;\n    }\n  }, {\n    key: \"defaultReplyHeaders\",\n    value: function defaultReplyHeaders(headers) {\n      this._defaultReplyHeaders = common.headersInputToRawArray(headers);\n      return this;\n    }\n  }, {\n    key: \"persist\",\n    value: function persist() {\n      var flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (typeof flag !== 'boolean') {\n        throw new Error('Invalid arguments: argument should be a boolean');\n      }\n      this._persist = flag;\n      return this;\n    }\n\n    /**\n     * @private\n     * @returns {boolean}\n     */\n  }, {\n    key: \"shouldPersist\",\n    value: function shouldPersist() {\n      return this._persist;\n    }\n  }, {\n    key: \"replyContentLength\",\n    value: function replyContentLength() {\n      this.contentLen = true;\n      return this;\n    }\n  }, {\n    key: \"replyDate\",\n    value: function replyDate(d) {\n      this.date = d || new Date();\n      return this;\n    }\n  }]);\n  return Scope;\n}(EventEmitter);\nfunction loadDefs(path) {\n  if (!fs) {\n    throw new Error('No fs');\n  }\n  var contents = fs.readFileSync(path);\n  return JSON.parse(contents);\n}\nfunction load(path) {\n  return define(loadDefs(path));\n}\nfunction getStatusFromDefinition(nockDef) {\n  // Backward compatibility for when `status` was encoded as string in `reply`.\n  if (nockDef.reply !== undefined) {\n    var parsedReply = parseInt(nockDef.reply, 10);\n    if (isNaN(parsedReply)) {\n      throw Error('`reply`, when present, must be a numeric string');\n    }\n    return parsedReply;\n  }\n  var DEFAULT_STATUS_OK = 200;\n  return nockDef.status || DEFAULT_STATUS_OK;\n}\nfunction getScopeFromDefinition(nockDef) {\n  //  Backward compatibility for when `port` was part of definition.\n  if (nockDef.port !== undefined) {\n    //  Include `port` into scope if it doesn't exist.\n    var options = url.parse(nockDef.scope);\n    if (options.port === null) {\n      return \"\".concat(nockDef.scope, \":\").concat(nockDef.port);\n    } else {\n      if (parseInt(options.port) !== parseInt(nockDef.port)) {\n        throw new Error('Mismatched port numbers in scope and port properties of nock definition.');\n      }\n    }\n  }\n  return nockDef.scope;\n}\nfunction tryJsonParse(string) {\n  try {\n    return JSON.parse(string);\n  } catch (err) {\n    return string;\n  }\n}\nfunction define(nockDefs) {\n  var scopes = [];\n  nockDefs.forEach(function (nockDef) {\n    var nscope = getScopeFromDefinition(nockDef);\n    var npath = nockDef.path;\n    if (!nockDef.method) {\n      throw Error('Method is required');\n    }\n    var method = nockDef.method.toLowerCase();\n    var status = getStatusFromDefinition(nockDef);\n    var rawHeaders = nockDef.rawHeaders || [];\n    var reqheaders = nockDef.reqheaders || {};\n    var badheaders = nockDef.badheaders || [];\n    var options = _objectSpread({}, nockDef.options);\n\n    //  We use request headers for both filtering (see below) and mocking.\n    //  Here we are setting up mocked request headers but we don't want to\n    //  be changing the user's options object so we clone it first.\n    options.reqheaders = reqheaders;\n    options.badheaders = badheaders;\n\n    // Response is not always JSON as it could be a string or binary data or\n    // even an array of binary buffers (e.g. when content is encoded).\n    var response;\n    if (!nockDef.response) {\n      response = '';\n      // TODO: Rename `responseIsBinary` to `responseIsUtf8Representable`.\n    } else if (nockDef.responseIsBinary) {\n      response = Buffer.from(nockDef.response, 'hex');\n    } else {\n      response = typeof nockDef.response === 'string' ? tryJsonParse(nockDef.response) : nockDef.response;\n    }\n    var scope = new Scope(nscope, options);\n\n    // If request headers were specified filter by them.\n    Object.entries(reqheaders).forEach(function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n        fieldName = _ref3[0],\n        value = _ref3[1];\n      scope.matchHeader(fieldName, value);\n    });\n    var acceptableFilters = ['filteringRequestBody', 'filteringPath'];\n    acceptableFilters.forEach(function (filter) {\n      if (nockDef[filter]) {\n        scope[filter](nockDef[filter]);\n      }\n    });\n    scope.intercept(npath, method, nockDef.body).reply(status, response, rawHeaders);\n    scopes.push(scope);\n  });\n  return scopes;\n}\nmodule.exports = {\n  Scope: Scope,\n  load: load,\n  loadDefs: loadDefs,\n  define: define\n};","map":{"version":3,"names":["require","addInterceptor","isOn","common","assert","url","debug","EventEmitter","Interceptor","URL","LegacyUrl","Url","fs","err","normalizeUrl","u","format","test","protocol","TypeError","href","origin","username","password","host","hostname","startsWith","slice","port","pathname","search","searchParams","hash","Scope","basePath","options","keyedInterceptors","interceptors","transformPathFunction","transformRequestBodyFunction","matchHeaders","scopeOptions","urlParts","_persist","contentLen","date","basePathname","_defaultReplyHeaders","logNamespace","String","RegExp","replace","logger","extend","key","interceptor","push","arr","splice","indexOf","length","uri","method","requestBody","interceptorOptions","ic","intercept","activeMocks","filter","some","interceptionCounter","optional","persistedAndUsed","Object","keys","pendingMocks","ok","isDone","join","filteringArguments","arguments","candidate","Error","buildFilter","apply","name","value","toLowerCase","headers","headersInputToRawArray","flag","d","Date","loadDefs","path","contents","readFileSync","JSON","parse","load","define","getStatusFromDefinition","nockDef","reply","undefined","parsedReply","parseInt","isNaN","DEFAULT_STATUS_OK","status","getScopeFromDefinition","scope","tryJsonParse","string","nockDefs","scopes","forEach","nscope","npath","rawHeaders","reqheaders","badheaders","response","responseIsBinary","Buffer","from","entries","fieldName","matchHeader","acceptableFilters","body","module","exports"],"sources":["/Users/lieo/diabetes/CUT2DMTest/node_modules/nock/lib/scope.js"],"sourcesContent":["'use strict'\n\n/**\n * @module nock/scope\n */\nconst { addInterceptor, isOn } = require('./intercept')\nconst common = require('./common')\nconst assert = require('assert')\nconst url = require('url')\nconst debug = require('debug')('nock.scope')\nconst { EventEmitter } = require('events')\nconst Interceptor = require('./interceptor')\n\nconst { URL, Url: LegacyUrl } = url\nlet fs\n\ntry {\n  fs = require('fs')\n} catch (err) {\n  // do nothing, we're in the browser\n}\n\n/**\n * Normalizes the passed url for consistent internal processing\n * @param {string|LegacyUrl|URL} u\n */\nfunction normalizeUrl(u) {\n  if (!(u instanceof URL)) {\n    if (u instanceof LegacyUrl) {\n      return normalizeUrl(new URL(url.format(u)))\n    }\n    // If the url is invalid, let the URL library report it\n    return normalizeUrl(new URL(u))\n  }\n\n  if (!/https?:/.test(u.protocol)) {\n    throw new TypeError(\n      `Protocol '${u.protocol}' not recognized. This commonly occurs when a hostname and port are included without a protocol, producing a URL that is valid but confusing, and probably not what you want.`\n    )\n  }\n\n  return {\n    href: u.href,\n    origin: u.origin,\n    protocol: u.protocol,\n    username: u.username,\n    password: u.password,\n    host: u.host,\n    hostname:\n      // strip brackets from IPv6\n      typeof u.hostname === 'string' && u.hostname.startsWith('[')\n        ? u.hostname.slice(1, -1)\n        : u.hostname,\n    port: u.port || (u.protocol === 'http:' ? 80 : 443),\n    pathname: u.pathname,\n    search: u.search,\n    searchParams: u.searchParams,\n    hash: u.hash,\n  }\n}\n\n/**\n * @param  {string|RegExp|LegacyUrl|URL} basePath\n * @param  {Object}   options\n * @param  {boolean}  options.allowUnmocked\n * @param  {string[]} options.badheaders\n * @param  {function} options.conditionally\n * @param  {boolean}  options.encodedQueryParams\n * @param  {function} options.filteringScope\n * @param  {Object}   options.reqheaders\n * @constructor\n */\nclass Scope extends EventEmitter {\n  constructor(basePath, options) {\n    super()\n\n    this.keyedInterceptors = {}\n    this.interceptors = []\n    this.transformPathFunction = null\n    this.transformRequestBodyFunction = null\n    this.matchHeaders = []\n    this.scopeOptions = options || {}\n    this.urlParts = {}\n    this._persist = false\n    this.contentLen = false\n    this.date = null\n    this.basePath = basePath\n    this.basePathname = ''\n    this.port = null\n    this._defaultReplyHeaders = []\n\n    let logNamespace = String(basePath)\n\n    if (!(basePath instanceof RegExp)) {\n      this.urlParts = normalizeUrl(basePath)\n      this.port = this.urlParts.port\n      this.basePathname = this.urlParts.pathname.replace(/\\/$/, '')\n      this.basePath = `${this.urlParts.protocol}//${this.urlParts.hostname}:${this.port}`\n      logNamespace = this.urlParts.host\n    }\n\n    this.logger = debug.extend(logNamespace)\n  }\n\n  add(key, interceptor) {\n    if (!(key in this.keyedInterceptors)) {\n      this.keyedInterceptors[key] = []\n    }\n    this.keyedInterceptors[key].push(interceptor)\n    addInterceptor(\n      this.basePath,\n      interceptor,\n      this,\n      this.scopeOptions,\n      this.urlParts.hostname\n    )\n  }\n\n  remove(key, interceptor) {\n    if (this._persist) {\n      return\n    }\n    const arr = this.keyedInterceptors[key]\n    if (arr) {\n      arr.splice(arr.indexOf(interceptor), 1)\n      if (arr.length === 0) {\n        delete this.keyedInterceptors[key]\n      }\n    }\n  }\n\n  intercept(uri, method, requestBody, interceptorOptions) {\n    const ic = new Interceptor(\n      this,\n      uri,\n      method,\n      requestBody,\n      interceptorOptions\n    )\n\n    this.interceptors.push(ic)\n    return ic\n  }\n\n  get(uri, requestBody, options) {\n    return this.intercept(uri, 'GET', requestBody, options)\n  }\n\n  post(uri, requestBody, options) {\n    return this.intercept(uri, 'POST', requestBody, options)\n  }\n\n  put(uri, requestBody, options) {\n    return this.intercept(uri, 'PUT', requestBody, options)\n  }\n\n  head(uri, requestBody, options) {\n    return this.intercept(uri, 'HEAD', requestBody, options)\n  }\n\n  patch(uri, requestBody, options) {\n    return this.intercept(uri, 'PATCH', requestBody, options)\n  }\n\n  merge(uri, requestBody, options) {\n    return this.intercept(uri, 'MERGE', requestBody, options)\n  }\n\n  delete(uri, requestBody, options) {\n    return this.intercept(uri, 'DELETE', requestBody, options)\n  }\n\n  options(uri, requestBody, options) {\n    return this.intercept(uri, 'OPTIONS', requestBody, options)\n  }\n\n  // Returns the list of keys for non-optional Interceptors that haven't been completed yet.\n  // TODO: This assumes that completed mocks are removed from the keyedInterceptors list\n  // (when persistence is off). We should change that (and this) in future.\n  pendingMocks() {\n    return this.activeMocks().filter(key =>\n      this.keyedInterceptors[key].some(({ interceptionCounter, optional }) => {\n        const persistedAndUsed = this._persist && interceptionCounter > 0\n        return !persistedAndUsed && !optional\n      })\n    )\n  }\n\n  // Returns all keyedInterceptors that are active.\n  // This includes incomplete interceptors, persisted but complete interceptors, and\n  // optional interceptors, but not non-persisted and completed interceptors.\n  activeMocks() {\n    return Object.keys(this.keyedInterceptors)\n  }\n\n  isDone() {\n    if (!isOn()) {\n      return true\n    }\n\n    return this.pendingMocks().length === 0\n  }\n\n  done() {\n    assert.ok(\n      this.isDone(),\n      `Mocks not yet satisfied:\\n${this.pendingMocks().join('\\n')}`\n    )\n  }\n\n  buildFilter() {\n    const filteringArguments = arguments\n\n    if (arguments[0] instanceof RegExp) {\n      return function (candidate) {\n        /* istanbul ignore if */\n        if (typeof candidate !== 'string') {\n          // Given the way nock is written, it seems like `candidate` will always\n          // be a string, regardless of what options might be passed to it.\n          // However the code used to contain a truthiness test of `candidate`.\n          // The check is being preserved for now.\n          throw Error(\n            `Nock internal assertion failed: typeof candidate is ${typeof candidate}. If you encounter this error, please report it as a bug.`\n          )\n        }\n        return candidate.replace(filteringArguments[0], filteringArguments[1])\n      }\n    } else if (typeof arguments[0] === 'function') {\n      return arguments[0]\n    }\n  }\n\n  filteringPath() {\n    this.transformPathFunction = this.buildFilter.apply(this, arguments)\n    if (!this.transformPathFunction) {\n      throw new Error(\n        'Invalid arguments: filtering path should be a function or a regular expression'\n      )\n    }\n    return this\n  }\n\n  filteringRequestBody() {\n    this.transformRequestBodyFunction = this.buildFilter.apply(this, arguments)\n    if (!this.transformRequestBodyFunction) {\n      throw new Error(\n        'Invalid arguments: filtering request body should be a function or a regular expression'\n      )\n    }\n    return this\n  }\n\n  matchHeader(name, value) {\n    //  We use lower-case header field names throughout Nock.\n    this.matchHeaders.push({ name: name.toLowerCase(), value })\n    return this\n  }\n\n  defaultReplyHeaders(headers) {\n    this._defaultReplyHeaders = common.headersInputToRawArray(headers)\n    return this\n  }\n\n  persist(flag = true) {\n    if (typeof flag !== 'boolean') {\n      throw new Error('Invalid arguments: argument should be a boolean')\n    }\n    this._persist = flag\n    return this\n  }\n\n  /**\n   * @private\n   * @returns {boolean}\n   */\n  shouldPersist() {\n    return this._persist\n  }\n\n  replyContentLength() {\n    this.contentLen = true\n    return this\n  }\n\n  replyDate(d) {\n    this.date = d || new Date()\n    return this\n  }\n}\n\nfunction loadDefs(path) {\n  if (!fs) {\n    throw new Error('No fs')\n  }\n\n  const contents = fs.readFileSync(path)\n  return JSON.parse(contents)\n}\n\nfunction load(path) {\n  return define(loadDefs(path))\n}\n\nfunction getStatusFromDefinition(nockDef) {\n  // Backward compatibility for when `status` was encoded as string in `reply`.\n  if (nockDef.reply !== undefined) {\n    const parsedReply = parseInt(nockDef.reply, 10)\n    if (isNaN(parsedReply)) {\n      throw Error('`reply`, when present, must be a numeric string')\n    }\n\n    return parsedReply\n  }\n\n  const DEFAULT_STATUS_OK = 200\n  return nockDef.status || DEFAULT_STATUS_OK\n}\n\nfunction getScopeFromDefinition(nockDef) {\n  //  Backward compatibility for when `port` was part of definition.\n  if (nockDef.port !== undefined) {\n    //  Include `port` into scope if it doesn't exist.\n    const options = url.parse(nockDef.scope)\n    if (options.port === null) {\n      return `${nockDef.scope}:${nockDef.port}`\n    } else {\n      if (parseInt(options.port) !== parseInt(nockDef.port)) {\n        throw new Error(\n          'Mismatched port numbers in scope and port properties of nock definition.'\n        )\n      }\n    }\n  }\n\n  return nockDef.scope\n}\n\nfunction tryJsonParse(string) {\n  try {\n    return JSON.parse(string)\n  } catch (err) {\n    return string\n  }\n}\n\nfunction define(nockDefs) {\n  const scopes = []\n\n  nockDefs.forEach(function (nockDef) {\n    const nscope = getScopeFromDefinition(nockDef)\n    const npath = nockDef.path\n    if (!nockDef.method) {\n      throw Error('Method is required')\n    }\n    const method = nockDef.method.toLowerCase()\n    const status = getStatusFromDefinition(nockDef)\n    const rawHeaders = nockDef.rawHeaders || []\n    const reqheaders = nockDef.reqheaders || {}\n    const badheaders = nockDef.badheaders || []\n    const options = { ...nockDef.options }\n\n    //  We use request headers for both filtering (see below) and mocking.\n    //  Here we are setting up mocked request headers but we don't want to\n    //  be changing the user's options object so we clone it first.\n    options.reqheaders = reqheaders\n    options.badheaders = badheaders\n\n    // Response is not always JSON as it could be a string or binary data or\n    // even an array of binary buffers (e.g. when content is encoded).\n    let response\n    if (!nockDef.response) {\n      response = ''\n      // TODO: Rename `responseIsBinary` to `responseIsUtf8Representable`.\n    } else if (nockDef.responseIsBinary) {\n      response = Buffer.from(nockDef.response, 'hex')\n    } else {\n      response =\n        typeof nockDef.response === 'string'\n          ? tryJsonParse(nockDef.response)\n          : nockDef.response\n    }\n\n    const scope = new Scope(nscope, options)\n\n    // If request headers were specified filter by them.\n    Object.entries(reqheaders).forEach(([fieldName, value]) => {\n      scope.matchHeader(fieldName, value)\n    })\n\n    const acceptableFilters = ['filteringRequestBody', 'filteringPath']\n    acceptableFilters.forEach(filter => {\n      if (nockDef[filter]) {\n        scope[filter](nockDef[filter])\n      }\n    })\n\n    scope\n      .intercept(npath, method, nockDef.body)\n      .reply(status, response, rawHeaders)\n\n    scopes.push(scope)\n  })\n\n  return scopes\n}\n\nmodule.exports = {\n  Scope,\n  load,\n  loadDefs,\n  define,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}