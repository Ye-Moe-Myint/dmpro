{"ast":null,"code":"'use strict';\n\n/**\n * @module nock/intercept\n */\nvar _toConsumableArray = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _require = require('./intercepted_request_router'),\n  InterceptedRequestRouter = _require.InterceptedRequestRouter;\nvar common = require('./common');\nvar _require2 = require('util'),\n  inherits = _require2.inherits;\nvar http = require('http');\nvar debug = require('debug')('nock.intercept');\nvar globalEmitter = require('./global_emitter');\n\n/**\n * @name NetConnectNotAllowedError\n * @private\n * @desc Error trying to make a connection when disabled external access.\n * @class\n * @example\n * nock.disableNetConnect();\n * http.get('http://zombo.com');\n * // throw NetConnectNotAllowedError\n */\nfunction NetConnectNotAllowedError(host, path) {\n  Error.call(this);\n  this.name = 'NetConnectNotAllowedError';\n  this.code = 'ENETUNREACH';\n  this.message = \"Nock: Disallowed net connect for \\\"\".concat(host).concat(path, \"\\\"\");\n  Error.captureStackTrace(this, this.constructor);\n}\ninherits(NetConnectNotAllowedError, Error);\nvar allInterceptors = {};\nvar allowNetConnect;\n\n/**\n * Enabled real request.\n * @public\n * @param {String|RegExp} matcher=RegExp.new('.*') Expression to match\n * @example\n * // Enables all real requests\n * nock.enableNetConnect();\n * @example\n * // Enables real requests for url that matches google\n * nock.enableNetConnect('google');\n * @example\n * // Enables real requests for url that matches google and amazon\n * nock.enableNetConnect(/(google|amazon)/);\n * @example\n * // Enables real requests for url that includes google\n * nock.enableNetConnect(host => host.includes('google'));\n */\nfunction enableNetConnect(matcher) {\n  if (typeof matcher === 'string') {\n    allowNetConnect = new RegExp(matcher);\n  } else if (matcher instanceof RegExp) {\n    allowNetConnect = matcher;\n  } else if (typeof matcher === 'function') {\n    allowNetConnect = {\n      test: matcher\n    };\n  } else {\n    allowNetConnect = /.*/;\n  }\n}\nfunction isEnabledForNetConnect(options) {\n  common.normalizeRequestOptions(options);\n  var enabled = allowNetConnect && allowNetConnect.test(options.host);\n  debug('Net connect', enabled ? '' : 'not', 'enabled for', options.host);\n  return enabled;\n}\n\n/**\n * Disable all real requests.\n * @public\n * @example\n * nock.disableNetConnect();\n */\nfunction disableNetConnect() {\n  allowNetConnect = undefined;\n}\nfunction isOn() {\n  return !isOff();\n}\nfunction isOff() {\n  return process.env.NOCK_OFF === 'true';\n}\nfunction addInterceptor(key, interceptor, scope, scopeOptions, host) {\n  if (!(key in allInterceptors)) {\n    allInterceptors[key] = {\n      key: key,\n      interceptors: []\n    };\n  }\n  interceptor.__nock_scope = scope;\n\n  //  We need scope's key and scope options for scope filtering function (if defined)\n  interceptor.__nock_scopeKey = key;\n  interceptor.__nock_scopeOptions = scopeOptions;\n  //  We need scope's host for setting correct request headers for filtered scopes.\n  interceptor.__nock_scopeHost = host;\n  interceptor.interceptionCounter = 0;\n  if (scopeOptions.allowUnmocked) allInterceptors[key].allowUnmocked = true;\n  allInterceptors[key].interceptors.push(interceptor);\n}\nfunction remove(interceptor) {\n  if (interceptor.__nock_scope.shouldPersist() || --interceptor.counter > 0) {\n    return;\n  }\n  var basePath = interceptor.basePath;\n  var interceptors = allInterceptors[basePath] && allInterceptors[basePath].interceptors || [];\n\n  // TODO: There is a clearer way to write that we want to delete the first\n  // matching instance. I'm also not sure why we couldn't delete _all_\n  // matching instances.\n  interceptors.some(function (thisInterceptor, i) {\n    return thisInterceptor === interceptor ? interceptors.splice(i, 1) : false;\n  });\n}\nfunction removeAll() {\n  Object.keys(allInterceptors).forEach(function (key) {\n    allInterceptors[key].interceptors.forEach(function (interceptor) {\n      interceptor.scope.keyedInterceptors = {};\n    });\n  });\n  allInterceptors = {};\n}\n\n/**\n * Return all the Interceptors whose Scopes match against the base path of the provided options.\n *\n * @returns {Interceptor[]}\n */\nfunction interceptorsFor(options) {\n  common.normalizeRequestOptions(options);\n  debug('interceptors for %j', options.host);\n  var basePath = \"\".concat(options.proto, \"://\").concat(options.host);\n  debug('filtering interceptors for basepath', basePath);\n\n  // First try to use filteringScope if any of the interceptors has it defined.\n  for (var _i = 0, _Object$values = Object.values(allInterceptors); _i < _Object$values.length; _i++) {\n    var _Object$values$_i = _Object$values[_i],\n      key = _Object$values$_i.key,\n      interceptors = _Object$values$_i.interceptors,\n      allowUnmocked = _Object$values$_i.allowUnmocked;\n    var _iterator = _createForOfIteratorHelper(interceptors),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var interceptor = _step.value;\n        var filteringScope = interceptor.__nock_scopeOptions.filteringScope;\n\n        // If scope filtering function is defined and returns a truthy value then\n        // we have to treat this as a match.\n        if (filteringScope && filteringScope(basePath)) {\n          interceptor.scope.logger('found matching scope interceptor');\n\n          // Keep the filtered scope (its key) to signal the rest of the module\n          // that this wasn't an exact but filtered match.\n          interceptors.forEach(function (ic) {\n            ic.__nock_filteredScope = ic.__nock_scopeKey;\n          });\n          return interceptors;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (common.matchStringOrRegexp(basePath, key)) {\n      if (allowUnmocked && interceptors.length === 0) {\n        debug('matched base path with allowUnmocked (no matching interceptors)');\n        return [{\n          options: {\n            allowUnmocked: true\n          },\n          matchOrigin: function matchOrigin() {\n            return false;\n          }\n        }];\n      } else {\n        debug(\"matched base path (\".concat(interceptors.length, \" interceptor\").concat(interceptors.length > 1 ? 's' : '', \")\"));\n        return interceptors;\n      }\n    }\n  }\n  return undefined;\n}\nfunction removeInterceptor(options) {\n  // Lazily import to avoid circular imports.\n  var Interceptor = require('./interceptor');\n  var baseUrl, key, method, proto;\n  if (options instanceof Interceptor) {\n    baseUrl = options.basePath;\n    key = options._key;\n  } else {\n    proto = options.proto ? options.proto : 'http';\n    common.normalizeRequestOptions(options);\n    baseUrl = \"\".concat(proto, \"://\").concat(options.host);\n    method = options.method && options.method.toUpperCase() || 'GET';\n    key = \"\".concat(method, \" \").concat(baseUrl).concat(options.path || '/');\n  }\n  if (allInterceptors[baseUrl] && allInterceptors[baseUrl].interceptors.length > 0) {\n    for (var i = 0; i < allInterceptors[baseUrl].interceptors.length; i++) {\n      var interceptor = allInterceptors[baseUrl].interceptors[i];\n      if (interceptor._key === key) {\n        allInterceptors[baseUrl].interceptors.splice(i, 1);\n        interceptor.scope.remove(key, interceptor);\n        break;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n//  Variable where we keep the ClientRequest we have overridden\n//  (which might or might not be node's original http.ClientRequest)\nvar originalClientRequest;\nfunction ErroringClientRequest(error) {\n  http.OutgoingMessage.call(this);\n  process.nextTick(function () {\n    this.emit('error', error);\n  }.bind(this));\n}\ninherits(ErroringClientRequest, http.ClientRequest);\nfunction overrideClientRequest() {\n  // Here's some background discussion about overriding ClientRequest:\n  // - https://github.com/nodejitsu/mock-request/issues/4\n  // - https://github.com/nock/nock/issues/26\n  // It would be good to add a comment that explains this more clearly.\n  debug('Overriding ClientRequest');\n\n  // ----- Extending http.ClientRequest\n\n  //  Define the overriding client request that nock uses internally.\n  function OverriddenClientRequest() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var _common$normalizeClie = common.normalizeClientRequestArgs.apply(common, args),\n      options = _common$normalizeClie.options,\n      callback = _common$normalizeClie.callback;\n    if (Object.keys(options).length === 0) {\n      // As weird as it is, it's possible to call `http.request` without\n      // options, and it makes a request to localhost or somesuch. We should\n      // support it too, for parity. However it doesn't work today, and fixing\n      // it seems low priority. Giving an explicit error is nicer than\n      // crashing with a weird stack trace. `http[s].request()`, nock's other\n      // client-facing entry point, makes a similar check.\n      // https://github.com/nock/nock/pull/1386\n      // https://github.com/nock/nock/pull/1440\n      throw Error('Creating a ClientRequest with empty `options` is not supported in Nock');\n    }\n    http.OutgoingMessage.call(this);\n\n    //  Filter the interceptors per request options.\n    var interceptors = interceptorsFor(options);\n    if (isOn() && interceptors) {\n      debug('using', interceptors.length, 'interceptors');\n\n      //  Use filtered interceptors to intercept requests.\n      // TODO: this shouldn't be a class anymore\n      // the overrider explicitly overrides methods and attrs on the request so the `assign` below should be removed.\n      var overrider = new InterceptedRequestRouter({\n        req: this,\n        options: options,\n        interceptors: interceptors\n      });\n      Object.assign(this, overrider);\n      if (callback) {\n        this.once('response', callback);\n      }\n    } else {\n      debug('falling back to original ClientRequest');\n\n      //  Fallback to original ClientRequest if nock is off or the net connection is enabled.\n      if (isOff() || isEnabledForNetConnect(options)) {\n        originalClientRequest.apply(this, arguments);\n      } else {\n        common.setImmediate(function () {\n          var error = new NetConnectNotAllowedError(options.host, options.path);\n          this.emit('error', error);\n        }.bind(this));\n      }\n    }\n  }\n  inherits(OverriddenClientRequest, http.ClientRequest);\n\n  //  Override the http module's request but keep the original so that we can use it and later restore it.\n  //  NOTE: We only override http.ClientRequest as https module also uses it.\n  originalClientRequest = http.ClientRequest;\n  http.ClientRequest = OverriddenClientRequest;\n  debug('ClientRequest overridden');\n}\nfunction restoreOverriddenClientRequest() {\n  debug('restoring overridden ClientRequest');\n\n  //  Restore the ClientRequest we have overridden.\n  if (!originalClientRequest) {\n    debug('- ClientRequest was not overridden');\n  } else {\n    http.ClientRequest = originalClientRequest;\n    originalClientRequest = undefined;\n    debug('- ClientRequest restored');\n  }\n}\nfunction isActive() {\n  //  If ClientRequest has been overwritten by Nock then originalClientRequest is not undefined.\n  //  This means that Nock has been activated.\n  return originalClientRequest !== undefined;\n}\nfunction interceptorScopes() {\n  var _ref;\n  var nestedInterceptors = Object.values(allInterceptors).map(function (i) {\n    return i.interceptors;\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(nestedInterceptors)).map(function (i) {\n    return i.scope;\n  });\n}\nfunction isDone() {\n  return interceptorScopes().every(function (scope) {\n    return scope.isDone();\n  });\n}\nfunction pendingMocks() {\n  var _ref2;\n  return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(interceptorScopes().map(function (scope) {\n    return scope.pendingMocks();\n  })));\n}\nfunction activeMocks() {\n  var _ref3;\n  return (_ref3 = []).concat.apply(_ref3, _toConsumableArray(interceptorScopes().map(function (scope) {\n    return scope.activeMocks();\n  })));\n}\nfunction activate() {\n  if (originalClientRequest) {\n    throw new Error('Nock already active');\n  }\n  overrideClientRequest();\n\n  // ----- Overriding http.request and https.request:\n\n  common.overrideRequests(function (proto, overriddenRequest, args) {\n    //  NOTE: overriddenRequest is already bound to its module.\n\n    var _common$normalizeClie2 = common.normalizeClientRequestArgs.apply(common, _toConsumableArray(args)),\n      options = _common$normalizeClie2.options,\n      callback = _common$normalizeClie2.callback;\n    if (Object.keys(options).length === 0) {\n      // As weird as it is, it's possible to call `http.request` without\n      // options, and it makes a request to localhost or somesuch. We should\n      // support it too, for parity. However it doesn't work today, and fixing\n      // it seems low priority. Giving an explicit error is nicer than\n      // crashing with a weird stack trace. `new ClientRequest()`, nock's\n      // other client-facing entry point, makes a similar check.\n      // https://github.com/nock/nock/pull/1386\n      // https://github.com/nock/nock/pull/1440\n      throw Error('Making a request with empty `options` is not supported in Nock');\n    }\n\n    // The option per the docs is `protocol`. Its unclear if this line is meant to override that and is misspelled or if\n    // the intend is to explicitly keep track of which module was called using a separate name.\n    // Either way, `proto` is used as the source of truth from here on out.\n    options.proto = proto;\n    var interceptors = interceptorsFor(options);\n    if (isOn() && interceptors) {\n      var matches = interceptors.some(function (interceptor) {\n        return interceptor.matchOrigin(options);\n      });\n      var allowUnmocked = interceptors.some(function (interceptor) {\n        return interceptor.options.allowUnmocked;\n      });\n      if (!matches && allowUnmocked) {\n        var req;\n        if (proto === 'https') {\n          var ClientRequest = http.ClientRequest;\n          http.ClientRequest = originalClientRequest;\n          req = overriddenRequest(options, callback);\n          http.ClientRequest = ClientRequest;\n        } else {\n          req = overriddenRequest(options, callback);\n        }\n        globalEmitter.emit('no match', req);\n        return req;\n      }\n\n      //  NOTE: Since we already overrode the http.ClientRequest we are in fact constructing\n      //    our own OverriddenClientRequest.\n      return new http.ClientRequest(options, callback);\n    } else {\n      globalEmitter.emit('no match', options);\n      if (isOff() || isEnabledForNetConnect(options)) {\n        return overriddenRequest(options, callback);\n      } else {\n        var error = new NetConnectNotAllowedError(options.host, options.path);\n        return new ErroringClientRequest(error);\n      }\n    }\n  });\n}\nmodule.exports = {\n  addInterceptor: addInterceptor,\n  remove: remove,\n  removeAll: removeAll,\n  removeInterceptor: removeInterceptor,\n  isOn: isOn,\n  activate: activate,\n  isActive: isActive,\n  isDone: isDone,\n  pendingMocks: pendingMocks,\n  activeMocks: activeMocks,\n  enableNetConnect: enableNetConnect,\n  disableNetConnect: disableNetConnect,\n  restoreOverriddenClientRequest: restoreOverriddenClientRequest,\n  abortPendingRequests: common.removeAllTimers\n};","map":{"version":3,"names":["require","InterceptedRequestRouter","common","inherits","http","debug","globalEmitter","NetConnectNotAllowedError","host","path","Error","call","name","code","message","captureStackTrace","constructor","allInterceptors","allowNetConnect","enableNetConnect","matcher","RegExp","test","isEnabledForNetConnect","options","normalizeRequestOptions","enabled","disableNetConnect","undefined","isOn","isOff","process","env","NOCK_OFF","addInterceptor","key","interceptor","scope","scopeOptions","interceptors","__nock_scope","__nock_scopeKey","__nock_scopeOptions","__nock_scopeHost","interceptionCounter","allowUnmocked","push","remove","shouldPersist","counter","basePath","some","thisInterceptor","i","splice","removeAll","Object","keys","forEach","keyedInterceptors","interceptorsFor","proto","values","filteringScope","logger","ic","__nock_filteredScope","matchStringOrRegexp","length","matchOrigin","removeInterceptor","Interceptor","baseUrl","method","_key","toUpperCase","originalClientRequest","ErroringClientRequest","error","OutgoingMessage","nextTick","emit","bind","ClientRequest","overrideClientRequest","OverriddenClientRequest","args","normalizeClientRequestArgs","callback","overrider","req","assign","once","apply","arguments","setImmediate","restoreOverriddenClientRequest","isActive","interceptorScopes","nestedInterceptors","map","concat","isDone","every","pendingMocks","activeMocks","activate","overrideRequests","overriddenRequest","matches","module","exports","abortPendingRequests","removeAllTimers"],"sources":["/Users/lieo/diabetes/CUT2DMTest/node_modules/nock/lib/intercept.js"],"sourcesContent":["'use strict'\n\n/**\n * @module nock/intercept\n */\n\nconst { InterceptedRequestRouter } = require('./intercepted_request_router')\nconst common = require('./common')\nconst { inherits } = require('util')\nconst http = require('http')\nconst debug = require('debug')('nock.intercept')\nconst globalEmitter = require('./global_emitter')\n\n/**\n * @name NetConnectNotAllowedError\n * @private\n * @desc Error trying to make a connection when disabled external access.\n * @class\n * @example\n * nock.disableNetConnect();\n * http.get('http://zombo.com');\n * // throw NetConnectNotAllowedError\n */\nfunction NetConnectNotAllowedError(host, path) {\n  Error.call(this)\n\n  this.name = 'NetConnectNotAllowedError'\n  this.code = 'ENETUNREACH'\n  this.message = `Nock: Disallowed net connect for \"${host}${path}\"`\n\n  Error.captureStackTrace(this, this.constructor)\n}\n\ninherits(NetConnectNotAllowedError, Error)\n\nlet allInterceptors = {}\nlet allowNetConnect\n\n/**\n * Enabled real request.\n * @public\n * @param {String|RegExp} matcher=RegExp.new('.*') Expression to match\n * @example\n * // Enables all real requests\n * nock.enableNetConnect();\n * @example\n * // Enables real requests for url that matches google\n * nock.enableNetConnect('google');\n * @example\n * // Enables real requests for url that matches google and amazon\n * nock.enableNetConnect(/(google|amazon)/);\n * @example\n * // Enables real requests for url that includes google\n * nock.enableNetConnect(host => host.includes('google'));\n */\nfunction enableNetConnect(matcher) {\n  if (typeof matcher === 'string') {\n    allowNetConnect = new RegExp(matcher)\n  } else if (matcher instanceof RegExp) {\n    allowNetConnect = matcher\n  } else if (typeof matcher === 'function') {\n    allowNetConnect = { test: matcher }\n  } else {\n    allowNetConnect = /.*/\n  }\n}\n\nfunction isEnabledForNetConnect(options) {\n  common.normalizeRequestOptions(options)\n\n  const enabled = allowNetConnect && allowNetConnect.test(options.host)\n  debug('Net connect', enabled ? '' : 'not', 'enabled for', options.host)\n  return enabled\n}\n\n/**\n * Disable all real requests.\n * @public\n * @example\n * nock.disableNetConnect();\n */\nfunction disableNetConnect() {\n  allowNetConnect = undefined\n}\n\nfunction isOn() {\n  return !isOff()\n}\n\nfunction isOff() {\n  return process.env.NOCK_OFF === 'true'\n}\n\nfunction addInterceptor(key, interceptor, scope, scopeOptions, host) {\n  if (!(key in allInterceptors)) {\n    allInterceptors[key] = { key, interceptors: [] }\n  }\n  interceptor.__nock_scope = scope\n\n  //  We need scope's key and scope options for scope filtering function (if defined)\n  interceptor.__nock_scopeKey = key\n  interceptor.__nock_scopeOptions = scopeOptions\n  //  We need scope's host for setting correct request headers for filtered scopes.\n  interceptor.__nock_scopeHost = host\n  interceptor.interceptionCounter = 0\n\n  if (scopeOptions.allowUnmocked) allInterceptors[key].allowUnmocked = true\n\n  allInterceptors[key].interceptors.push(interceptor)\n}\n\nfunction remove(interceptor) {\n  if (interceptor.__nock_scope.shouldPersist() || --interceptor.counter > 0) {\n    return\n  }\n\n  const { basePath } = interceptor\n  const interceptors =\n    (allInterceptors[basePath] && allInterceptors[basePath].interceptors) || []\n\n  // TODO: There is a clearer way to write that we want to delete the first\n  // matching instance. I'm also not sure why we couldn't delete _all_\n  // matching instances.\n  interceptors.some(function (thisInterceptor, i) {\n    return thisInterceptor === interceptor ? interceptors.splice(i, 1) : false\n  })\n}\n\nfunction removeAll() {\n  Object.keys(allInterceptors).forEach(function (key) {\n    allInterceptors[key].interceptors.forEach(function (interceptor) {\n      interceptor.scope.keyedInterceptors = {}\n    })\n  })\n  allInterceptors = {}\n}\n\n/**\n * Return all the Interceptors whose Scopes match against the base path of the provided options.\n *\n * @returns {Interceptor[]}\n */\nfunction interceptorsFor(options) {\n  common.normalizeRequestOptions(options)\n\n  debug('interceptors for %j', options.host)\n\n  const basePath = `${options.proto}://${options.host}`\n\n  debug('filtering interceptors for basepath', basePath)\n\n  // First try to use filteringScope if any of the interceptors has it defined.\n  for (const { key, interceptors, allowUnmocked } of Object.values(\n    allInterceptors\n  )) {\n    for (const interceptor of interceptors) {\n      const { filteringScope } = interceptor.__nock_scopeOptions\n\n      // If scope filtering function is defined and returns a truthy value then\n      // we have to treat this as a match.\n      if (filteringScope && filteringScope(basePath)) {\n        interceptor.scope.logger('found matching scope interceptor')\n\n        // Keep the filtered scope (its key) to signal the rest of the module\n        // that this wasn't an exact but filtered match.\n        interceptors.forEach(ic => {\n          ic.__nock_filteredScope = ic.__nock_scopeKey\n        })\n        return interceptors\n      }\n    }\n\n    if (common.matchStringOrRegexp(basePath, key)) {\n      if (allowUnmocked && interceptors.length === 0) {\n        debug('matched base path with allowUnmocked (no matching interceptors)')\n        return [\n          {\n            options: { allowUnmocked: true },\n            matchOrigin() {\n              return false\n            },\n          },\n        ]\n      } else {\n        debug(\n          `matched base path (${interceptors.length} interceptor${\n            interceptors.length > 1 ? 's' : ''\n          })`\n        )\n        return interceptors\n      }\n    }\n  }\n\n  return undefined\n}\n\nfunction removeInterceptor(options) {\n  // Lazily import to avoid circular imports.\n  const Interceptor = require('./interceptor')\n\n  let baseUrl, key, method, proto\n  if (options instanceof Interceptor) {\n    baseUrl = options.basePath\n    key = options._key\n  } else {\n    proto = options.proto ? options.proto : 'http'\n\n    common.normalizeRequestOptions(options)\n    baseUrl = `${proto}://${options.host}`\n    method = (options.method && options.method.toUpperCase()) || 'GET'\n    key = `${method} ${baseUrl}${options.path || '/'}`\n  }\n\n  if (\n    allInterceptors[baseUrl] &&\n    allInterceptors[baseUrl].interceptors.length > 0\n  ) {\n    for (let i = 0; i < allInterceptors[baseUrl].interceptors.length; i++) {\n      const interceptor = allInterceptors[baseUrl].interceptors[i]\n      if (interceptor._key === key) {\n        allInterceptors[baseUrl].interceptors.splice(i, 1)\n        interceptor.scope.remove(key, interceptor)\n        break\n      }\n    }\n\n    return true\n  }\n\n  return false\n}\n//  Variable where we keep the ClientRequest we have overridden\n//  (which might or might not be node's original http.ClientRequest)\nlet originalClientRequest\n\nfunction ErroringClientRequest(error) {\n  http.OutgoingMessage.call(this)\n  process.nextTick(\n    function () {\n      this.emit('error', error)\n    }.bind(this)\n  )\n}\n\ninherits(ErroringClientRequest, http.ClientRequest)\n\nfunction overrideClientRequest() {\n  // Here's some background discussion about overriding ClientRequest:\n  // - https://github.com/nodejitsu/mock-request/issues/4\n  // - https://github.com/nock/nock/issues/26\n  // It would be good to add a comment that explains this more clearly.\n  debug('Overriding ClientRequest')\n\n  // ----- Extending http.ClientRequest\n\n  //  Define the overriding client request that nock uses internally.\n  function OverriddenClientRequest(...args) {\n    const { options, callback } = common.normalizeClientRequestArgs(...args)\n\n    if (Object.keys(options).length === 0) {\n      // As weird as it is, it's possible to call `http.request` without\n      // options, and it makes a request to localhost or somesuch. We should\n      // support it too, for parity. However it doesn't work today, and fixing\n      // it seems low priority. Giving an explicit error is nicer than\n      // crashing with a weird stack trace. `http[s].request()`, nock's other\n      // client-facing entry point, makes a similar check.\n      // https://github.com/nock/nock/pull/1386\n      // https://github.com/nock/nock/pull/1440\n      throw Error(\n        'Creating a ClientRequest with empty `options` is not supported in Nock'\n      )\n    }\n\n    http.OutgoingMessage.call(this)\n\n    //  Filter the interceptors per request options.\n    const interceptors = interceptorsFor(options)\n\n    if (isOn() && interceptors) {\n      debug('using', interceptors.length, 'interceptors')\n\n      //  Use filtered interceptors to intercept requests.\n      // TODO: this shouldn't be a class anymore\n      // the overrider explicitly overrides methods and attrs on the request so the `assign` below should be removed.\n      const overrider = new InterceptedRequestRouter({\n        req: this,\n        options,\n        interceptors,\n      })\n      Object.assign(this, overrider)\n\n      if (callback) {\n        this.once('response', callback)\n      }\n    } else {\n      debug('falling back to original ClientRequest')\n\n      //  Fallback to original ClientRequest if nock is off or the net connection is enabled.\n      if (isOff() || isEnabledForNetConnect(options)) {\n        originalClientRequest.apply(this, arguments)\n      } else {\n        common.setImmediate(\n          function () {\n            const error = new NetConnectNotAllowedError(\n              options.host,\n              options.path\n            )\n            this.emit('error', error)\n          }.bind(this)\n        )\n      }\n    }\n  }\n  inherits(OverriddenClientRequest, http.ClientRequest)\n\n  //  Override the http module's request but keep the original so that we can use it and later restore it.\n  //  NOTE: We only override http.ClientRequest as https module also uses it.\n  originalClientRequest = http.ClientRequest\n  http.ClientRequest = OverriddenClientRequest\n\n  debug('ClientRequest overridden')\n}\n\nfunction restoreOverriddenClientRequest() {\n  debug('restoring overridden ClientRequest')\n\n  //  Restore the ClientRequest we have overridden.\n  if (!originalClientRequest) {\n    debug('- ClientRequest was not overridden')\n  } else {\n    http.ClientRequest = originalClientRequest\n    originalClientRequest = undefined\n\n    debug('- ClientRequest restored')\n  }\n}\n\nfunction isActive() {\n  //  If ClientRequest has been overwritten by Nock then originalClientRequest is not undefined.\n  //  This means that Nock has been activated.\n  return originalClientRequest !== undefined\n}\n\nfunction interceptorScopes() {\n  const nestedInterceptors = Object.values(allInterceptors).map(\n    i => i.interceptors\n  )\n  return [].concat(...nestedInterceptors).map(i => i.scope)\n}\n\nfunction isDone() {\n  return interceptorScopes().every(scope => scope.isDone())\n}\n\nfunction pendingMocks() {\n  return [].concat(...interceptorScopes().map(scope => scope.pendingMocks()))\n}\n\nfunction activeMocks() {\n  return [].concat(...interceptorScopes().map(scope => scope.activeMocks()))\n}\n\nfunction activate() {\n  if (originalClientRequest) {\n    throw new Error('Nock already active')\n  }\n\n  overrideClientRequest()\n\n  // ----- Overriding http.request and https.request:\n\n  common.overrideRequests(function (proto, overriddenRequest, args) {\n    //  NOTE: overriddenRequest is already bound to its module.\n\n    const { options, callback } = common.normalizeClientRequestArgs(...args)\n\n    if (Object.keys(options).length === 0) {\n      // As weird as it is, it's possible to call `http.request` without\n      // options, and it makes a request to localhost or somesuch. We should\n      // support it too, for parity. However it doesn't work today, and fixing\n      // it seems low priority. Giving an explicit error is nicer than\n      // crashing with a weird stack trace. `new ClientRequest()`, nock's\n      // other client-facing entry point, makes a similar check.\n      // https://github.com/nock/nock/pull/1386\n      // https://github.com/nock/nock/pull/1440\n      throw Error(\n        'Making a request with empty `options` is not supported in Nock'\n      )\n    }\n\n    // The option per the docs is `protocol`. Its unclear if this line is meant to override that and is misspelled or if\n    // the intend is to explicitly keep track of which module was called using a separate name.\n    // Either way, `proto` is used as the source of truth from here on out.\n    options.proto = proto\n\n    const interceptors = interceptorsFor(options)\n\n    if (isOn() && interceptors) {\n      const matches = interceptors.some(interceptor =>\n        interceptor.matchOrigin(options)\n      )\n      const allowUnmocked = interceptors.some(\n        interceptor => interceptor.options.allowUnmocked\n      )\n\n      if (!matches && allowUnmocked) {\n        let req\n        if (proto === 'https') {\n          const { ClientRequest } = http\n          http.ClientRequest = originalClientRequest\n          req = overriddenRequest(options, callback)\n          http.ClientRequest = ClientRequest\n        } else {\n          req = overriddenRequest(options, callback)\n        }\n        globalEmitter.emit('no match', req)\n        return req\n      }\n\n      //  NOTE: Since we already overrode the http.ClientRequest we are in fact constructing\n      //    our own OverriddenClientRequest.\n      return new http.ClientRequest(options, callback)\n    } else {\n      globalEmitter.emit('no match', options)\n      if (isOff() || isEnabledForNetConnect(options)) {\n        return overriddenRequest(options, callback)\n      } else {\n        const error = new NetConnectNotAllowedError(options.host, options.path)\n        return new ErroringClientRequest(error)\n      }\n    }\n  })\n}\n\nmodule.exports = {\n  addInterceptor,\n  remove,\n  removeAll,\n  removeInterceptor,\n  isOn,\n  activate,\n  isActive,\n  isDone,\n  pendingMocks,\n  activeMocks,\n  enableNetConnect,\n  disableNetConnect,\n  restoreOverriddenClientRequest,\n  abortPendingRequests: common.removeAllTimers,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}