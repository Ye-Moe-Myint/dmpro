{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _require = require('events'),\n  EventEmitter = _require.EventEmitter;\nvar debug = require('debug')('nock.socket');\nmodule.exports = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Socket, _EventEmitter);\n  var _super = _createSuper(Socket);\n  function Socket(options) {\n    var _this;\n    _classCallCheck(this, Socket);\n    _this = _super.call(this);\n\n    // Pretend this is a TLSSocket\n    if (options.proto === 'https') {\n      // https://github.com/nock/nock/issues/158\n      _this.authorized = true;\n      // https://github.com/nock/nock/issues/2147\n      _this.encrypted = true;\n    }\n    _this.bufferSize = 0;\n    _this.writableLength = 0;\n    _this.writable = true;\n    _this.readable = true;\n    _this.pending = false;\n    _this.destroyed = false;\n    _this.connecting = true;\n\n    // Undocumented flag used by ClientRequest to ensure errors aren't double-fired\n    _this._hadError = false;\n\n    // Maximum allowed delay. 0 means unlimited.\n    _this.timeout = 0;\n    var ipv6 = options.family === 6;\n    _this.remoteFamily = ipv6 ? 'IPv6' : 'IPv4';\n    _this.localAddress = _this.remoteAddress = ipv6 ? '::1' : '127.0.0.1';\n    _this.localPort = _this.remotePort = parseInt(options.port);\n    return _this;\n  }\n  _createClass(Socket, [{\n    key: \"setNoDelay\",\n    value: function setNoDelay() {}\n  }, {\n    key: \"setKeepAlive\",\n    value: function setKeepAlive() {}\n  }, {\n    key: \"resume\",\n    value: function resume() {}\n  }, {\n    key: \"ref\",\n    value: function ref() {}\n  }, {\n    key: \"unref\",\n    value: function unref() {}\n  }, {\n    key: \"address\",\n    value: function address() {\n      return {\n        port: this.remotePort,\n        family: this.remoteFamily,\n        address: this.remoteAddress\n      };\n    }\n  }, {\n    key: \"setTimeout\",\n    value: function setTimeout(timeoutMs, fn) {\n      this.timeout = timeoutMs;\n      if (fn) {\n        this.once('timeout', fn);\n      }\n      return this;\n    }\n\n    /**\n     * Artificial delay that will trip socket timeouts when appropriate.\n     *\n     * Doesn't actually wait for time to pass.\n     * Timeout events don't necessarily end the request.\n     * While many clients choose to abort the request upon a timeout, Node itself does not.\n     */\n  }, {\n    key: \"applyDelay\",\n    value: function applyDelay(delayMs) {\n      if (this.timeout && delayMs > this.timeout) {\n        debug('socket timeout');\n        this.emit('timeout');\n      }\n    }\n  }, {\n    key: \"getPeerCertificate\",\n    value: function getPeerCertificate() {\n      return Buffer.from((Math.random() * 10000 + Date.now()).toString()).toString('base64');\n    }\n\n    /**\n     * Denotes that no more I/O activity should happen on this socket.\n     *\n     * The implementation in Node if far more complex as it juggles underlying async streams.\n     * For the purposes of Nock, we just need it to set some flags and on the first call\n     * emit a 'close' and optional 'error' event. Both events propagate through the request object.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy(err) {\n      var _this2 = this;\n      if (this.destroyed) {\n        return this;\n      }\n      debug('socket destroy');\n      this.destroyed = true;\n      this.readable = this.writable = false;\n      this.readableEnded = this.writableFinished = true;\n      process.nextTick(function () {\n        if (err) {\n          _this2._hadError = true;\n          _this2.emit('error', err);\n        }\n        _this2.emit('close');\n      });\n      return this;\n    }\n  }]);\n  return Socket;\n}(EventEmitter);","map":{"version":3,"names":["require","EventEmitter","debug","module","exports","options","proto","authorized","encrypted","bufferSize","writableLength","writable","readable","pending","destroyed","connecting","_hadError","timeout","ipv6","family","remoteFamily","localAddress","remoteAddress","localPort","remotePort","parseInt","port","address","timeoutMs","fn","once","delayMs","emit","Buffer","from","Math","random","Date","now","toString","err","readableEnded","writableFinished","process","nextTick"],"sources":["/Users/lieo/diabetes/CUT2DMTest/node_modules/nock/lib/socket.js"],"sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst debug = require('debug')('nock.socket')\n\nmodule.exports = class Socket extends EventEmitter {\n  constructor(options) {\n    super()\n\n    // Pretend this is a TLSSocket\n    if (options.proto === 'https') {\n      // https://github.com/nock/nock/issues/158\n      this.authorized = true\n      // https://github.com/nock/nock/issues/2147\n      this.encrypted = true\n    }\n\n    this.bufferSize = 0\n    this.writableLength = 0\n    this.writable = true\n    this.readable = true\n    this.pending = false\n    this.destroyed = false\n    this.connecting = true\n\n    // Undocumented flag used by ClientRequest to ensure errors aren't double-fired\n    this._hadError = false\n\n    // Maximum allowed delay. 0 means unlimited.\n    this.timeout = 0\n\n    const ipv6 = options.family === 6\n    this.remoteFamily = ipv6 ? 'IPv6' : 'IPv4'\n    this.localAddress = this.remoteAddress = ipv6 ? '::1' : '127.0.0.1'\n    this.localPort = this.remotePort = parseInt(options.port)\n  }\n\n  setNoDelay() {}\n  setKeepAlive() {}\n  resume() {}\n  ref() {}\n  unref() {}\n\n  address() {\n    return {\n      port: this.remotePort,\n      family: this.remoteFamily,\n      address: this.remoteAddress,\n    }\n  }\n\n  setTimeout(timeoutMs, fn) {\n    this.timeout = timeoutMs\n    if (fn) {\n      this.once('timeout', fn)\n    }\n    return this\n  }\n\n  /**\n   * Artificial delay that will trip socket timeouts when appropriate.\n   *\n   * Doesn't actually wait for time to pass.\n   * Timeout events don't necessarily end the request.\n   * While many clients choose to abort the request upon a timeout, Node itself does not.\n   */\n  applyDelay(delayMs) {\n    if (this.timeout && delayMs > this.timeout) {\n      debug('socket timeout')\n      this.emit('timeout')\n    }\n  }\n\n  getPeerCertificate() {\n    return Buffer.from(\n      (Math.random() * 10000 + Date.now()).toString()\n    ).toString('base64')\n  }\n\n  /**\n   * Denotes that no more I/O activity should happen on this socket.\n   *\n   * The implementation in Node if far more complex as it juggles underlying async streams.\n   * For the purposes of Nock, we just need it to set some flags and on the first call\n   * emit a 'close' and optional 'error' event. Both events propagate through the request object.\n   */\n  destroy(err) {\n    if (this.destroyed) {\n      return this\n    }\n\n    debug('socket destroy')\n    this.destroyed = true\n    this.readable = this.writable = false\n    this.readableEnded = this.writableFinished = true\n\n    process.nextTick(() => {\n      if (err) {\n        this._hadError = true\n        this.emit('error', err)\n      }\n      this.emit('close')\n    })\n\n    return this\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}