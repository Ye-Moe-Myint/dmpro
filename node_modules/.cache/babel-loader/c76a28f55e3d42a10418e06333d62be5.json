{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _toConsumableArray = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _objectSpread = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/lieo/diabetes/CUT2DMTest/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar stringify = require('json-stringify-safe');\nvar querystring = require('querystring');\nvar _require = require('url'),\n  URL = _require.URL,\n  URLSearchParams = _require.URLSearchParams;\nvar common = require('./common');\nvar _require2 = require('./intercept'),\n  remove = _require2.remove;\nvar matchBody = require('./match_body');\nvar fs;\ntry {\n  fs = require('fs');\n} catch (err) {\n  // do nothing, we're in the browser\n}\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   *\n   * Valid argument types for `uri`:\n   *  - A string used for strict comparisons with pathname.\n   *    The search portion of the URI may also be postfixed, in which case the search params\n   *    are striped and added via the `query` method.\n   *  - A RegExp instance that tests against only the pathname of requests.\n   *  - A synchronous function bound to this Interceptor instance. It's provided the pathname\n   *    of requests and must return a boolean denoting if the request is considered a match.\n   */\n  function Interceptor(scope, uri, method, requestBody, interceptorOptions) {\n    _classCallCheck(this, Interceptor);\n    var uriIsStr = typeof uri === 'string';\n    // Check for leading slash. Uri can be either a string or a regexp, but\n    // When enabled filteringScope ignores the passed URL entirely so we skip validation.\n\n    if (uriIsStr && !scope.scopeOptions.filteringScope && !scope.basePathname && !uri.startsWith('/') && !uri.startsWith('*')) {\n      throw Error(\"Non-wildcard URL path strings must begin with a slash (otherwise they won't match anything) (got: \".concat(uri, \")\"));\n    }\n    if (!method) {\n      throw new Error('The \"method\" parameter is required for an intercept call.');\n    }\n    this.scope = scope;\n    this.interceptorMatchHeaders = [];\n    this.method = method.toUpperCase();\n    this.uri = uri;\n    this._key = \"\".concat(this.method, \" \").concat(scope.basePath).concat(scope.basePathname).concat(uriIsStr ? '' : '/').concat(uri);\n    this.basePath = this.scope.basePath;\n    this.path = uriIsStr ? scope.basePathname + uri : uri;\n    this.queries = null;\n    this.options = interceptorOptions || {};\n    this.counter = 1;\n    this._requestBody = requestBody;\n\n    //  We use lower-case header field names throughout Nock.\n    this.reqheaders = common.headersFieldNamesToLowerCase(scope.scopeOptions.reqheaders || {}, true);\n    this.badheaders = common.headersFieldsArrayToLowerCase(scope.scopeOptions.badheaders || []);\n    this.delayBodyInMs = 0;\n    this.delayConnectionInMs = 0;\n    this.optional = false;\n\n    // strip off literal query parameters if they were provided as part of the URI\n    if (uriIsStr && uri.includes('?')) {\n      // localhost is a dummy value because the URL constructor errors for only relative inputs\n      var parsedURL = new URL(this.path, 'http://localhost');\n      this.path = parsedURL.pathname;\n      this.query(parsedURL.searchParams);\n      this._key = \"\".concat(this.method, \" \").concat(scope.basePath).concat(this.path);\n    }\n  }\n  _createClass(Interceptor, [{\n    key: \"optionally\",\n    value: function optionally() {\n      var flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      // The default behaviour of optionally() with no arguments is to make the mock optional.\n      if (typeof flag !== 'boolean') {\n        throw new Error('Invalid arguments: argument should be a boolean');\n      }\n      this.optional = flag;\n      return this;\n    }\n  }, {\n    key: \"replyWithError\",\n    value: function replyWithError(errorMessage) {\n      this.errorMessage = errorMessage;\n      this.options = _objectSpread(_objectSpread({}, this.scope.scopeOptions), this.options);\n      this.scope.add(this._key, this);\n      return this.scope;\n    }\n  }, {\n    key: \"reply\",\n    value: function reply(statusCode, body, rawHeaders) {\n      // support the format of only passing in a callback\n      if (typeof statusCode === 'function') {\n        if (arguments.length > 1) {\n          // It's not very Javascript-y to throw an error for extra args to a function, but because\n          // of legacy behavior, this error was added to reduce confusion for those migrating.\n          throw Error('Invalid arguments. When providing a function for the first argument, .reply does not accept other arguments.');\n        }\n        this.statusCode = null;\n        this.fullReplyFunction = statusCode;\n      } else {\n        if (statusCode !== undefined && !Number.isInteger(statusCode)) {\n          throw new Error(\"Invalid \".concat(typeof statusCode, \" value for status code\"));\n        }\n        this.statusCode = statusCode || 200;\n        if (typeof body === 'function') {\n          this.replyFunction = body;\n          body = null;\n        }\n      }\n      this.options = _objectSpread(_objectSpread({}, this.scope.scopeOptions), this.options);\n      this.rawHeaders = common.headersInputToRawArray(rawHeaders);\n      if (this.scope.date) {\n        // https://tools.ietf.org/html/rfc7231#section-7.1.1.2\n        this.rawHeaders.push('Date', this.scope.date.toUTCString());\n      }\n\n      // Prepare the headers temporarily so we can make best guesses about content-encoding and content-type\n      // below as well as while the response is being processed in RequestOverrider.end().\n      // Including all the default headers is safe for our purposes because of the specific headers we introspect.\n      // A more thoughtful process is used to merge the default headers when the response headers are finally computed.\n      this.headers = common.headersArrayToObject(this.rawHeaders.concat(this.scope._defaultReplyHeaders));\n\n      //  If the content is not encoded we may need to transform the response body.\n      //  Otherwise, we leave it as it is.\n      if (body && typeof body !== 'string' && !Buffer.isBuffer(body) && !common.isStream(body) && !common.isContentEncoded(this.headers)) {\n        try {\n          body = stringify(body);\n        } catch (err) {\n          throw new Error('Error encoding response body into JSON');\n        }\n        if (!this.headers['content-type']) {\n          // https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n          this.rawHeaders.push('Content-Type', 'application/json');\n        }\n      }\n      if (this.scope.contentLen) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        if (typeof body === 'string') {\n          this.rawHeaders.push('Content-Length', body.length);\n        } else if (Buffer.isBuffer(body)) {\n          this.rawHeaders.push('Content-Length', body.byteLength);\n        }\n      }\n      this.scope.logger('reply.headers:', this.headers);\n      this.scope.logger('reply.rawHeaders:', this.rawHeaders);\n      this.body = body;\n      this.scope.add(this._key, this);\n      return this.scope;\n    }\n  }, {\n    key: \"replyWithFile\",\n    value: function replyWithFile(statusCode, filePath, headers) {\n      if (!fs) {\n        throw new Error('No fs');\n      }\n      var readStream = fs.createReadStream(filePath);\n      readStream.pause();\n      this.filePath = filePath;\n      return this.reply(statusCode, readStream, headers);\n    }\n\n    // Also match request headers\n    // https://github.com/nock/nock/issues/163\n  }, {\n    key: \"reqheaderMatches\",\n    value: function reqheaderMatches(options, key) {\n      var reqHeader = this.reqheaders[key];\n      var header = options.headers[key];\n\n      // https://github.com/nock/nock/issues/399\n      // https://github.com/nock/nock/issues/822\n      if (header && typeof header !== 'string' && header.toString) {\n        header = header.toString();\n      }\n\n      // We skip 'host' header comparison unless it's available in both mock and\n      // actual request. This because 'host' may get inserted by Nock itself and\n      // then get recorded. NOTE: We use lower-case header field names throughout\n      // Nock. See https://github.com/nock/nock/pull/196.\n      if (key === 'host' && (header === undefined || reqHeader === undefined)) {\n        return true;\n      }\n      if (reqHeader !== undefined && header !== undefined) {\n        if (typeof reqHeader === 'function') {\n          return reqHeader(header);\n        } else if (common.matchStringOrRegexp(header, reqHeader)) {\n          return true;\n        }\n      }\n      this.scope.logger(\"request header field doesn't match:\", key, header, reqHeader);\n      return false;\n    }\n  }, {\n    key: \"match\",\n    value: function match(req, options, body) {\n      var _this = this;\n      // check if the logger is enabled because the stringifies can be expensive.\n      if (this.scope.logger.enabled) {\n        this.scope.logger('attempting match %s, body = %s', stringify(options), stringify(body));\n      }\n      var method = (options.method || 'GET').toUpperCase();\n      var _options$path = options.path,\n        path = _options$path === void 0 ? '/' : _options$path;\n      var matches;\n      var matchKey;\n      var proto = options.proto;\n      if (this.method !== method) {\n        this.scope.logger(\"Method did not match. Request \".concat(method, \" Interceptor \").concat(this.method));\n        return false;\n      }\n      if (this.scope.transformPathFunction) {\n        path = this.scope.transformPathFunction(path);\n      }\n      var requestMatchesFilter = function requestMatchesFilter(_ref) {\n        var name = _ref.name,\n          predicate = _ref.value;\n        var headerValue = req.getHeader(name);\n        if (typeof predicate === 'function') {\n          return predicate(headerValue);\n        } else {\n          return common.matchStringOrRegexp(headerValue, predicate);\n        }\n      };\n      if (!this.scope.matchHeaders.every(requestMatchesFilter) || !this.interceptorMatchHeaders.every(requestMatchesFilter)) {\n        this.scope.logger(\"headers don't match\");\n        return false;\n      }\n      var reqHeadersMatch = Object.keys(this.reqheaders).every(function (key) {\n        return _this.reqheaderMatches(options, key);\n      });\n      if (!reqHeadersMatch) {\n        this.scope.logger(\"headers don't match\");\n        return false;\n      }\n      if (this.scope.scopeOptions.conditionally && !this.scope.scopeOptions.conditionally()) {\n        this.scope.logger('matching failed because Scope.conditionally() did not validate');\n        return false;\n      }\n      var badHeaders = this.badheaders.filter(function (header) {\n        return header in options.headers;\n      });\n      if (badHeaders.length) {\n        var _this$scope;\n        (_this$scope = this.scope).logger.apply(_this$scope, ['request contains bad headers'].concat(_toConsumableArray(badHeaders)));\n        return false;\n      }\n\n      // Match query strings when using query()\n      if (this.queries === null) {\n        this.scope.logger('query matching skipped');\n      } else {\n        // can't rely on pathname or search being in the options, but path has a default\n        var _path$split = path.split('?'),\n          _path$split2 = _slicedToArray(_path$split, 2),\n          pathname = _path$split2[0],\n          search = _path$split2[1];\n        var matchQueries = this.matchQuery({\n          search: search\n        });\n        this.scope.logger(matchQueries ? 'query matching succeeded' : 'query matching failed');\n        if (!matchQueries) {\n          return false;\n        }\n\n        // If the query string was explicitly checked then subsequent checks against\n        // the path using a callback or regexp only validate the pathname.\n        path = pathname;\n      }\n\n      // If we have a filtered scope then we use it instead reconstructing the\n      // scope from the request options (proto, host and port) as these two won't\n      // necessarily match and we have to remove the scope that was matched (vs.\n      // that was defined).\n      if (this.__nock_filteredScope) {\n        matchKey = this.__nock_filteredScope;\n      } else {\n        matchKey = common.normalizeOrigin(proto, options.host, options.port);\n      }\n      if (typeof this.uri === 'function') {\n        matches = common.matchStringOrRegexp(matchKey, this.basePath) &&\n        // This is a false positive, as `uri` is not bound to `this`.\n        // eslint-disable-next-line no-useless-call\n        this.uri.call(this, path);\n      } else {\n        matches = common.matchStringOrRegexp(matchKey, this.basePath) && common.matchStringOrRegexp(path, this.path);\n      }\n      this.scope.logger(\"matching \".concat(matchKey).concat(path, \" to \").concat(this._key, \": \").concat(matches));\n      if (matches && this._requestBody !== undefined) {\n        if (this.scope.transformRequestBodyFunction) {\n          body = this.scope.transformRequestBodyFunction(body, this._requestBody);\n        }\n        matches = matchBody(options, this._requestBody, body);\n        if (!matches) {\n          this.scope.logger(\"bodies don't match: \\n\", this._requestBody, '\\n', body);\n        }\n      }\n      return matches;\n    }\n\n    /**\n     * Return true when the interceptor's method, protocol, host, port, and path\n     * match the provided options.\n     */\n  }, {\n    key: \"matchOrigin\",\n    value: function matchOrigin(options) {\n      var isPathFn = typeof this.path === 'function';\n      var isRegex = this.path instanceof RegExp;\n      var isRegexBasePath = this.scope.basePath instanceof RegExp;\n      var method = (options.method || 'GET').toUpperCase();\n      var path = options.path;\n      var proto = options.proto;\n\n      // NOTE: Do not split off the query params as the regex could use them\n      if (!isRegex) {\n        path = path ? path.split('?')[0] : '';\n      }\n      if (this.scope.transformPathFunction) {\n        path = this.scope.transformPathFunction(path);\n      }\n      var comparisonKey = isPathFn || isRegex ? this.__nock_scopeKey : this._key;\n      var matchKey = \"\".concat(method, \" \").concat(proto, \"://\").concat(options.host).concat(path);\n      if (isPathFn) {\n        return !!(matchKey.match(comparisonKey) && this.path(path));\n      }\n      if (isRegex && !isRegexBasePath) {\n        return !!matchKey.match(comparisonKey) && this.path.test(path);\n      }\n      if (isRegexBasePath) {\n        return this.scope.basePath.test(matchKey) && !!path.match(this.path);\n      }\n      return comparisonKey === matchKey;\n    }\n  }, {\n    key: \"matchHostName\",\n    value: function matchHostName(options) {\n      var basePath = this.scope.basePath;\n      if (basePath instanceof RegExp) {\n        return basePath.test(options.hostname);\n      }\n      return options.hostname === this.scope.urlParts.hostname;\n    }\n  }, {\n    key: \"matchQuery\",\n    value: function matchQuery(options) {\n      if (this.queries === true) {\n        return true;\n      }\n      var reqQueries = querystring.parse(options.search);\n      this.scope.logger('Interceptor queries: %j', this.queries);\n      this.scope.logger('    Request queries: %j', reqQueries);\n      if (typeof this.queries === 'function') {\n        return this.queries(reqQueries);\n      }\n      return common.dataEqual(this.queries, reqQueries);\n    }\n  }, {\n    key: \"filteringPath\",\n    value: function filteringPath() {\n      var _this$scope2;\n      (_this$scope2 = this.scope).filteringPath.apply(_this$scope2, arguments);\n      return this;\n    }\n\n    // TODO filtering by path is valid on the intercept level, but not filtering\n    // by request body?\n  }, {\n    key: \"markConsumed\",\n    value: function markConsumed() {\n      this.interceptionCounter++;\n      if ((this.scope.shouldPersist() || this.counter > 0) && this.interceptionCounter > 1 && this.filePath) {\n        this.body = fs.createReadStream(this.filePath);\n        this.body.pause();\n      }\n      remove(this);\n      if (!this.scope.shouldPersist() && this.counter < 1) {\n        this.scope.remove(this._key, this);\n      }\n    }\n  }, {\n    key: \"matchHeader\",\n    value: function matchHeader(name, value) {\n      this.interceptorMatchHeaders.push({\n        name: name,\n        value: value\n      });\n      return this;\n    }\n  }, {\n    key: \"basicAuth\",\n    value: function basicAuth(_ref2) {\n      var user = _ref2.user,\n        _ref2$pass = _ref2.pass,\n        pass = _ref2$pass === void 0 ? '' : _ref2$pass;\n      var encoded = Buffer.from(\"\".concat(user, \":\").concat(pass)).toString('base64');\n      this.matchHeader('authorization', \"Basic \".concat(encoded));\n      return this;\n    }\n\n    /**\n     * Set query strings for the interceptor\n     * @name query\n     * @param queries Object of query string name,values (accepts regexp values)\n     * @public\n     * @example\n     * // Will match 'http://zombo.com/?q=t'\n     * nock('http://zombo.com').get('/').query({q: 't'});\n     */\n  }, {\n    key: \"query\",\n    value: function query(queries) {\n      if (this.queries !== null) {\n        throw Error(\"Query parameters have already been defined\");\n      }\n\n      // Allow all query strings to match this route\n      if (queries === true) {\n        this.queries = queries;\n        return this;\n      }\n      if (typeof queries === 'function') {\n        this.queries = queries;\n        return this;\n      }\n      var strFormattingFn;\n      if (this.scope.scopeOptions.encodedQueryParams) {\n        strFormattingFn = common.percentDecode;\n      }\n      if (queries instanceof URLSearchParams) {\n        // Normalize the data into the shape that is matched against.\n        // Duplicate keys are handled by combining the values into an array.\n        queries = querystring.parse(queries.toString());\n      } else if (!common.isPlainObject(queries)) {\n        throw Error(\"Argument Error: \".concat(queries));\n      }\n      this.queries = {};\n      for (var _i = 0, _Object$entries = Object.entries(queries); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          key = _Object$entries$_i[0],\n          value = _Object$entries$_i[1];\n        var formatted = common.formatQueryValue(key, value, strFormattingFn);\n        var _formatted = _slicedToArray(formatted, 2),\n          formattedKey = _formatted[0],\n          formattedValue = _formatted[1];\n        this.queries[formattedKey] = formattedValue;\n      }\n      return this;\n    }\n\n    /**\n     * Set number of times will repeat the interceptor\n     * @name times\n     * @param newCounter Number of times to repeat (should be > 0)\n     * @public\n     * @example\n     * // Will repeat mock 5 times for same king of request\n     * nock('http://zombo.com).get('/').times(5).reply(200, 'Ok');\n     */\n  }, {\n    key: \"times\",\n    value: function times(newCounter) {\n      if (newCounter < 1) {\n        return this;\n      }\n      this.counter = newCounter;\n      return this;\n    }\n\n    /**\n     * An sugar syntax for times(1)\n     * @name once\n     * @see {@link times}\n     * @public\n     * @example\n     * nock('http://zombo.com).get('/').once().reply(200, 'Ok');\n     */\n  }, {\n    key: \"once\",\n    value: function once() {\n      return this.times(1);\n    }\n\n    /**\n     * An sugar syntax for times(2)\n     * @name twice\n     * @see {@link times}\n     * @public\n     * @example\n     * nock('http://zombo.com).get('/').twice().reply(200, 'Ok');\n     */\n  }, {\n    key: \"twice\",\n    value: function twice() {\n      return this.times(2);\n    }\n\n    /**\n     * An sugar syntax for times(3).\n     * @name thrice\n     * @see {@link times}\n     * @public\n     * @example\n     * nock('http://zombo.com).get('/').thrice().reply(200, 'Ok');\n     */\n  }, {\n    key: \"thrice\",\n    value: function thrice() {\n      return this.times(3);\n    }\n\n    /**\n     * Delay the response by a certain number of ms.\n     *\n     * @param {(integer|object)} opts - Number of milliseconds to wait, or an object\n     * @param {integer} [opts.head] - Number of milliseconds to wait before response is sent\n     * @param {integer} [opts.body] - Number of milliseconds to wait before response body is sent\n     * @return {Interceptor} - the current interceptor for chaining\n     */\n  }, {\n    key: \"delay\",\n    value: function delay(opts) {\n      var headDelay;\n      var bodyDelay;\n      if (typeof opts === 'number') {\n        headDelay = opts;\n        bodyDelay = 0;\n      } else if (typeof opts === 'object') {\n        headDelay = opts.head || 0;\n        bodyDelay = opts.body || 0;\n      } else {\n        throw new Error(\"Unexpected input opts \".concat(opts));\n      }\n      return this.delayConnection(headDelay).delayBody(bodyDelay);\n    }\n\n    /**\n     * Delay the response body by a certain number of ms.\n     *\n     * @param {integer} ms - Number of milliseconds to wait before response is sent\n     * @return {Interceptor} - the current interceptor for chaining\n     */\n  }, {\n    key: \"delayBody\",\n    value: function delayBody(ms) {\n      this.delayBodyInMs = ms;\n      return this;\n    }\n\n    /**\n     * Delay the connection by a certain number of ms.\n     *\n     * @param  {integer} ms - Number of milliseconds to wait\n     * @return {Interceptor} - the current interceptor for chaining\n     */\n  }, {\n    key: \"delayConnection\",\n    value: function delayConnection(ms) {\n      this.delayConnectionInMs = ms;\n      return this;\n    }\n  }]);\n  return Interceptor;\n}();","map":{"version":3,"names":["stringify","require","querystring","URL","URLSearchParams","common","remove","matchBody","fs","err","module","exports","scope","uri","method","requestBody","interceptorOptions","uriIsStr","scopeOptions","filteringScope","basePathname","startsWith","Error","interceptorMatchHeaders","toUpperCase","_key","basePath","path","queries","options","counter","_requestBody","reqheaders","headersFieldNamesToLowerCase","badheaders","headersFieldsArrayToLowerCase","delayBodyInMs","delayConnectionInMs","optional","includes","parsedURL","pathname","query","searchParams","flag","errorMessage","add","statusCode","body","rawHeaders","arguments","length","fullReplyFunction","undefined","Number","isInteger","replyFunction","headersInputToRawArray","date","push","toUTCString","headers","headersArrayToObject","concat","_defaultReplyHeaders","Buffer","isBuffer","isStream","isContentEncoded","contentLen","byteLength","logger","filePath","readStream","createReadStream","pause","reply","key","reqHeader","header","toString","matchStringOrRegexp","req","enabled","matches","matchKey","proto","transformPathFunction","requestMatchesFilter","name","predicate","value","headerValue","getHeader","matchHeaders","every","reqHeadersMatch","Object","keys","reqheaderMatches","conditionally","badHeaders","filter","split","search","matchQueries","matchQuery","__nock_filteredScope","normalizeOrigin","host","port","call","transformRequestBodyFunction","isPathFn","isRegex","RegExp","isRegexBasePath","comparisonKey","__nock_scopeKey","match","test","hostname","urlParts","reqQueries","parse","dataEqual","filteringPath","interceptionCounter","shouldPersist","user","pass","encoded","from","matchHeader","strFormattingFn","encodedQueryParams","percentDecode","isPlainObject","entries","formatted","formatQueryValue","formattedKey","formattedValue","newCounter","times","opts","headDelay","bodyDelay","head","delayConnection","delayBody","ms"],"sources":["/Users/lieo/diabetes/CUT2DMTest/node_modules/nock/lib/interceptor.js"],"sourcesContent":["'use strict'\n\nconst stringify = require('json-stringify-safe')\nconst querystring = require('querystring')\nconst { URL, URLSearchParams } = require('url')\n\nconst common = require('./common')\nconst { remove } = require('./intercept')\nconst matchBody = require('./match_body')\n\nlet fs\ntry {\n  fs = require('fs')\n} catch (err) {\n  // do nothing, we're in the browser\n}\n\nmodule.exports = class Interceptor {\n  /**\n   *\n   * Valid argument types for `uri`:\n   *  - A string used for strict comparisons with pathname.\n   *    The search portion of the URI may also be postfixed, in which case the search params\n   *    are striped and added via the `query` method.\n   *  - A RegExp instance that tests against only the pathname of requests.\n   *  - A synchronous function bound to this Interceptor instance. It's provided the pathname\n   *    of requests and must return a boolean denoting if the request is considered a match.\n   */\n  constructor(scope, uri, method, requestBody, interceptorOptions) {\n    const uriIsStr = typeof uri === 'string'\n    // Check for leading slash. Uri can be either a string or a regexp, but\n    // When enabled filteringScope ignores the passed URL entirely so we skip validation.\n\n    if (\n      uriIsStr &&\n      !scope.scopeOptions.filteringScope &&\n      !scope.basePathname &&\n      !uri.startsWith('/') &&\n      !uri.startsWith('*')\n    ) {\n      throw Error(\n        `Non-wildcard URL path strings must begin with a slash (otherwise they won't match anything) (got: ${uri})`\n      )\n    }\n\n    if (!method) {\n      throw new Error(\n        'The \"method\" parameter is required for an intercept call.'\n      )\n    }\n\n    this.scope = scope\n    this.interceptorMatchHeaders = []\n    this.method = method.toUpperCase()\n    this.uri = uri\n    this._key = `${this.method} ${scope.basePath}${scope.basePathname}${\n      uriIsStr ? '' : '/'\n    }${uri}`\n    this.basePath = this.scope.basePath\n    this.path = uriIsStr ? scope.basePathname + uri : uri\n    this.queries = null\n\n    this.options = interceptorOptions || {}\n    this.counter = 1\n    this._requestBody = requestBody\n\n    //  We use lower-case header field names throughout Nock.\n    this.reqheaders = common.headersFieldNamesToLowerCase(\n      scope.scopeOptions.reqheaders || {},\n      true\n    )\n    this.badheaders = common.headersFieldsArrayToLowerCase(\n      scope.scopeOptions.badheaders || []\n    )\n\n    this.delayBodyInMs = 0\n    this.delayConnectionInMs = 0\n\n    this.optional = false\n\n    // strip off literal query parameters if they were provided as part of the URI\n    if (uriIsStr && uri.includes('?')) {\n      // localhost is a dummy value because the URL constructor errors for only relative inputs\n      const parsedURL = new URL(this.path, 'http://localhost')\n      this.path = parsedURL.pathname\n      this.query(parsedURL.searchParams)\n      this._key = `${this.method} ${scope.basePath}${this.path}`\n    }\n  }\n\n  optionally(flag = true) {\n    // The default behaviour of optionally() with no arguments is to make the mock optional.\n    if (typeof flag !== 'boolean') {\n      throw new Error('Invalid arguments: argument should be a boolean')\n    }\n\n    this.optional = flag\n\n    return this\n  }\n\n  replyWithError(errorMessage) {\n    this.errorMessage = errorMessage\n\n    this.options = {\n      ...this.scope.scopeOptions,\n      ...this.options,\n    }\n\n    this.scope.add(this._key, this)\n    return this.scope\n  }\n\n  reply(statusCode, body, rawHeaders) {\n    // support the format of only passing in a callback\n    if (typeof statusCode === 'function') {\n      if (arguments.length > 1) {\n        // It's not very Javascript-y to throw an error for extra args to a function, but because\n        // of legacy behavior, this error was added to reduce confusion for those migrating.\n        throw Error(\n          'Invalid arguments. When providing a function for the first argument, .reply does not accept other arguments.'\n        )\n      }\n      this.statusCode = null\n      this.fullReplyFunction = statusCode\n    } else {\n      if (statusCode !== undefined && !Number.isInteger(statusCode)) {\n        throw new Error(`Invalid ${typeof statusCode} value for status code`)\n      }\n\n      this.statusCode = statusCode || 200\n      if (typeof body === 'function') {\n        this.replyFunction = body\n        body = null\n      }\n    }\n\n    this.options = {\n      ...this.scope.scopeOptions,\n      ...this.options,\n    }\n\n    this.rawHeaders = common.headersInputToRawArray(rawHeaders)\n\n    if (this.scope.date) {\n      // https://tools.ietf.org/html/rfc7231#section-7.1.1.2\n      this.rawHeaders.push('Date', this.scope.date.toUTCString())\n    }\n\n    // Prepare the headers temporarily so we can make best guesses about content-encoding and content-type\n    // below as well as while the response is being processed in RequestOverrider.end().\n    // Including all the default headers is safe for our purposes because of the specific headers we introspect.\n    // A more thoughtful process is used to merge the default headers when the response headers are finally computed.\n    this.headers = common.headersArrayToObject(\n      this.rawHeaders.concat(this.scope._defaultReplyHeaders)\n    )\n\n    //  If the content is not encoded we may need to transform the response body.\n    //  Otherwise, we leave it as it is.\n    if (\n      body &&\n      typeof body !== 'string' &&\n      !Buffer.isBuffer(body) &&\n      !common.isStream(body) &&\n      !common.isContentEncoded(this.headers)\n    ) {\n      try {\n        body = stringify(body)\n      } catch (err) {\n        throw new Error('Error encoding response body into JSON')\n      }\n\n      if (!this.headers['content-type']) {\n        // https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n        this.rawHeaders.push('Content-Type', 'application/json')\n      }\n    }\n\n    if (this.scope.contentLen) {\n      // https://tools.ietf.org/html/rfc7230#section-3.3.2\n      if (typeof body === 'string') {\n        this.rawHeaders.push('Content-Length', body.length)\n      } else if (Buffer.isBuffer(body)) {\n        this.rawHeaders.push('Content-Length', body.byteLength)\n      }\n    }\n\n    this.scope.logger('reply.headers:', this.headers)\n    this.scope.logger('reply.rawHeaders:', this.rawHeaders)\n\n    this.body = body\n\n    this.scope.add(this._key, this)\n    return this.scope\n  }\n\n  replyWithFile(statusCode, filePath, headers) {\n    if (!fs) {\n      throw new Error('No fs')\n    }\n    const readStream = fs.createReadStream(filePath)\n    readStream.pause()\n    this.filePath = filePath\n    return this.reply(statusCode, readStream, headers)\n  }\n\n  // Also match request headers\n  // https://github.com/nock/nock/issues/163\n  reqheaderMatches(options, key) {\n    const reqHeader = this.reqheaders[key]\n    let header = options.headers[key]\n\n    // https://github.com/nock/nock/issues/399\n    // https://github.com/nock/nock/issues/822\n    if (header && typeof header !== 'string' && header.toString) {\n      header = header.toString()\n    }\n\n    // We skip 'host' header comparison unless it's available in both mock and\n    // actual request. This because 'host' may get inserted by Nock itself and\n    // then get recorded. NOTE: We use lower-case header field names throughout\n    // Nock. See https://github.com/nock/nock/pull/196.\n    if (key === 'host' && (header === undefined || reqHeader === undefined)) {\n      return true\n    }\n\n    if (reqHeader !== undefined && header !== undefined) {\n      if (typeof reqHeader === 'function') {\n        return reqHeader(header)\n      } else if (common.matchStringOrRegexp(header, reqHeader)) {\n        return true\n      }\n    }\n\n    this.scope.logger(\n      \"request header field doesn't match:\",\n      key,\n      header,\n      reqHeader\n    )\n    return false\n  }\n\n  match(req, options, body) {\n    // check if the logger is enabled because the stringifies can be expensive.\n    if (this.scope.logger.enabled) {\n      this.scope.logger(\n        'attempting match %s, body = %s',\n        stringify(options),\n        stringify(body)\n      )\n    }\n\n    const method = (options.method || 'GET').toUpperCase()\n    let { path = '/' } = options\n    let matches\n    let matchKey\n    const { proto } = options\n\n    if (this.method !== method) {\n      this.scope.logger(\n        `Method did not match. Request ${method} Interceptor ${this.method}`\n      )\n      return false\n    }\n\n    if (this.scope.transformPathFunction) {\n      path = this.scope.transformPathFunction(path)\n    }\n\n    const requestMatchesFilter = ({ name, value: predicate }) => {\n      const headerValue = req.getHeader(name)\n      if (typeof predicate === 'function') {\n        return predicate(headerValue)\n      } else {\n        return common.matchStringOrRegexp(headerValue, predicate)\n      }\n    }\n\n    if (\n      !this.scope.matchHeaders.every(requestMatchesFilter) ||\n      !this.interceptorMatchHeaders.every(requestMatchesFilter)\n    ) {\n      this.scope.logger(\"headers don't match\")\n      return false\n    }\n\n    const reqHeadersMatch = Object.keys(this.reqheaders).every(key =>\n      this.reqheaderMatches(options, key)\n    )\n\n    if (!reqHeadersMatch) {\n      this.scope.logger(\"headers don't match\")\n      return false\n    }\n\n    if (\n      this.scope.scopeOptions.conditionally &&\n      !this.scope.scopeOptions.conditionally()\n    ) {\n      this.scope.logger(\n        'matching failed because Scope.conditionally() did not validate'\n      )\n      return false\n    }\n\n    const badHeaders = this.badheaders.filter(\n      header => header in options.headers\n    )\n\n    if (badHeaders.length) {\n      this.scope.logger('request contains bad headers', ...badHeaders)\n      return false\n    }\n\n    // Match query strings when using query()\n    if (this.queries === null) {\n      this.scope.logger('query matching skipped')\n    } else {\n      // can't rely on pathname or search being in the options, but path has a default\n      const [pathname, search] = path.split('?')\n      const matchQueries = this.matchQuery({ search })\n\n      this.scope.logger(\n        matchQueries ? 'query matching succeeded' : 'query matching failed'\n      )\n\n      if (!matchQueries) {\n        return false\n      }\n\n      // If the query string was explicitly checked then subsequent checks against\n      // the path using a callback or regexp only validate the pathname.\n      path = pathname\n    }\n\n    // If we have a filtered scope then we use it instead reconstructing the\n    // scope from the request options (proto, host and port) as these two won't\n    // necessarily match and we have to remove the scope that was matched (vs.\n    // that was defined).\n    if (this.__nock_filteredScope) {\n      matchKey = this.__nock_filteredScope\n    } else {\n      matchKey = common.normalizeOrigin(proto, options.host, options.port)\n    }\n\n    if (typeof this.uri === 'function') {\n      matches =\n        common.matchStringOrRegexp(matchKey, this.basePath) &&\n        // This is a false positive, as `uri` is not bound to `this`.\n        // eslint-disable-next-line no-useless-call\n        this.uri.call(this, path)\n    } else {\n      matches =\n        common.matchStringOrRegexp(matchKey, this.basePath) &&\n        common.matchStringOrRegexp(path, this.path)\n    }\n\n    this.scope.logger(`matching ${matchKey}${path} to ${this._key}: ${matches}`)\n\n    if (matches && this._requestBody !== undefined) {\n      if (this.scope.transformRequestBodyFunction) {\n        body = this.scope.transformRequestBodyFunction(body, this._requestBody)\n      }\n\n      matches = matchBody(options, this._requestBody, body)\n      if (!matches) {\n        this.scope.logger(\n          \"bodies don't match: \\n\",\n          this._requestBody,\n          '\\n',\n          body\n        )\n      }\n    }\n\n    return matches\n  }\n\n  /**\n   * Return true when the interceptor's method, protocol, host, port, and path\n   * match the provided options.\n   */\n  matchOrigin(options) {\n    const isPathFn = typeof this.path === 'function'\n    const isRegex = this.path instanceof RegExp\n    const isRegexBasePath = this.scope.basePath instanceof RegExp\n\n    const method = (options.method || 'GET').toUpperCase()\n    let { path } = options\n    const { proto } = options\n\n    // NOTE: Do not split off the query params as the regex could use them\n    if (!isRegex) {\n      path = path ? path.split('?')[0] : ''\n    }\n\n    if (this.scope.transformPathFunction) {\n      path = this.scope.transformPathFunction(path)\n    }\n    const comparisonKey = isPathFn || isRegex ? this.__nock_scopeKey : this._key\n    const matchKey = `${method} ${proto}://${options.host}${path}`\n\n    if (isPathFn) {\n      return !!(matchKey.match(comparisonKey) && this.path(path))\n    }\n\n    if (isRegex && !isRegexBasePath) {\n      return !!matchKey.match(comparisonKey) && this.path.test(path)\n    }\n\n    if (isRegexBasePath) {\n      return this.scope.basePath.test(matchKey) && !!path.match(this.path)\n    }\n\n    return comparisonKey === matchKey\n  }\n\n  matchHostName(options) {\n    const { basePath } = this.scope\n\n    if (basePath instanceof RegExp) {\n      return basePath.test(options.hostname)\n    }\n\n    return options.hostname === this.scope.urlParts.hostname\n  }\n\n  matchQuery(options) {\n    if (this.queries === true) {\n      return true\n    }\n\n    const reqQueries = querystring.parse(options.search)\n    this.scope.logger('Interceptor queries: %j', this.queries)\n    this.scope.logger('    Request queries: %j', reqQueries)\n\n    if (typeof this.queries === 'function') {\n      return this.queries(reqQueries)\n    }\n\n    return common.dataEqual(this.queries, reqQueries)\n  }\n\n  filteringPath(...args) {\n    this.scope.filteringPath(...args)\n    return this\n  }\n\n  // TODO filtering by path is valid on the intercept level, but not filtering\n  // by request body?\n\n  markConsumed() {\n    this.interceptionCounter++\n\n    if (\n      (this.scope.shouldPersist() || this.counter > 0) &&\n      this.interceptionCounter > 1 &&\n      this.filePath\n    ) {\n      this.body = fs.createReadStream(this.filePath)\n      this.body.pause()\n    }\n\n    remove(this)\n\n    if (!this.scope.shouldPersist() && this.counter < 1) {\n      this.scope.remove(this._key, this)\n    }\n  }\n\n  matchHeader(name, value) {\n    this.interceptorMatchHeaders.push({ name, value })\n    return this\n  }\n\n  basicAuth({ user, pass = '' }) {\n    const encoded = Buffer.from(`${user}:${pass}`).toString('base64')\n    this.matchHeader('authorization', `Basic ${encoded}`)\n    return this\n  }\n\n  /**\n   * Set query strings for the interceptor\n   * @name query\n   * @param queries Object of query string name,values (accepts regexp values)\n   * @public\n   * @example\n   * // Will match 'http://zombo.com/?q=t'\n   * nock('http://zombo.com').get('/').query({q: 't'});\n   */\n  query(queries) {\n    if (this.queries !== null) {\n      throw Error(`Query parameters have already been defined`)\n    }\n\n    // Allow all query strings to match this route\n    if (queries === true) {\n      this.queries = queries\n      return this\n    }\n\n    if (typeof queries === 'function') {\n      this.queries = queries\n      return this\n    }\n\n    let strFormattingFn\n    if (this.scope.scopeOptions.encodedQueryParams) {\n      strFormattingFn = common.percentDecode\n    }\n\n    if (queries instanceof URLSearchParams) {\n      // Normalize the data into the shape that is matched against.\n      // Duplicate keys are handled by combining the values into an array.\n      queries = querystring.parse(queries.toString())\n    } else if (!common.isPlainObject(queries)) {\n      throw Error(`Argument Error: ${queries}`)\n    }\n\n    this.queries = {}\n    for (const [key, value] of Object.entries(queries)) {\n      const formatted = common.formatQueryValue(key, value, strFormattingFn)\n      const [formattedKey, formattedValue] = formatted\n      this.queries[formattedKey] = formattedValue\n    }\n\n    return this\n  }\n\n  /**\n   * Set number of times will repeat the interceptor\n   * @name times\n   * @param newCounter Number of times to repeat (should be > 0)\n   * @public\n   * @example\n   * // Will repeat mock 5 times for same king of request\n   * nock('http://zombo.com).get('/').times(5).reply(200, 'Ok');\n   */\n  times(newCounter) {\n    if (newCounter < 1) {\n      return this\n    }\n\n    this.counter = newCounter\n\n    return this\n  }\n\n  /**\n   * An sugar syntax for times(1)\n   * @name once\n   * @see {@link times}\n   * @public\n   * @example\n   * nock('http://zombo.com).get('/').once().reply(200, 'Ok');\n   */\n  once() {\n    return this.times(1)\n  }\n\n  /**\n   * An sugar syntax for times(2)\n   * @name twice\n   * @see {@link times}\n   * @public\n   * @example\n   * nock('http://zombo.com).get('/').twice().reply(200, 'Ok');\n   */\n  twice() {\n    return this.times(2)\n  }\n\n  /**\n   * An sugar syntax for times(3).\n   * @name thrice\n   * @see {@link times}\n   * @public\n   * @example\n   * nock('http://zombo.com).get('/').thrice().reply(200, 'Ok');\n   */\n  thrice() {\n    return this.times(3)\n  }\n\n  /**\n   * Delay the response by a certain number of ms.\n   *\n   * @param {(integer|object)} opts - Number of milliseconds to wait, or an object\n   * @param {integer} [opts.head] - Number of milliseconds to wait before response is sent\n   * @param {integer} [opts.body] - Number of milliseconds to wait before response body is sent\n   * @return {Interceptor} - the current interceptor for chaining\n   */\n  delay(opts) {\n    let headDelay\n    let bodyDelay\n    if (typeof opts === 'number') {\n      headDelay = opts\n      bodyDelay = 0\n    } else if (typeof opts === 'object') {\n      headDelay = opts.head || 0\n      bodyDelay = opts.body || 0\n    } else {\n      throw new Error(`Unexpected input opts ${opts}`)\n    }\n\n    return this.delayConnection(headDelay).delayBody(bodyDelay)\n  }\n\n  /**\n   * Delay the response body by a certain number of ms.\n   *\n   * @param {integer} ms - Number of milliseconds to wait before response is sent\n   * @return {Interceptor} - the current interceptor for chaining\n   */\n  delayBody(ms) {\n    this.delayBodyInMs = ms\n    return this\n  }\n\n  /**\n   * Delay the connection by a certain number of ms.\n   *\n   * @param  {integer} ms - Number of milliseconds to wait\n   * @return {Interceptor} - the current interceptor for chaining\n   */\n  delayConnection(ms) {\n    this.delayConnectionInMs = ms\n    return this\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}